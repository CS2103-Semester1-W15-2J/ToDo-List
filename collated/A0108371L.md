# A0108371L
###### \src\tasknote\logic\Commands\AddCommand.java
``` java
package tasknote.logic.Commands;

import tasknote.logic.TaskNote;
import tasknote.shared.Constants;
import tasknote.shared.TaskObject;

public class AddCommand implements Command {

	private TaskNote taskNote;
	private TaskObject taskObject;
	private String statusOfOperation;

	/******************* AddCommand Constructor *********************/
	public AddCommand(TaskNote taskNote, TaskObject taskObject) {
		this.taskObject = taskObject;
		this.taskNote = taskNote;
		statusOfOperation = new String();
	}
	
	public void execute() {
		statusOfOperation = taskNote.addTask(taskObject);
	}

	public void refreshDisplay() {
		taskNote.refreshDisplay(taskNote.getTaskList());
	}

	public String getFeedBack() {
		if(statusOfOperation.equals("")){
			statusOfOperation = Constants.ERROR_FEEDBACK;
		}
		return statusOfOperation;
	}
}
```
###### \src\tasknote\logic\Commands\ChangeCategoryCommand.java
``` java
package tasknote.logic.Commands;

import tasknote.logic.TaskNote;
import tasknote.logic.ShowCategory;
import tasknote.shared.Constants;

public class ChangeCategoryCommand implements Command {

	private TaskNote taskNote;
	private ShowCategory category;
	private String statusOfOperation;

	/******************* ChangeCategoryCommand Constructor *********************/
	public ChangeCategoryCommand(TaskNote taskNote, ShowCategory category) {
		this.taskNote = taskNote;
		this.category = category;
		statusOfOperation = new String();
	}
	
	public void execute() {
		statusOfOperation = taskNote.displayCategory(category);
	}

	public void refreshDisplay() {
		taskNote.refreshDisplay(taskNote.getDisplayList());
	}

	public String getFeedBack() {
		if(statusOfOperation.equals("")){
			statusOfOperation = Constants.ERROR_FEEDBACK;
		}
		return statusOfOperation;
	}
}
```
###### \src\tasknote\logic\Commands\ChangeFilePathCommand.java
``` java
package tasknote.logic.Commands;

import tasknote.logic.TaskNote;
import tasknote.shared.Constants;

public class ChangeFilePathCommand implements Command {

	private TaskNote taskNote;
	private String filePath;
	private String statusOfOperation;
	
	/******************* ChangeFilePathCommand Constructor *********************/
	public ChangeFilePathCommand(TaskNote taskNote, String filePath) {
		this.filePath = filePath;
		this.taskNote = taskNote;
		statusOfOperation = new String();
	}
	
	public void execute() {
		statusOfOperation = taskNote.changeFilePath(filePath);
	}

	public void refreshDisplay() {
		taskNote.refreshDisplay(taskNote.getTaskList());
	}

	public String getFeedBack() {
		if(statusOfOperation.equals("")){
			statusOfOperation = Constants.ERROR_FEEDBACK;
		}
		return statusOfOperation;
	}
}
```
###### \src\tasknote\logic\Commands\Command.java
``` java
package tasknote.logic.Commands;

public interface Command {
	public void execute();
	public void refreshDisplay();
	public String getFeedBack();
}
```
###### \src\tasknote\logic\Commands\DeleteCommand.java
``` java
package tasknote.logic.Commands;

import tasknote.logic.TaskNote;
import tasknote.shared.Constants;

import java.util.ArrayList;


public class DeleteCommand implements Command {
	
	private TaskNote taskNote;
	private ArrayList<Integer> deleteIds;
	private String statusOfOperation;

	/******************* DeleteCommand Constructor *********************/
	public DeleteCommand(TaskNote taskNote, ArrayList<Integer> deleteIds) {
		this.deleteIds = deleteIds;
		this.taskNote = taskNote;
		statusOfOperation = new String();
	}

	public void execute() {
		statusOfOperation = taskNote.deleteTask(deleteIds);
	}

	public void refreshDisplay() {
		taskNote.refreshDisplay(taskNote.getTaskList());
	}

	public String getFeedBack() {
		if(statusOfOperation.equals("")){
			statusOfOperation = Constants.ERROR_FEEDBACK;
		}
		return statusOfOperation;
	}
}
```
###### \src\tasknote\logic\Commands\DoneCommand.java
``` java
package tasknote.logic.Commands;

import tasknote.logic.TaskNote;
import tasknote.shared.Constants;
import tasknote.shared.TaskObject;

public class DoneCommand implements Command  {
	
	private TaskNote taskNote;
	private int taskId;
	private String statusOfOperation;

	/******************* DoneCommand Constructor *********************/
	public DoneCommand(TaskNote taskNote, int taskId) {
		this.taskId = taskId;
		this.taskNote = taskNote;
		statusOfOperation = new String();
	}
	
	public void execute() {
		statusOfOperation = taskNote.markTaskAsComplete(taskId);
	}

	public void refreshDisplay() {
		taskNote.refreshDisplay(taskNote.getTaskList());
	}

	public String getFeedBack() {
		if(statusOfOperation.equals("")){
			statusOfOperation = Constants.ERROR_FEEDBACK;
		}
		return statusOfOperation;
	}
}
```
###### \src\tasknote\logic\Commands\HelpCommand.java
``` java
package tasknote.logic.Commands;

import tasknote.logic.TaskNote;
import tasknote.shared.Constants;
import tasknote.shared.COMMAND_TYPE;

public class HelpCommand implements Command {
	
	private TaskNote taskNote;
	private COMMAND_TYPE commandType;
	private String statusOfOperation;

	/******************* HelpCommand Constructor *********************/
	public HelpCommand(TaskNote taskNote, COMMAND_TYPE commandType) {
		this.taskNote = taskNote;
		this.commandType = commandType;
		statusOfOperation = new String();
	}
	
	public void execute() {
		statusOfOperation = TaskNote.displayHelpMessage(commandType);
	}

	public void refreshDisplay() {
		taskNote.refreshDisplay(taskNote.getDisplayList());
	}

	public String getFeedBack() {
		if(statusOfOperation.equals("")){
			statusOfOperation = Constants.ERROR_FEEDBACK;
		}
		return statusOfOperation;
	}
}
```
###### \src\tasknote\logic\Commands\RedoCommand.java
``` java
package tasknote.logic.Commands;

import tasknote.logic.TaskNote;
import tasknote.shared.Constants;

public class RedoCommand implements Command {
	
	private TaskNote taskNote;
	private String statusOfOperation;

	/******************* RedoCommand Constructor *********************/
	public RedoCommand(TaskNote taskNote) {
		this.taskNote = taskNote;
		statusOfOperation = new String();
	}
	
	public void execute() {
		statusOfOperation = taskNote.redoLastUndoCommand();
	}

	public void refreshDisplay() {
		taskNote.refreshDisplay(taskNote.getTaskList());
	}

	public String getFeedBack() {
		if(statusOfOperation.equals("")){
			statusOfOperation = Constants.ERROR_FEEDBACK;
		}
		return statusOfOperation;
	}
}
```
###### \src\tasknote\logic\Commands\SearchCommand.java
``` java
package tasknote.logic.Commands;

import tasknote.logic.TaskNote;
import tasknote.shared.Constants;
import tasknote.shared.TaskObject;

import java.util.ArrayList;

public class SearchCommand implements Command {
	
	private TaskNote taskNote;
	private ArrayList<Integer> searchIds;
	private String statusOfOperation;

	/******************* SearchCommand Constructor *********************/
	public SearchCommand(TaskNote taskNote, ArrayList<Integer> searchIds) {
		this.searchIds = searchIds;
		this.taskNote = taskNote;
		statusOfOperation = new String();
	}

	public void execute() {
		statusOfOperation = taskNote.searchTasks(searchIds);
	}
	
	public ArrayList<TaskObject> getSearchResults(){
		return taskNote.getSearchList();
	}

	public void refreshDisplay() {
		taskNote.refreshDisplay(getSearchResults());
	}

	public String getFeedBack() {
		if(statusOfOperation.equals("")){
			statusOfOperation = Constants.ERROR_FEEDBACK;
		}
		return statusOfOperation;
	}
}
```
###### \src\tasknote\logic\Commands\ShowCommand.java
``` java
package tasknote.logic.Commands;

import tasknote.logic.TaskNote;
import tasknote.logic.ShowInterval;
import tasknote.shared.Constants;


public class ShowCommand implements Command {

	private TaskNote taskNote;
	private ShowInterval timeInterval;
	private int countInterval;
	private String statusOfOperation;

	/******************* ShowCommand Constructor *********************/
	public ShowCommand(TaskNote taskNote, ShowInterval timeInterval, int countInterval) {
		this.taskNote = taskNote;
		this.timeInterval = timeInterval;
		this.countInterval = countInterval;
		statusOfOperation = new String();
	}
	
	public void execute() {
		statusOfOperation = taskNote.showTasks(timeInterval, countInterval);
	}

	public void refreshDisplay() {
		taskNote.refreshDisplay(taskNote.getShowIntervalList());
	}

	public String getFeedBack() {
		if(statusOfOperation.equals("")){
			statusOfOperation = Constants.ERROR_FEEDBACK;
		}
		return statusOfOperation;
	}
}
```
###### \src\tasknote\logic\Commands\UndoCommand.java
``` java
package tasknote.logic.Commands;

import tasknote.logic.TaskNote;
import tasknote.shared.Constants;

public class UndoCommand implements Command {
	
	private TaskNote taskNote;
	private String statusOfOperation;

	/******************* UndoCommand Constructor *********************/
	public UndoCommand(TaskNote taskNote) {
		this.taskNote = taskNote;
		statusOfOperation = new String();
	}
	
	public void execute() {
		statusOfOperation = taskNote.undoLastCommand();
	}

	public void refreshDisplay() {
		taskNote.refreshDisplay(taskNote.getTaskList());
	}

	public String getFeedBack() {
		if(statusOfOperation.equals("")){
			statusOfOperation = Constants.ERROR_FEEDBACK;
		}
		return statusOfOperation;
	}

}
```
###### \src\tasknote\logic\Commands\UndoneCommand.java
``` java
package tasknote.logic.Commands;

import tasknote.logic.TaskNote;
import tasknote.shared.Constants;
import tasknote.shared.TaskObject;

public class UndoneCommand implements Command  {
	
	private TaskNote taskNote;
	private TaskObject taskObject;
	private int taskId;
	private boolean isComplete;
	private String statusOfOperation;

	/******************* UndoneCommand Constructor *********************/
	public UndoneCommand(TaskNote taskNote, int taskId) {
		this.taskId = taskId;
		this.taskNote = taskNote;
		statusOfOperation = new String();
	}
	
	public void execute() {
		//statusOfOperation = taskNote.setTaskCompletionStatus(taskObject, isComplete);
		statusOfOperation = taskNote.markTaskAsIncomplete(taskId);
	}

	public void refreshDisplay() {
		taskNote.refreshDisplay(taskNote.getTaskList());
	}

	public String getFeedBack() {
		if(statusOfOperation.equals("")){
			statusOfOperation = Constants.ERROR_FEEDBACK;
		}
		return statusOfOperation;
	}
}
```
###### \src\tasknote\logic\Commands\UpdateCommand.java
``` java
package tasknote.logic.Commands;

import tasknote.logic.TaskNote;
import tasknote.shared.Constants;
import tasknote.shared.TaskObject;

public class UpdateCommand implements Command {
	
	private TaskNote taskNote;
	private int updateTaskId;
	private TaskObject updatedTaskObject;
	private String statusOfOperation;

	/******************* UpdateCommand Constructor *********************/
	public UpdateCommand(TaskNote taskNote, int updateTaskId, TaskObject updatedTaskObject) {
		this.updateTaskId = updateTaskId;
		this.updatedTaskObject = updatedTaskObject;
		this.taskNote = taskNote;
		statusOfOperation = new String();
	}

	public void execute() {
		statusOfOperation = taskNote.updateTask(updateTaskId, updatedTaskObject);
	}
	
	public void refreshDisplay() {
		taskNote.refreshDisplay(taskNote.getTaskList());
	}

	public String getFeedBack() {
		if(statusOfOperation.equals("")){
			statusOfOperation = Constants.ERROR_FEEDBACK;
		}
		return statusOfOperation;
	}
}
```
###### \src\tasknote\logic\History\CommandHistory.java
``` java
package tasknote.logic.History;

import java.util.Stack;

import tasknote.shared.COMMAND_TYPE;
import tasknote.shared.TaskObject;
import tasknote.shared.Constants;

public class CommandHistory {
	
	private static Stack<CommandObject> undoStack;
	private static Stack<CommandObject> redoStack;
	
	/*
	 * These are the COMMAND TYPES for the possible User Commands that 
	 * Undo function can be used on
	 */
	private static final COMMAND_TYPE undoAddCommand = COMMAND_TYPE.DELETE;
	private static final COMMAND_TYPE undoDeleteCommand = COMMAND_TYPE.ADD;
	private static final COMMAND_TYPE undoUpdateCommand = COMMAND_TYPE.UPDATE;
	private static final COMMAND_TYPE undoTaskCompletionCommand = COMMAND_TYPE.DONE;
	private static final COMMAND_TYPE undoChangeFilePathCommand = COMMAND_TYPE.CHANGE_FILE_PATH;
	
	/*
	 * These are the COMMAND TYPES for the possible User Commands that 
	 * Redo function can be used on
	 */
	private static final COMMAND_TYPE redoAddCommand = COMMAND_TYPE.ADD;
	private static final COMMAND_TYPE redoDeleteCommand = COMMAND_TYPE.DELETE;
	private static final COMMAND_TYPE redoUpdateCommand = COMMAND_TYPE.UPDATE;
	private static final COMMAND_TYPE redoTaskCompletionCommand = COMMAND_TYPE.DONE;
	private static final COMMAND_TYPE redoChangeFilePathCommand = COMMAND_TYPE.CHANGE_FILE_PATH;
	
	/*
	 * This is the Integer Constant for the number of associated preceding 
	 * tasks for an undo object
	 */
	private static final int numPrecedingObjects = Constants.PRECEDING_OBJECTS_CONSTANT;
	
	/******************* CommandHistoryObject Constructor *********************/
	public CommandHistory() {
		undoStack = new Stack<CommandObject>();
		redoStack = new Stack<CommandObject>();
	}
	
	/**
	 * This operation adds the inverse of the User's 
	 * Add Command into the Undo Stack
	 *
	 * @param: taskObject
	 */
	public void pushAddToUndo(TaskObject taskObject) {
		undoStack.push(new CommandObject(undoAddCommand, taskObject));
	}
	
	/**
	 * This operation adds the inverse of the Undo
	 * Delete Command into the Redo Stack as an ADD
	 * COMMAND TYPE
	 *
	 * @param: taskObject
	 */
	public void pushAddToRedo(TaskObject taskObject) {
		redoStack.push(new CommandObject(redoAddCommand, taskObject));
	}
	
	/**
	 * This operation adds the inverse of the User's 
	 * Delete Command into the Undo Stack
	 * 
	 * @param: taskObject
	 */
	public void pushDeleteToUndo(TaskObject taskObject) {
		undoStack.push(new CommandObject(undoDeleteCommand, taskObject));
	}
	
	/**
	 * This operation adds the inverse of the Undo
	 * Add Command into the Redo Stack as an Delete
	 * COMMAND TYPE
	 *
	 * @param: taskObject
	 */
	public void pushDeleteToRedo(TaskObject taskObject) {
		redoStack.push(new CommandObject(redoDeleteCommand, taskObject));
	}
	
	/**
	 * This operation adds the old and new task objects to 
	 * the Undo Stack as well as a null object, whose 
	 * numPrecedingUndoObjects will be set to 2
	 *
	 * @param: oldTaskObject, newTaskObject
	 */
	public void pushUpdateToUndo(TaskObject oldTaskObject, TaskObject newTaskObject) {
		pushAddToUndo(newTaskObject);
		pushDeleteToUndo(oldTaskObject);
		CommandObject undoObject = new CommandObject(undoUpdateCommand, null);
		undoObject.setPrecedingObjects(numPrecedingObjects);
		undoStack.push(undoObject);
	}
	
	/**
	 * This operation adds the old and new task objects to 
	 * the Redo Stack as well as a null object, whose 
	 * numPrecedingUndoObjects will be set to 2
	 * 
	 * Old Object is still the object that was created first
	 * New Object is the object that was created after the Old Object
	 *
	 * @param: oldTaskObject, newTaskObject
	 */
	public void pushUpdateToRedo(TaskObject oldTaskObject, TaskObject newTaskObject) {
		pushAddToRedo(newTaskObject);
		pushDeleteToRedo(oldTaskObject);
		CommandObject redoObject = new CommandObject(redoUpdateCommand, null);
		redoObject.setPrecedingObjects(numPrecedingObjects);
		redoStack.push(redoObject);
	}
	
	/**
	 * This operation adds the inverse of the User's 
	 * Complete Command into the Undo Stack
	 *
	 * @param: taskObject
	 */
	public void pushTaskCompletionToUndo(TaskObject taskObject) {
		undoStack.push(new CommandObject(undoTaskCompletionCommand, taskObject));
	}
	
	/**
	 * This operation adds the inverse of the Undo
	 * Complete Command into the Redo Stack 
	 *
	 * @param: taskObject
	 */
	public void pushTaskCompletionToRedo(TaskObject taskObject) {
		redoStack.push(new CommandObject(redoTaskCompletionCommand, taskObject));
	}
	
	/**
	 * This operation adds the User's Change File
	 * Path Command into the Undo Stack
	 *
	 */
	public void pushChangeFilePathToUndo() {
		undoStack.push(new CommandObject(undoChangeFilePathCommand, null));
	}
	
	/**
	 * This operation adds the User's Change File
	 * Path Command into the Redo Stack
	 *
	 */
	public void pushChangeFilePathToRedo() {
		redoStack.push(new CommandObject(redoChangeFilePathCommand, null));
	}
	
	public CommandObject peekUndoStack() {
		return undoStack.peek();
	}
	
	public CommandObject peekRedoStack() {
		return redoStack.peek();
	}
	
	public CommandObject popUndoStack() {
		return undoStack.pop();
	}
	
	public CommandObject popRedoStack() {
		return redoStack.pop();
	}
	
	public boolean isUndoStackEmpty() {
		return undoStack.isEmpty();
	}
	
	public boolean isRedoStackEmpty() {
		return redoStack.isEmpty();
	}

}
```
###### \src\tasknote\logic\History\CommandObject.java
``` java
package tasknote.logic.History;

import tasknote.shared.COMMAND_TYPE;
import tasknote.shared.TaskObject;

public class CommandObject {
	
	private COMMAND_TYPE commandType;
	private TaskObject taskObject;
	private int precedingObjects;
	
	/******************* CommandObject Constructor *********************/
	public CommandObject(COMMAND_TYPE commandType, TaskObject taskObject) {
		this.commandType = commandType;
		this.taskObject = taskObject;
		this.precedingObjects = 0;
	}
	
	/******************* Accessors *********************/
	public COMMAND_TYPE getRevertCommandType() {
		return this.commandType;
	}
	
	public TaskObject getTaskObject() {
		return this.taskObject;
	}
	
	public int getPrecedingObjects() {
		return this.precedingObjects;
	}
	
	/******************* Mutators *********************/
	public void setPrecedingObjects(int numPrecedingObjects) {
		this.precedingObjects = numPrecedingObjects;
	}

}
```
###### \src\tasknote\logic\JUnitTests\AddTests.java
``` java
package tasknote.logic.JUnitTests;

import static org.junit.Assert.*;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import org.junit.Assert;
import org.junit.Test;

import tasknote.logic.TaskNoteControl;
import tasknote.shared.Constants;
import tasknote.shared.TaskObject;

public class AddTests {

	TaskNoteControl tnc;
	ArrayList<TaskObject> obj;
	String command;
	String feedback;
	String output;
	String details;
	
	@Test
	public void testAdd() {
		
		resetTaskContents();
		
		tnc = new TaskNoteControl();
		
		command = "add breakfast 5pm";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = Constants.MESSAGE_ADD_SUCCESSFUL;
		String name = String.format(Constants.STRING_TASK_NAME_INDEX, 1, "breakfast 5pm");
		output = output.concat(name);
		//System.out.println(feedback);
		//System.out.println(output);
		Assert.assertEquals(output, feedback);
		
		command = "add do work    at 9am";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = Constants.MESSAGE_ADD_SUCCESSFUL;
		details = String.format(Constants.STRING_TASK_NAME_INDEX, 2, "do work");
		details = details.concat(String.format(Constants.STRING_TASK_DATE, getDate(9, 0)));
		details = details.concat(String.format(Constants.STRING_TASK_TIME, formatTime(9, 00, "AM")));
		output = output.concat(details);
		//System.out.println(feedback);
		//System.out.println(output);
		Assert.assertEquals(output, feedback);
		
		command = "add Complete Assignment by 8pm";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = Constants.MESSAGE_ADD_SUCCESSFUL;
		details = String.format(Constants.STRING_TASK_NAME_INDEX, 2, "Complete Assignment");
		details = details.concat(String.format(Constants.STRING_TASK_DATE, getDate(20, 0)));
		details = details.concat(String.format(Constants.STRING_TASK_TIME, formatTime(8, 00, "PM")));
		output = output.concat(details);
		Assert.assertEquals(output, feedback);
		
		command = "add      wedding at New York";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = Constants.MESSAGE_ADD_SUCCESSFUL;
		details = String.format(Constants.STRING_TASK_NAME_INDEX, 2, "wedding");
		details = details.concat(String.format(Constants.STRING_TASK_LOCATION, "New York"));
		output = output.concat(details);
		//System.out.println(feedback);
		//System.out.println(output);
		Assert.assertEquals(output, feedback);
		
		
		command = "add Kids Marathon on Saturday";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = Constants.MESSAGE_ADD_SUCCESSFUL;
		details = String.format(Constants.STRING_TASK_NAME_INDEX, 1, "Kids Marathon on Saturday");
		output = output.concat(details);
		//System.out.println(output);
		//System.out.println(feedback);
		Assert.assertEquals(output, feedback);
		
	}
	
	private void resetTaskContents() {
		Path taskContentsPath = Paths.get("taskContents.txt");
		ArrayList<String> resetList = new ArrayList<>();
		
		try {
			Files.write(taskContentsPath, resetList, Charset.forName("UTF-8"));
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	private static String getDate(int hour, int min){
		
		LocalDateTime now = LocalDateTime.now();
		if(now.getHour() >= hour && now.getMinute() > min){
			now = now.plusDays(1);
		}
		int currentDay = now.getDayOfMonth();
		String month = now.getMonth().name();
		month = month.substring(0, 1).toUpperCase() + month.substring(1).toLowerCase();
		int currentYear = now.getYear();
		String date = "%d %s %d";
		date = String.format(date, currentDay, month, currentYear);
		return date;
	}
	
	private static String getTime(){
		LocalDateTime now = LocalDateTime.now();
		int hour = now.getHour();
		int minute = now.getMinute();
		String amPm;
		if(hour >= 12) {
			amPm = "am";
		} else {
			amPm = "pm";
		}
		String time = "%d:%d%s";
		time = String.format(time, hour, minute, amPm);
		return time;
	}
	
	private static String formatTime(int hour, int minute, String period) {
		String time = "%02d:%02d%s";
		time = String.format(time, hour, minute, period);
		return time;
	}
	

}
```
###### \src\tasknote\logic\JUnitTests\DeleteTests.java
``` java
package tasknote.logic.JUnitTests;

import static org.junit.Assert.*;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

import org.junit.Assert;
import org.junit.Test;

import tasknote.logic.TaskNoteControl;
import tasknote.shared.TaskObject;
import tasknote.shared.Constants;

public class DeleteTests {

	TaskNoteControl tnc = new TaskNoteControl();
	ArrayList<TaskObject> obj;
	String command;
	String feedback;
	String output;
	
	@Test
	public void testDelete() {
		
		resetTaskContents();
		
		addCommands();
		
		command = "delete 1";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "Deleted 1 task(s) Successfully";
		Assert.assertEquals(output, feedback);
		
		command = "  delete 1 ";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "Deleted 1 task(s) Successfully";
		Assert.assertEquals(output, feedback);
		
		command = "  delete 1 3 - 5";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "Deleted 4 task(s) Successfully";
		Assert.assertEquals(output, feedback);
		
		/*The following are boundary cases for the ‘negative value’ partitions */
		command = "  delete    99";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "Deletion Failed\n\n";
		output = output.concat(Constants.WARNING_INVALID_DELETE_INDEX);
		System.out.println(feedback);
		System.out.println(output);
		Assert.assertEquals(output, feedback);
		
		command = "  delete    1 3 99";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "Deletion Failed\n\n";
		output = output.concat(Constants.WARNING_INVALID_DELETE_INDEX);
		Assert.assertEquals(output, feedback);

		command = "  delete    ";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "Deletion Failed\n\n";
		output = output.concat(Constants.WARNING_EMPTY_DELETEID_LIST);
		Assert.assertEquals(output, feedback);
		
		command = "  delete 1 2 3";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "Deletion Failed\n\n";
		output = output.concat(Constants.WARNING_INVALID_DELETE_INDEX);
		Assert.assertEquals(output, feedback);
	}
	
	private void resetTaskContents() {
		Path taskContentsPath = Paths.get("taskContents.txt");
		ArrayList<String> resetList = new ArrayList<>();
		
		try {
			Files.write(taskContentsPath, resetList, Charset.forName("UTF-8"));
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public static void addCommands(){
		String command;
		String feedback;
		TaskNoteControl tnc = new TaskNoteControl();
		
		command = "add Kids Marathon on Saturday";
		feedback = tnc.executeCommand(command);
		command = "add Kids Marathon 2 on Saturday";
		feedback = tnc.executeCommand(command);
		command = "add Kids Marathon 3 on Saturday";
		feedback = tnc.executeCommand(command);
		command = "add Kids Marathon 4 on Saturday";
		feedback = tnc.executeCommand(command);
		command = "add Kids Marathon 5 on Saturday";
		feedback = tnc.executeCommand(command);
		command = "add Kids Marathon 6 on Saturday";
		feedback = tnc.executeCommand(command);
		command = "add Kids Marathon 7 on Saturday";
		feedback = tnc.executeCommand(command);
	}

}
```
###### \src\tasknote\logic\JUnitTests\DoneTests.java
``` java
package tasknote.logic.JUnitTests;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

import org.junit.Assert;
import org.junit.Test;

import tasknote.logic.TaskNoteControl;
import tasknote.logic.TaskNote;
import tasknote.shared.TaskObject;
import tasknote.shared.Constants;

public class DoneTests {

	TaskNoteControl tnc = new TaskNoteControl();
	ArrayList<TaskObject> obj;
	String command;
	String feedback;
	String output;
	
	@Test
	// @condition: Task File must be empty before executing this test
	public void testMarkAsComplete() {
		
		resetTaskContents();
		
		String taskName;
		ArrayList<TaskObject> list;
		TaskObject task;
		
		command = "add Buy Vegetables next tue";
		feedback = tnc.executeCommand(command);
		command = "add Complete Assignment by tonight 9pm";
		feedback = tnc.executeCommand(command);
		
		//First test case
		command = "done 1";
		feedback = tnc.executeCommand(command);
		
		list = tnc.getDisplayList();
		task = list.get(0);
		
		output = "Task \"%s\" has been marked as completed Successfully";
		taskName = task.getTaskName();
		feedback = feedback.trim();
		Assert.assertEquals(String.format(output, taskName), feedback);
		
		
		//Second test case
		command = "done 200";
		output = "Mark as complete failed\n\n";
		output = output.concat("Invalid task ID specified: 200.\n");
		output = output.concat("Please Specify a valid TaskID to mark Task as Completed.");
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		Assert.assertEquals(output, feedback);
		
		
		//Third test case
		command = "done 0";
		output = "Mark as complete failed\n\n";
		output = output.concat("Invalid task ID specified: 0.\n");
		output = output.concat("Please Specify a valid TaskID to mark Task as Completed.");
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		Assert.assertEquals(output, feedback);
		
		
		//Fourth test case
		command = "done 1";
		feedback = tnc.executeCommand(command);

		list = tnc.getDisplayList();
		task = list.get(0);
		//System.out.println(task);
		
		output = "Task 1 is already marked as completed.\n";
		output = output.concat("To mark task as incomplete, use the UNDONE command.");
		taskName = task.getTaskName();
		feedback = feedback.trim();
		Assert.assertEquals(String.format(output, taskName), feedback);
		
		tnc.executeCommand("undone 1");
	}
	
	private void resetTaskContents() {
		Path taskContentsPath = Paths.get("taskContents.txt");
		ArrayList<String> resetList = new ArrayList<>();
		
		try {
			Files.write(taskContentsPath, resetList, Charset.forName("UTF-8"));
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
```
###### \src\tasknote\logic\JUnitTests\TaskNoteTests.java
``` java
package tasknote.logic.JUnitTests;

import org.junit.Test;
import org.junit.Assert;

import tasknote.shared.Constants;
import tasknote.shared.TaskObject;
import tasknote.logic.TaskNote;
import tasknote.logic.TaskNoteControl;

import java.util.ArrayList;

public class TaskNoteTests {

	TaskNote note = new TaskNote();
	TaskNoteControl tnc = new TaskNoteControl();
	String feedback;
	String output;
	String command;
	
	
	@Test
	public void testAddTask() {
		
		/*
		 * The following is a boundary case for the ‘negative value’ partition
		 */
		
		feedback = note.addTask(null);
		output = Constants.MESSAGE_ADD_UNSUCCESSFUL;
		Assert.assertEquals(output, feedback);
		
		

		/*
		 * The following is a test case that is part of the partition that is
		 * valid
		 */
		
		feedback = note.addTask(new TaskObject("New Task Object"));
		output = Constants.MESSAGE_ADD_SUCCESSFUL;
		String name = String.format(Constants.STRING_TASK_NAME_INDEX, 1, "New Task Object");
		output = output.concat(name);
		Assert.assertEquals(output, feedback);
	}
	
	@Test
	public void testDeleteTask() {
		ArrayList<Integer> ids = new ArrayList<Integer>();

		/*
		 * The following are boundary cases for the ‘negative value’ partitions
		 */

		// Case 1
		ids.add(-1);
		ids.add(-9);
		ids.add(-200);
		feedback = note.deleteTask(ids);
		output = Constants.MESSAGE_DELETE_UNSUCCESSFUL;
		output = output.concat("\n\nInvalid Deletion Index found. Please enter valid task IDs to delete tasks.");
		Assert.assertEquals(output, feedback);

		// Case 2
		populateTasks();
		ids.add(200);
		feedback = note.deleteTask(ids);
		output = Constants.MESSAGE_DELETE_UNSUCCESSFUL;
		output = output.concat("\n\nInvalid Deletion Index found. Please enter valid task IDs to delete tasks.");
		Assert.assertEquals(output, feedback);

		/*
		 * The following is a test case that is part of the partition that is
		 * valid
		 */
		ids = new ArrayList<Integer>();
		ids.add(1);
		ids.add(2);
		feedback = note.deleteTask(ids);
		feedback = feedback.trim();
		output = String.format(Constants.MESSAGE_DELETE_SUCCESSFUL, 2);
		Assert.assertEquals(output, feedback);

		/* This is another boundary case for the ‘negative value’ partitions */
		ids = new ArrayList<Integer>();
		feedback = note.deleteTask(ids);
		output = Constants.MESSAGE_DELETE_UNSUCCESSFUL;
		output = output.concat("\n\n• No Delete IDs specified to Delete Tasks.\n• Please specify Task ID(s) to delete corresponding Task(s).");
		Assert.assertEquals(output, feedback);
	}

	@Test
	public void testSearchTasks() {
		populateTasks();
		ArrayList<Integer> ids = new ArrayList<Integer>();

		/*
		 * The following are boundary cases for the ‘negative value’ partitions
		 */

		// Case 1
		ids.add(-1);
		ids.add(-2);
		feedback = note.searchTasks(ids);
		output = Constants.MESSAGE_SEARCH_UNSUCCESSFUL;
		Assert.assertEquals(output, feedback);

		// Case 2
		ids = new ArrayList<Integer>();
		feedback = note.searchTasks(ids);
		output = Constants.MESSAGE_SEARCH_UNSUCCESSFUL;
		Assert.assertEquals(output, feedback);

		/*
		 * The following is a test case that is part of the partition that is
		 * valid
		 */
		ids = new ArrayList<Integer>();
		ids.add(1);
		ids.add(2);
		feedback = note.searchTasks(ids);
		output = String.format(Constants.MESSAGE_SEARCH_SUCCESSFUL, 2);
		Assert.assertEquals(output, feedback);

	}

	@Test
	public void testUpdateTask() {
		populateTasks();

		/*
		 * The following are boundary cases for the ‘negative value’ partitions
		 */

		// Case 1
		int id = -1;
		feedback = note.updateTask(id, null);
		output = Constants.MESSAGE_UPDATE_UNSUCCESSFUL;
		Assert.assertEquals(output, feedback);

		// Case 2
		id = 0;
		feedback = note.updateTask(id, null);
		output = Constants.MESSAGE_UPDATE_UNSUCCESSFUL;
		Assert.assertEquals(output, feedback);

		// Case 3
		id = 1;
		feedback = note.updateTask(id, null);
		output = Constants.MESSAGE_UPDATE_UNSUCCESSFUL;
		Assert.assertEquals(output, feedback);

		/*
		 * The following is a test case that is part of the partition that is
		 * valid
		 */
		id = 1;
		feedback = note.updateTask(id, new TaskObject("New Task"));
		feedback = feedback.trim();
		output = Constants.MESSAGE_UPDATE_SUCCESSFUL;
		String name = String.format(Constants.STRING_TASK_NAME_INDEX, 1, "New Task");
		output = output.concat(name);
		Assert.assertEquals(output, feedback);
	}

	@Test
	public void testMarkCompleted() {
		/*
		 * The following are boundary cases for the ‘negative value’ partitions
		 */

		/*
		 * Note: Comment out "taskNote.loadTasks();" in TaskNote Control class
		 * in Class Constructor before testing
		 * 
		 **/

		// Case 1
		populateTasks();
		feedback = note.setTaskCompletionStatus(new TaskObject("Some New Task"), true);
		output = String.format(Constants.MESSAGE_DONE_UNSUCCESSFUL);
		Assert.assertEquals(output, feedback);

		/*
		 * The following is a test case that is part of the partition that is
		 * valid
		 */

		feedback = note.setTaskCompletionStatus(new TaskObject("breakfast 10:00"), true);
		output = String.format(Constants.MESSAGE_DONE_SUCCESSFUL, "breakfast 10:00");
		Assert.assertEquals(output, feedback);

	}
	
	@Test
	public void testUndoCommand() {
		//TODO
		feedback = note.addTask(new TaskObject("New Task Object"));
		output = String.format(Constants.MESSAGE_DONE_UNSUCCESSFUL);
		Assert.assertEquals(output, feedback);
	}

	public void populateTasks() {
		tnc = new TaskNoteControl();
		command = "add breakfast 10:00";
		feedback = tnc.executeCommand(command);
		command = "add lunch at 14:00";
		feedback = tnc.executeCommand(command);
		command = "add dinner at Marriot by 21:00";
		feedback = tnc.executeCommand(command);
	}

}
```
###### \src\tasknote\logic\JUnitTests\UndoTests.java
``` java
package tasknote.logic.JUnitTests;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

import org.junit.Assert;
import org.junit.Test;

import tasknote.logic.TaskNoteControl;
import tasknote.shared.TaskObject;

public class UndoTests {
	
	TaskNoteControl tnc = new TaskNoteControl();
	ArrayList<TaskObject> obj;
	String command;
	String feedback;
	String output;

	@Test
	public void testUndo() {
		
		resetTaskContents();
		
		//Test Case 1
		command = "add breakfast 5pm";
		tnc.executeCommand(command);
		
		command = "undo";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "The Last ADD Operation has been Undone Successfully";
		Assert.assertEquals(output, feedback);
		
		
		//Test Case 2
		command = "add breakfast 5pm";
		tnc.executeCommand(command);
		command = "add breakfast 6pm";
		tnc.executeCommand(command);
		command = "add breakfast 7pm";
		tnc.executeCommand(command);
		
		//obj = tnc.getDisplayList();
		//print(obj);
		
		command = "undo";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "The Last ADD Operation has been Undone Successfully";
		Assert.assertEquals(output, feedback);
		
		//obj = tnc.getDisplayList();
		//print(obj);
		
		
		//Test Case 3
		command = "add breakfast 7pm";
		tnc.executeCommand(command);
		command = "add breakfast 8pm";
		tnc.executeCommand(command);
		obj = tnc.getDisplayList();
		print(obj);

		command = "delete 3";
		tnc.executeCommand(command);
		obj = tnc.getDisplayList();
		print(obj);
		
		command = "undo   ";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "The Last DELETE Operation has been Undone Successfully";
		Assert.assertEquals(output, feedback);
		obj = tnc.getDisplayList();
		print(obj);
		
		
		//Test Case 4
		command = "delete 3";
		tnc.executeCommand(command);
		command = "delete 1";
		tnc.executeCommand(command);
		command = "delete 2";
		tnc.executeCommand(command);

		obj = tnc.getDisplayList();
		print(obj);
		
		command = "      undo   ";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "The Last DELETE Operation has been Undone Successfully";
		Assert.assertEquals(output, feedback);
		
		command = "undo   ";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "The Last DELETE Operation has been Undone Successfully";
		Assert.assertEquals(output, feedback);
		
		obj = tnc.getDisplayList();
		print(obj);
		
		
		//Test Case 5
		command = "delete 1 3";
		tnc.executeCommand(command);
		
		command = "undo   ";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "The Last DELETE Operation has been Undone Successfully";
		Assert.assertEquals(output, feedback);
		
		obj = tnc.getDisplayList();
		print(obj);
		
		
		//Test Case 6
		command = "edit 1 brunch 5.15pm";
		tnc.executeCommand(command);
		
		obj = tnc.getDisplayList();
		print(obj);
		
		command = "undo   ";
		feedback = tnc.executeCommand(command);
		feedback = feedback.trim();
		output = "The Last UPDATE Operation has been Undone Successfully";
		Assert.assertEquals(output, feedback);
		
		obj = tnc.getDisplayList();
		print(obj);
		
	}
	
	private void resetTaskContents() {
		Path taskContentsPath = Paths.get("taskContents.txt");
		ArrayList<String> resetList = new ArrayList<>();
		
		try {
			Files.write(taskContentsPath, resetList, Charset.forName("UTF-8"));
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public void print(ArrayList<TaskObject> obj) {
		for(int i = 0; i < obj.size(); i++) {
			System.out.println(obj.get(i).getTaskName());
		}
		System.out.println();
	}

}
```
###### \src\tasknote\logic\ShowCategory.java
``` java
package tasknote.logic;

public enum ShowCategory {
	ALL, OUTSTANDING, OVERDUE, COMPLETED;
}
```
###### \src\tasknote\logic\ShowInterval.java
``` java
package tasknote.logic;

public enum ShowInterval {
	TODAY, TOMORROW, DAY, WEEK, MONTH, YEAR, ALL;
}
```
###### \src\tasknote\logic\TaskNote.java
``` java
package tasknote.logic;

import tasknote.storage.Storage;
import tasknote.shared.TaskObject;
import tasknote.shared.TaskObject.TaskStatus;
import tasknote.shared.COMMAND_TYPE;
import tasknote.shared.Constants;
import tasknote.logic.History.CommandHistory;
import tasknote.logic.History.CommandObject;

import java.util.ArrayList;
import java.util.Collections;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.time.LocalDateTime;

public class TaskNote {

	/*
	 * These are the various lists that will be used to store the TaskObjects,
	 * Search IDs of Tasks and Search results which will then be displayed to
	 * user
	 */
	private static ArrayList<TaskObject> taskList;
	private static ArrayList<TaskObject> searchList;
	private static ArrayList<TaskObject> showIntervalList;
	private static ArrayList<TaskObject> displayList;

	private static CommandHistory history;

	private static ShowInterval showType;
	private static ShowCategory taskCategory;
	
	private static COMMAND_TYPE undoCommandType;
	private static COMMAND_TYPE redoCommandType;

	/*
	 * This is the storage object that will be used to load tasks into the
	 * taskList and it will be called to save the tasks after each user
	 * operation
	 */
	private static Storage storage = new Storage();

	/*
	 * This variable is used to store the filePath
	 */
	private static String filePath;

	/*
	 * These integers are used to store the number of results retrieved upon
	 * user's operation
	 */
	private static int searchIdSize;
	private static int deleteIdSize;
	private static int showCountInterval;

	private static Logger logger = Logger.getLogger(TaskNote.class.getName());

	public TaskNote() {
		taskList = new ArrayList<TaskObject>();
		searchList = new ArrayList<TaskObject>();
		showIntervalList = new ArrayList<TaskObject>();
		displayList = new ArrayList<TaskObject>();
		history = new CommandHistory();
		filePath = new String();
	}

	/**
	 * This operation loads the tasks from the storage after each time the
	 * application is opened
	 *
	 */
	public void loadTasks() {
		try {
			storage = new Storage();
			taskList = storage.loadTasks();
		} catch (Exception e) {
			taskList = new ArrayList<TaskObject>();
		}
		refreshDisplay(taskList);
	}

	/**
	 * This operation returns the taskList containing Task Objects
	 * 
	 * @return List of Tasks
	 */
	public ArrayList<TaskObject> getTaskList() {
		return taskList;
	}

	/**
	 * This operation returns the Search List containing Task Objects that
	 * matched the User's search
	 * 
	 * @return List of Tasks that matched User's search
	 */
	public ArrayList<TaskObject> getSearchList() {
		return searchList;
	}

	/**
	 * This operation returns the Show Interval List containing Task Objects
	 * that have deadlines in the given interval by the user
	 * 
	 * @return List of Tasks that matched User's search
	 */
	public ArrayList<TaskObject> getShowIntervalList() {
		return showIntervalList;
	}

	/**
	 * This method is called by UI after each User Operation to display the list
	 * of tasks to the User
	 *
	 * @return List of Tasks to be displayed to the User
	 */
	public ArrayList<TaskObject> getDisplayList() {
		return displayList;
	}

	/**
	 * This operation reinitializes the Search List to a new list
	 * 
	 */
	public void reIntializeSearchList() {
		searchList = new ArrayList<TaskObject>();
	}

	/**
	 * This operation refreshes the list of task to be displayed to the user
	 * after each user operation
	 *
	 * @param List
	 *            of Tasks to be displayed to the User
	 */
	public void refreshDisplay(ArrayList<TaskObject> list) {
		displayList = new ArrayList<TaskObject>();
		for (int i = 0; i < list.size(); i++) {
			displayList.add(list.get(i));
		}
	}

	/**
	 * This operation adds a taskObject to the ArrayList of TaskObjects, sorts
	 * it based on Date and Time and saves it in the Storage
	 *
	 * @param task
	 *            object
	 * @return Status of Operation
	 */
	public String addTask(TaskObject taskObject) {
		boolean isSuccess = true;
		try {
			assert (isNotNullTaskObject(taskObject) == isSuccess);
			taskList.add(taskObject);
			sortAndSave(taskList);
			history.pushAddToUndo(taskObject);
			logger.log(Level.INFO, String.format(Constants.INFO_ADD_SUCCESSFUL));
		} catch (Exception ex) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_ADD_FAILURE, ex));
		} catch (Error er) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_ADD_INVALID_OBJECT, er));
		}
		return showFeedback(COMMAND_TYPE.ADD, isSuccess, taskObject);
	}

	/**
	 * This operation deletes a task in the ArrayList of TaskObjects and saves
	 * it in the Storage
	 *
	 * @param Id
	 *            of the Task stored in ArrayList
	 * @return Status of the operation
	 */
	public String deleteTask(ArrayList<Integer> deleteIds) {
		deleteIdSize = deleteIds.size();
		String deletionErrorFeedback = new String();
		boolean isSuccess = true;
		try {
			assert (deleteIdSize > Constants.EMPTY_LIST_SIZE_CONSTANT && isValidIdList(deleteIds));
			deleteFromTaskList(deleteIds);
			storage.saveTasks(taskList);
		} catch (Exception ex) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_DELETE_FAILURE, ex));
		} catch (Error er) {
			isSuccess = false;
			if(deleteIdSize > Constants.EMPTY_LIST_SIZE_CONSTANT) {
				deletionErrorFeedback = Constants.WARNING_INVALID_DELETE_INDEX;
			} else {
				deletionErrorFeedback = Constants.WARNING_EMPTY_DELETEID_LIST;
			}
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_DELETE_INVALID_LIST, er));
		}
		String feedback = showFeedback(COMMAND_TYPE.DELETE, isSuccess, null);
		feedback = feedback.concat(Constants.STRING_CONSTANT_NEWLINE).concat(Constants.STRING_CONSTANT_NEWLINE);
		feedback = feedback.concat(deletionErrorFeedback);
		return feedback;
	}

	/**
	 * This operation searches retrieves all relevant tasks based on the given
	 * IDs from the ArrayList of TaskObjects.
	 *
	 * @param userCommand
	 * @return status of the operation
	 */
	public String searchTasks(ArrayList<Integer> searchIds) {
		boolean isSuccess = true;
		searchIdSize = searchIds.size();
		reIntializeSearchList();
		try {
			assert (searchIdSize > Constants.EMPTY_LIST_SIZE_CONSTANT);
			for (int i = 0; i < searchIds.size(); i++) {
				searchList.add(displayList.get(searchIds.get(i)));
			}
			logger.log(Level.INFO, Constants.INFO_SEARCH_SUCCESSFUL);
		} catch (Exception ex) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_SEARCH_FAILURE, ex));
		} catch (Error er) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_SEARCH_NO_RESULT, er));
		}
		return showFeedback(COMMAND_TYPE.SEARCH, isSuccess, null);
	}

	/**
	 * This operation removes the old task from the taskList, adds the updated
	 * task into the taskList, sorts and saves the list
	 *
	 * @param userCommand
	 * @return status of the operation
	 */
	public String updateTask(int updateTaskId, TaskObject updatedTaskObject) {
		boolean isSuccess = true;
		try {
			assert (isValidTaskId(updateTaskId) && updatedTaskObject != null);
			TaskObject oldTaskObject = taskList.remove(updateTaskId);
			taskList.add(updateTaskId, updatedTaskObject);
			sortAndSave(taskList);
			history.pushUpdateToUndo(oldTaskObject, updatedTaskObject);
		} catch (Exception ex) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_UPDATE_FAILURE, ex));
		} catch (Error er) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_UPDATE_INVALID_OBJECTID, er));
		}

		return showFeedback(COMMAND_TYPE.UPDATE, isSuccess, updatedTaskObject);
	}

	/**
	 * This operation reverts the action executed by the last command
	 * 
	 * @return status of the operation
	 */
	public String undoLastCommand() {
		boolean isSuccess = true;
		TaskObject taskObject = null;
		try {
			CommandObject commandObject = history.peekUndoStack();
			COMMAND_TYPE commandType = commandObject.getRevertCommandType();
			setUndoCommandType(commandType);
			//System.out.println("COMMAND TYPE = " + commandType);
			int numPrecedingObjects = commandObject.getPrecedingObjects();
			recoverByUndo(numPrecedingObjects);
			sortAndSave(taskList);
			logger.log(Level.INFO, Constants.INFO_UNDO_SUCCESSFUL);
		} catch (Exception e) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_UNDO, e));
		}

		return showFeedback(COMMAND_TYPE.UNDO, isSuccess, taskObject);
	}
	
	/**
	 * This operation reverts the last action reverted by Undo command
	 * 
	 * @return status of the operation
	 */
	public String redoLastUndoCommand() {
		boolean isSuccess = true;
		TaskObject taskObject = null;
		try {
			CommandObject commandObject = history.peekRedoStack();
			COMMAND_TYPE commandType = commandObject.getRevertCommandType();
			setRedoCommandType(commandType);
			int numPrecedingObjects = commandObject.getPrecedingObjects();
			recoverByRedo(numPrecedingObjects);
			sortAndSave(taskList);
			logger.log(Level.INFO, Constants.INFO_REDO_SUCCESSFUL);
		} catch (Exception e) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_REDO, e));
		}
		return showFeedback(COMMAND_TYPE.REDO, isSuccess, taskObject);
	}
	
	/**
	 * This operation marks a task as completed if it's
	 * current task status is set to be false (outstanding or overdue)
	 *
	 * @param taksId
	 * @return status of the operation
	 */
	public String markTaskAsComplete(int taskId) {
		TaskObject taskObject;
		String doneFeedback = new String();
		int enteredTaskId = taskId + Constants.INCREMENT_COUNT_CONSTANT;
		boolean markAsComplete = true;
		if (isValidTaskId(taskId)) {
			ArrayList<TaskObject> displayList = getDisplayList();
			taskObject = displayList.get(taskId);
			if(taskObject.getIsMarkedDone()) {
				doneFeedback = String.format(Constants.WARNING_EXECUTE_DONE_TASK_COMPLETED, enteredTaskId);
			} else {
				doneFeedback = setTaskCompletionStatus(taskObject, markAsComplete);
			}
		} else {
			taskObject = null;
			doneFeedback = Constants.MESSAGE_DONE_UNSUCCESSFUL.concat(Constants.STRING_CONSTANT_NEWLINE);
			doneFeedback = doneFeedback.concat(String.format(Constants.WARNING_EXECUTE_DONE_INVALID_ID, enteredTaskId));
		}
		return doneFeedback;
	}
	
	public String markTaskAsIncomplete(int taskId) {
		TaskObject taskObject;
		String undoneFeedback = new String();
		int enteredTaskId = taskId + Constants.INCREMENT_COUNT_CONSTANT;
		boolean markAsComplete = false;
		if (isValidTaskId(taskId)) {
			ArrayList<TaskObject> displayList = getDisplayList();
			taskObject = displayList.get(taskId);
			if(!taskObject.getIsMarkedDone()) {
				System.out.println(taskObject.getIsMarkedDone());
				undoneFeedback = String.format(Constants.WARNING_EXECUTE_DONE_TASK_INCOMPLETE, enteredTaskId);
			} else {
				undoneFeedback = setTaskCompletionStatus(taskObject, markAsComplete);
			}
		} else {
			taskObject = null;
			undoneFeedback = Constants.MESSAGE_UNDONE_UNSUCCESSFUL.concat(Constants.STRING_CONSTANT_NEWLINE);
			undoneFeedback = undoneFeedback.concat(String.format(Constants.WARNING_EXECUTE_DONE_INVALID_ID, enteredTaskId));
		}
		return undoneFeedback;
	}

	/**
	 * This operation sets the completion status of the task to be true
	 *
	 * @param TaskObject
	 * @return status of the operation
	 */
	public String setTaskCompletionStatus(TaskObject taskObject, boolean isComplete) {
		String feedback = new String();
		boolean isSuccess = true;
		try {
			assert (isValidTaskObject(taskObject) == isSuccess);
			taskObject.setIsMarkedDone(isComplete);
			history.pushTaskCompletionToUndo(taskObject);
			sortAndSave(taskList);
			if(isComplete) {
				logger.log(Level.INFO, Constants.INFO_DONE_SUCCESSFUL);
			} else {
				logger.log(Level.INFO, Constants.INFO_UNDONE_SUCCESSFUL);
			}
		} catch (Exception ex) {
			isSuccess = false;
			if(isComplete) {
				logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_COMPLETE_FAILURE, ex));
			} else {
				logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_INCOMPLETE_FAILURE, ex));
			}
		} catch (Error er) {
			isSuccess = false;
			if(isComplete) {
				logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_COMPLETE_INVALID_OBJECT, er));
			} else {
				logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_INCOMPLETE_INVALID_OBJECT, er));
			}
		}
		if(isComplete) {
			feedback = showFeedback(COMMAND_TYPE.DONE, isSuccess, taskObject);
		} else {
			feedback = showFeedback(COMMAND_TYPE.UNDONE, isSuccess, taskObject);
		}
		return feedback;
	}

	/**
	 * This operation changes the File Path to the new location specified by the
	 * user
	 *
	 * @param file
	 *            path
	 * @return status of the operation
	 */
	public String changeFilePath(String newFilePath) {
		boolean isSuccess;
		filePath = newFilePath;

		try {
			assert (!filePath.equals(Constants.STRING_CONSTANT_EMPTY) && isNotNullFilePath(filePath));
			isSuccess = storage.changePath(filePath);
			if (isSuccess) {
				history.pushChangeFilePathToUndo();
				logger.log(Level.INFO, String.format(Constants.INFO_EXECUTE_CHANGE_PATH_SUCCESSFUL, filePath));
			} else {
				logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_CHANGE_PATH_FALSE, filePath));
			}
		} catch (Exception ex) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_CHANGE_PATH_FAILURE, filePath, ex));
		} catch (Error er) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_SHOW_INVALID_FILEPATH, er));
		}
		return showFeedback(COMMAND_TYPE.CHANGE_FILE_PATH, isSuccess, null);
	}
	
	/**
	 * This operation shows the tasks within the specified time interval
	 *
	 * @param showIDs
	 * @return status of the operation
	 */
	public String showTasks(ShowInterval timeInterval, int countInterval) {
		boolean isSuccess = true;
		showIntervalList = new ArrayList<TaskObject>();
		try {
			assert (timeInterval != null);
			showCountInterval = countInterval;
			switch (timeInterval) {
			case TODAY:
				getTodayTasks();
				showType = ShowInterval.TODAY;
				break;
			case TOMORROW:
				getTomorrowTasks();
				showType = ShowInterval.TOMORROW;
				break;
			case DAY:
				getDayTasks(countInterval);
				showType = ShowInterval.DAY;
				break;
			case WEEK:
				getWeekTasks(countInterval);
				showType = ShowInterval.WEEK;
				break;
			case ALL:
				getAllTasksInInterval();
				showType = ShowInterval.ALL;
				break;
			default:
				throw new Error("Unrecognized ShowInterval type");
			}
		} catch (Exception ex) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_SHOW_FAILURE, ex));
		} catch (Error er) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_SHOW_INVALID_INTERVAL, er));
		}
		return showFeedback(COMMAND_TYPE.SHOW, isSuccess, null);
	}

	/**
	 * This operation executes the retrieval of tasks in the user specified
	 * display category
	 *
	 * @param category
	 * @return status of the operation
	 */
	public String displayCategory(ShowCategory category) {
		boolean isSuccess = true;
		try {
			assert (category != null);
			switch (category) {
			case ALL:
				displayAllTasksInInterval();
				taskCategory = ShowCategory.ALL;
				break;
			case OUTSTANDING:
				displayTasks(TaskStatus.TASK_OUTSTANDING);
				taskCategory = ShowCategory.OUTSTANDING;
				break;
			case OVERDUE:
				displayTasks(TaskStatus.TASK_OVERDUE);
				taskCategory = ShowCategory.OVERDUE;
				break;
			case COMPLETED:
				displayTasks(TaskStatus.TASK_COMPLETED);
				taskCategory = ShowCategory.COMPLETED;
				break;
			default:
				throw new Error("Unrecognized ShowInterval type");
			}
		} catch (Exception ex) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_SHOW_CATEGORY_FAILURE, category, ex));
		} catch (Error er) {
			isSuccess = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_SHOW_CATEGORY_INVALID, er));
		}
		return showFeedback(COMMAND_TYPE.CHANGE_CATEGORY, isSuccess, null);
	}
	
	/**
	 * This operation displays help messages for each command
	 *
	 * @param commandType
	 * @return help message for requested command
	 */
	public static String displayHelpMessage(COMMAND_TYPE commandType) {
		String helpMessage;
		switch(commandType) {
		case ADD:
			helpMessage = Constants.MESSAGE_HELP_ADD;
			break;
		case DELETE:
			helpMessage = Constants.MESSAGE_HELP_DELETE;
			break;
		case SEARCH:
			helpMessage = Constants.MESSAGE_HELP_SEARCH;
			break;
		case UPDATE:
			helpMessage = Constants.MESSAGE_HELP_UPDATE;
			break;
		case UNDO:
			helpMessage = Constants.MESSAGE_HELP_UNDO;
			break;
		case REDO:
			helpMessage = Constants.MESSAGE_HELP_REDO;
			break;
		case DONE:
			helpMessage = Constants.MESSAGE_HELP_DONE;
			break;
		case UNDONE:
			helpMessage = Constants.MESSAGE_HELP_UNDONE;
			break;
		case CHANGE_FILE_PATH:
			helpMessage = Constants.MESSAGE_HELP_CHANGE_FILE_PATH;
			break;
		case SHOW:
			helpMessage = Constants.MESSAGE_HELP_SHOW;
			break;
		case CHANGE_CATEGORY:
			helpMessage = Constants.MESSAGE_HELP_CHANGE_CATEGORY;
			break;
		case HELP:
			helpMessage = Constants.MESSAGE_HELP;
			break;
		case EXIT:
			helpMessage = Constants.MESSAGE_HELP_EXIT;
			break;
		default:
			helpMessage = new String();
		}
		return helpMessage;
	}
	
	/**
	 * This operation recovers the previous status of the tasks
	 * by executing the Undo operation
	 *
	 * @param numPrecedingObjects
	 * @throws Exception
	 */
	private void recoverByUndo(int numPrecedingObjects) throws Exception {
		int undoCount = Constants.EMPTY_LIST_SIZE_CONSTANT;
		try{
			while (undoCount <= numPrecedingObjects) {
				CommandObject commandObject = history.popUndoStack();
				COMMAND_TYPE commandType = commandObject.getRevertCommandType();
				//setUndoCommandType(commandType);
				if (commandType == COMMAND_TYPE.ADD) {
					undoDelete(commandObject);
				} else if (commandType == COMMAND_TYPE.DELETE) {
					undoAdd(commandObject);
				} else if (commandType == COMMAND_TYPE.UPDATE) {
					undoUpdate(commandObject);
				} else if (commandType == COMMAND_TYPE.DONE) {
					undoDone(commandObject);
				} else if (commandType == COMMAND_TYPE.CHANGE_FILE_PATH) {
					undoChangeFilePath();
				}
				history.peekRedoStack().setPrecedingObjects(numPrecedingObjects);
				undoCount++;
			}
		} catch (Exception e) {
			throw e;
		}
	}
	
	/**
	 * This operation recovers the previous status of the tasks
	 * by executing the Undo operation
	 *
	 * @param numPrecedingObjects
	 * @throws Exception 
	 */
	private void recoverByRedo(int numPrecedingObjects) throws Exception {
		int redoCount = Constants.EMPTY_LIST_SIZE_CONSTANT;
		try {
			while (redoCount <= numPrecedingObjects) {
				CommandObject commandObject = history.popRedoStack();
				COMMAND_TYPE commandType = commandObject.getRevertCommandType();
				//setRedoCommandType(commandType);
				if (commandType == COMMAND_TYPE.ADD) {
					redoAdd(commandObject);
				} else if (commandType == COMMAND_TYPE.DELETE) {
					redoDelete(commandObject);
				} else if (commandType == COMMAND_TYPE.UPDATE) {
					redoUpdate(commandObject);
				} else if (commandType == COMMAND_TYPE.DONE) {
					redoDone(commandObject);
				} else if (commandType == COMMAND_TYPE.CHANGE_FILE_PATH) {
					redoChangeFilePath();
				}
				history.peekUndoStack().setPrecedingObjects(numPrecedingObjects);
				redoCount++;
			}
		} catch (Exception e) {
			throw e; 
		}
	}
	
	/**
	 * This operation sets the type of Command that has been undone
	 *
	 * @param commandType
	 */
	private void setUndoCommandType(COMMAND_TYPE commandType) {
		if(commandType == COMMAND_TYPE.ADD) {
			undoCommandType = COMMAND_TYPE.DELETE;
		} else if(commandType == COMMAND_TYPE.DELETE) {
			undoCommandType = COMMAND_TYPE.ADD;
		}else {
			undoCommandType = commandType;
		}
	}
	
	/**
	 * This operation sets the type of Command that has been redone
	 *
	 * @param commandType
	 */
	private void setRedoCommandType(COMMAND_TYPE commandType) {
		if(commandType == COMMAND_TYPE.ADD) {
			redoCommandType = COMMAND_TYPE.DELETE;
		} else if(commandType == COMMAND_TYPE.DELETE) {
			redoCommandType = COMMAND_TYPE.ADD;
		}else {
			redoCommandType = commandType;
		}
	}
	
	/**
	 * This operation reverts the previous add command executed
	 *
	 * @param commandType
	 */
	private void undoDelete(CommandObject commandObject) {
		try{
			TaskObject taskObject = commandObject.getTaskObject();
			history.pushDeleteToRedo(taskObject);
			taskList.add(taskObject);
		} catch (Exception e) {
			throw e;
		}
	}
	
	/**
	 * This operation reverts the previous delete command executed
	 *
	 * @param commandType
	 */
	private void undoAdd(CommandObject commandObject) {
		try {
			TaskObject taskObject = commandObject.getTaskObject();
			history.pushAddToRedo(taskObject);
			taskList.remove(taskObject);
		} catch (Exception e) {
			throw e;
		}
	}
	
	/**
	 * This operation reverts the previous update command executed
	 *
	 * @param commandType
	 */
	private void undoUpdate(CommandObject commandObject) {
		try {
			CommandObject oldObject = history.popUndoStack();
			CommandObject newObject = history.popUndoStack();
			TaskObject oldTaskObject = oldObject.getTaskObject();
			TaskObject newTaskObject = newObject.getTaskObject();
			history.pushUpdateToRedo(oldTaskObject, newTaskObject);
			history.pushAddToUndo(newTaskObject);
			history.pushDeleteToUndo(oldTaskObject);
		} catch (Exception e) {
			throw e;
		}
	}
	
	/**
	 * This operation reverts the previous done command executed
	 *
	 * @param commandType
	 */
	private void undoDone(CommandObject commandObject) {
		try {
			TaskObject taskObject = commandObject.getTaskObject();
			history.pushTaskCompletionToRedo(taskObject);
			taskList.remove(taskObject);
			boolean isComplete = taskObject.getIsMarkedDone();
			taskObject.setIsMarkedDone(!isComplete);
			isComplete = taskObject.getIsMarkedDone();
			taskList.add(taskObject);
		} catch (Exception e) {
			throw e;
		}
	}
	
	/**
	 * This operation reverts the previous change file path
	 * command executed
	 *
	 * @param commandType
	 * @throws Exception 
	 */
	private void undoChangeFilePath() throws Exception {
		try {
			boolean isPathUndone = storage.undoPath();
			if (isPathUndone) {
				history.pushChangeFilePathToRedo();
			}
		} catch (Exception e) {
			throw e;
		}
	}
	
	/**
	 * This operation reverts the previous undo command for 
	 * Add operation
	 *
	 * @param commandType
	 */
	private void redoAdd(CommandObject commandObject) {
		try{
			TaskObject taskObject = commandObject.getTaskObject();
			history.pushAddToUndo(taskObject);
			taskList.add(taskObject);
		} catch (Exception e) {
			throw e;
		}
	}
	
	/**
	 * This operation reverts the previous undo command for 
	 * Delete operation
	 *
	 * @param commandType
	 */
	private void redoDelete(CommandObject commandObject) {
		try{
			TaskObject taskObject = commandObject.getTaskObject();
			history.pushDeleteToUndo(taskObject);
			taskList.remove(taskObject);
		} catch (Exception e) {
			throw e;
		}
	}
	
	/**
	 * This operation reverts the previous undo command for 
	 * Update operation
	 *
	 * @param commandType
	 */
	private void redoUpdate(CommandObject commandObject) {
		try{
			CommandObject oldObject = history.popRedoStack();
			CommandObject newObject = history.popRedoStack();
			TaskObject oldTaskObject = oldObject.getTaskObject();
			TaskObject newTaskObject = newObject.getTaskObject();
			history.pushUpdateToUndo(oldTaskObject, newTaskObject);
			history.pushAddToUndo(oldTaskObject);
			history.pushDeleteToUndo(newTaskObject);
		} catch (Exception e) {
			throw e;
		}
	}
	
	/**
	 * This operation reverts the previous undo command for 
	 * Done operation
	 *
	 * @param commandType
	 */
	private void redoDone(CommandObject commandObject) {
		try{
			TaskObject taskObject = commandObject.getTaskObject();
			history.pushTaskCompletionToUndo(taskObject);
			taskList.remove(taskObject);
			boolean isComplete = taskObject.getIsMarkedDone();
			taskObject.setIsMarkedDone(!isComplete);
			isComplete = taskObject.getIsMarkedDone();
			taskList.add(taskObject);
		} catch (Exception e) {
			throw e;
		}
	}
	
	/**
	 * This operation reverts the previous undo command for 
	 * Change File Path operation
	 *
	 * @param commandType
	 * @throws Exception 
	 */
	private void redoChangeFilePath() throws Exception {
		try{
			boolean isPathRedone = storage.redoPath();
			if (isPathRedone) {
				history.pushChangeFilePathToUndo();
			}
		} catch (Exception e) {
			throw e;
		}
	}
	
	/**
	 * This operation populates tasks in Search Interval List with task objects
	 * that have deadlines today
	 * 
	 */
	private void getTodayTasks() {
		LocalDateTime now = LocalDateTime.now();
		int currentYear = now.getYear();
		int currentMonth = now.getMonthValue();
		int currentDay = now.getDayOfMonth();

		try {
			populateTdyTmrShowList(currentYear, currentMonth, currentDay);
		} catch (Exception e) {
			throw e;
		}
	}

	/**
	 * This operation populates tasks in Search Interval List with task objects
	 * that have deadlines tomorrow
	 * 
	 */
	private void getTomorrowTasks() {
		LocalDateTime now = LocalDateTime.now();
		now = now.plusDays(Constants.INCREMENT_DAY_TOMORROW_CONSTANT);

		int tomorrowYear = now.getYear();
		int tomorrowMonth = now.getMonthValue();
		int tomorrowDay = now.getDayOfMonth();

		try {
			populateTdyTmrShowList(tomorrowYear, tomorrowMonth, tomorrowDay);
		} catch (Exception e) {
			throw e;
		}
	}

	/**
	 * This operation populates tasks in Search Interval List with task objects
	 * that have deadlines within the next specified number of days by the user
	 * 
	 * E.g. of User Command: Show next 5 days
	 * 
	 * @param: number
	 *             of days
	 * 
	 */
	private void getDayTasks(int days) {
		try {
			assert (days > Constants.ZERO_TIME_INTERVAL_CONSTANT);
			LocalDateTime startDateTime = LocalDateTime.now();
			LocalDateTime endDateTime = startDateTime.plusDays(days);
			populateDayWeekShowList(startDateTime, endDateTime);
		} catch (Exception ex) {
			throw ex;
		} catch (Error er) {
			throw er;
		}
	}

	/**
	 * This operation populates tasks in Search Interval List with task objects
	 * that have deadlines within the next specified number of weeks by the user
	 * 
	 * E.g. of User Command: Show next 1 week
	 * 
	 * @param: number
	 *             of weeks
	 * 
	 */
	private void getWeekTasks(int weeks) {
		try {
			assert (weeks > Constants.ZERO_TIME_INTERVAL_CONSTANT);
			LocalDateTime startDateTime = LocalDateTime.now();
			LocalDateTime endDateTime = startDateTime.plusWeeks(weeks);
			populateDayWeekShowList(startDateTime, endDateTime);
		} catch (Exception ex) {
			throw ex;
		} catch (Error er) {
			throw er;
		}
	}
	
	/**
	 * This operation retrieves all the tasks from the Task List
	 * and populates the showInterval List
	 *
	 */
	private void getAllTasksInInterval() {
		try {
			for (int i = 0; i < taskList.size(); i++) {
				TaskObject taskObject = taskList.get(i);
				showIntervalList.add(taskObject);
			}
		} catch (Exception e) {
			throw e;
		}
	}

	private void displayAllTasksInInterval() {
		getAllTasksInInterval();
		refreshDisplay(showIntervalList);
	}

	/**
	 * This operation populates tasks in the user specified category in the list
	 * to be displayed to the user
	 * 
	 * @param: taskStatus
	 * 
	 */
	private void displayTasks(TaskStatus taskStatus) {
		ArrayList<TaskObject> list = new ArrayList<TaskObject>();
		for (int i = 0; i < taskList.size(); i++) {
			TaskObject task = taskList.get(i);
			if (task.getTaskStatus() == taskStatus) {
				list.add(task);
			}
		}
		refreshDisplay(list);
	}

	/**
	 * This operation populates tasks that are either due today
	 * or tomorrow based on the calling method
	 * 
	 * @param: year, month, day
	 */
	private void populateTdyTmrShowList(int year, int month, int day) {
		for (int i = 0; i < taskList.size(); i++) {
			TaskObject taskObject = taskList.get(i);
			String taskType = taskObject.getTaskType();
			if (taskType.equalsIgnoreCase(Constants.STRING_TASKTYPE_DEADLINE)) {
				int taskDay = taskObject.getDateDay();
				int taskMonth = taskObject.getDateMonth();
				int taskYear = taskObject.getDateYear();

				if (year == taskYear && month == taskMonth && day == taskDay) {
					showIntervalList.add(taskObject);
				}
			}
		}
	}
	
	/**
	 * This operation populates tasks that are either due within 
	 * a specified number of days or weeks
	 * 
	 * @param: startDateTime, endDateTime
	 */
	private void populateDayWeekShowList(LocalDateTime startDateTime, LocalDateTime endDateTime) {
		for (int i = 0; i < taskList.size(); i++) {
			TaskObject taskObject = taskList.get(i);
			String taskType = taskObject.getTaskType();
			if (taskType.equalsIgnoreCase(Constants.STRING_TASKTYPE_DEADLINE)) {
				LocalDateTime taskDateTime = getTaskDateTime(taskObject);
				if ((taskDateTime.isEqual(startDateTime) || taskDateTime.isAfter(startDateTime))
						&& (taskDateTime.isEqual(endDateTime) || taskDateTime.isBefore(endDateTime))) {
					showIntervalList.add(taskObject);
				}
			}
		}
	}
	
	/**
	 * This operation returns a date time object based on the
	 * taskObject's date time if specified. Otherwise it assigns
	 * the latest hour and minute possible on the given day.
	 * 
	 * @param: taskObject
	 */
	private LocalDateTime getTaskDateTime(TaskObject taskObject) {
		int taskDay = taskObject.getDateDay();
		int taskMonth = taskObject.getDateMonth();
		int taskYear = taskObject.getDateYear();
		int taskHour = taskObject.getDateHour();
		int taskMinute = taskObject.getDateMinute();
		if(taskHour == Constants.INVALID_VALUE_CONSTANT) {
			taskHour = Constants.TIME_LATEST_HOUR_CONSTANT;
		}
		if(taskMinute == Constants.INVALID_VALUE_CONSTANT) {
			taskMinute = Constants.TIME_LATEST_MINUTE_CONSTANT;
		}
		LocalDateTime taskDateTime = LocalDateTime.of(taskYear, taskMonth, taskDay, taskHour, taskMinute);
		return taskDateTime;
	}

	private boolean isNotNullFilePath(String filePath) {
		boolean isNotNull = (filePath != null);
		return isNotNull;
	}

	private boolean isNotNullTaskObject(TaskObject taskObject) {
		boolean isNotNull = (taskObject != null);
		return isNotNull;
	}

	private boolean isValidTaskObject(TaskObject taskObject) {
		boolean isValid = taskList.contains(taskObject);
		return isValid;
	}

	/**
	 * This operation returns True if all IDs are valid;
	 * Otherwise False
	 * 
	 * @param: ID List
	 */
	private boolean isValidIdList(ArrayList<Integer> idList) {
		boolean isValid = true;
		if (deleteIdSize > Constants.EMPTY_LIST_SIZE_CONSTANT) {
			logger.log(Level.FINE, String.format(Constants.FINE_DELETE_LIST_VALIDITY, idList.size()));
			for (int i = 0; i < idList.size(); i++) {
				int taskId = idList.get(i);
				if (!isValidTaskId(taskId)) {
					isValid = false;
					break;
				}
				logger.log(Level.FINER,
						String.format(Constants.FINER_VALID_DELETE_ID, i, displayList.get(i).getTaskName()));
			}
		} else {
			isValid = false;
			logger.log(Level.INFO, String.format(Constants.INFO_DELETE_LIST, deleteIdSize));
		}
		return isValid;
	}
	
	/**
	 * This operation deletes the corresponding tasks based on IDs
	 * from the taskList
	 * 
	 * @param: deleteIdList
	 */
	private static void deleteFromTaskList(ArrayList<Integer> deleteIds) {
		for (int i = 0; i < deleteIds.size(); i++) {
			TaskObject taskObject = displayList.get(deleteIds.get(i));
			int index = taskList.indexOf(taskObject);
			taskList.remove(index);
			history.pushDeleteToUndo(taskObject);
		}
		CommandObject commandObject = history.peekUndoStack();
		commandObject.setPrecedingObjects(deleteIdSize - Constants.DECREMENT_PRECEDING_OBJECTS_CONSTANT);
	}

	public boolean isValidTaskId(int taskId) {
		boolean isValid = true;
		if (taskId >= displayList.size() || taskId < Constants.EMPTY_LIST_SIZE_CONSTANT) {
			isValid = false;
			logger.log(Level.WARNING, String.format(Constants.WARNING_INVALID_DELETE_ID, taskId));
		}
		return isValid;
	}
	
	private static int getLatestTaskIndex(TaskObject taskObject) {
		int latestIndex = Constants.INVALID_VALUE_CONSTANT;
		for (int i = 0; i < taskList.size(); i++) {
			TaskObject currentTaskObject = taskList.get(i);
			if(taskObject.equals(currentTaskObject)){
				latestIndex = i;
			}
		}
		return latestIndex;
	}

	/**
	 * This operation sorts the list of Tasks and saves them to Storage
	 *
	 * @param Task
	 *            List
	 * @throws Exception
	 */
	private static void sortAndSave(ArrayList<TaskObject> taskList) throws Exception {
		try {
			sortByDate(taskList);
			storage.saveTasks(taskList);
		} catch (Exception e) {
			logger.log(Level.WARNING, String.format(Constants.WARNING_EXECUTE_SORT_SAVE, e));
			throw e;
		}
	}

	/**
	 * This operation sorts all tasks based on the date-time of the task
	 *
	 * @param list
	 *            to be sorted
	 * @throws Exception
	 */
	private static void sortByDate(ArrayList<TaskObject> list) throws Exception {
		try {
			// Sort by Date-Time
			Collections.sort(list);
		} catch (Exception e) {
			throw e;
		}
	}

	/**
	 * This operation constructs the feedback to be displayed to the User after
	 * each User Operation
	 *
	 * @param Command
	 *            type, isSuccess(true if User operation is executed
	 *            successfully; Otherwise false), Task Object
	 *
	 * @return Feedback to the User
	 */
	private static String showFeedback(COMMAND_TYPE commandType, boolean isSuccess, TaskObject taskObject) {

		switch (commandType) {
		case ADD:
			return getAddFeedback(isSuccess, taskObject);
		case DELETE:
			return getDeleteFeedback(isSuccess, taskObject);
		case SEARCH:
			return getSearchFeedback(isSuccess, taskObject);
		case UPDATE:
			return getUpdateFeedback(isSuccess, taskObject);
		case UNDO:
			return getUndoFeedback(isSuccess, taskObject);
		case REDO:
			return getRedoFeedback(isSuccess, taskObject);
		case DONE:
			return getDoneFeedback(isSuccess, taskObject);
		case UNDONE:
			return getUndoneFeedback(isSuccess, taskObject);
		case CHANGE_FILE_PATH:
			return getChangeFilePathFeedback(isSuccess, taskObject);
		case SHOW:
			return getShowFeedback(isSuccess, taskObject);
		case CHANGE_CATEGORY:
			return getChangeCategoryFeedback(isSuccess, taskObject);
		default:
			throw new Error("Unrecognized command type");
		}
	}
	
	private static String getAddFeedback(boolean isSuccess, TaskObject taskObject) {
		String feedback = new String();
		if (isSuccess && taskObject != null) {
			feedback = Constants.MESSAGE_ADD_SUCCESSFUL;
			feedback = getFeedbackDetails(feedback, taskObject);
		} else {
			feedback =  Constants.MESSAGE_ADD_UNSUCCESSFUL;
		}
		return feedback;
	}
	
	private static String getDeleteFeedback(boolean isSuccess, TaskObject taskObject) {
		String feedback = new String();
		if (isSuccess) {
			feedback =  String.format(Constants.MESSAGE_DELETE_SUCCESSFUL, deleteIdSize);
		} else {
			feedback = Constants.MESSAGE_DELETE_UNSUCCESSFUL;
		}
		return feedback;
	}
	
	private static String getSearchFeedback(boolean isSuccess, TaskObject taskObject) {
		String feedback = new String();
		if (isSuccess) {
			feedback = String.format(Constants.MESSAGE_SEARCH_SUCCESSFUL, searchIdSize);
		} else {
			feedback = Constants.MESSAGE_SEARCH_UNSUCCESSFUL;
		}
		return feedback;
	}
	
	private static String getUpdateFeedback(boolean isSuccess, TaskObject taskObject) {
		String feedback = new String();
		if (isSuccess && taskObject != null) {
			feedback =  Constants.MESSAGE_UPDATE_SUCCESSFUL;
			feedback = getFeedbackDetails(feedback, taskObject);
		} else if (isSuccess && taskObject == null) {
			feedback =  Constants.MESSAGE_UPDATE_SUCCESSFUL;
		} else {
			feedback = Constants.MESSAGE_UPDATE_UNSUCCESSFUL;
		}
		return feedback;
	}
	
	private static String getUndoFeedback(boolean isSuccess, TaskObject taskObject) {
		String feedback = new String();
		if (isSuccess) {
			feedback = Constants.MESSAGE_UNDO_SUCCESSFUL;
			feedback = getUndoFeedbackDetails(feedback);
		} else {
			feedback = Constants.MESSAGE_UNDO_UNSUCCESSFUL;
		}
		return feedback;
	}
	
	private static String getRedoFeedback(boolean isSuccess, TaskObject taskObject) {
		String feedback = new String();
		if (isSuccess) {
			feedback = Constants.MESSAGE_REDO_SUCCESSFUL;
			feedback = getRedoFeedbackDetails(feedback);
		} else {
			feedback = Constants.MESSAGE_REDO_UNSUCCESSFUL;
		}
		return feedback;
	}
	
	private static String getDoneFeedback(boolean isSuccess, TaskObject taskObject) {
		String feedback = new String();
		if (isSuccess && taskObject != null) {
			String taskName = taskObject.getTaskName();
			feedback = String.format(Constants.MESSAGE_DONE_SUCCESSFUL, taskName);
		} else {
			feedback = Constants.MESSAGE_DONE_UNSUCCESSFUL;
		}
		return feedback;
	}
	
	private static String getUndoneFeedback(boolean isSuccess, TaskObject taskObject) {
		String feedback = new String();
		if (isSuccess && taskObject != null) {
			String taskName = taskObject.getTaskName();
			feedback = String.format(Constants.MESSAGE_UNDONE_SUCCESSFUL, taskName);
		} else {
			feedback = Constants.MESSAGE_UNDONE_UNSUCCESSFUL;
		}
		return feedback;
	}
	
	private static String getChangeFilePathFeedback(boolean isSuccess, TaskObject taskObject) {
		String feedback = new String();
		if (isSuccess) {
			feedback = String.format(Constants.MESSAGE_CHANGE_PATH_SUCCESSFUL, filePath);
		} else {
			feedback = String.format(Constants.MESSAGE_CHANGE_PATH_UNSUCCESSFUL, filePath);
		}
		return feedback;
	}
	
	private static String getShowFeedback(boolean isSuccess, TaskObject taskObject) {
		String feedback = new String();
		if (isSuccess) {
			int numTasks = showIntervalList.size();
			if (numTasks > Constants.EMPTY_LIST_SIZE_CONSTANT) {
				if (showType == ShowInterval.ALL) {
					feedback = Constants.MESSAGE_SHOW_SUCCESSFUL_ALL;
				} else {
					if (showCountInterval > Constants.EMPTY_LIST_SIZE_CONSTANT) {
						feedback = String.format(Constants.MESSAGE_SHOW_SUCCESSFUL_DEADLINE_INTERVAL, numTasks,
								showCountInterval, showType);
					} else {
						feedback = String.format(Constants.MESSAGE_SHOW_SUCCESSFUL_DEADLINE, numTasks, showType);
					}
				}
			} else {
				feedback = String.format(Constants.MESSAGE_SHOW_NO_RESULTS, numTasks, showType);
			}

		} else {
			feedback = String.format(Constants.MESSAGE_SHOW_UNSUCCESSFUL, showType);
		}
		return feedback;
	}
	
	private static String getChangeCategoryFeedback(boolean isSuccess, TaskObject taskObject) {
		String feedback = new String();
		if (isSuccess) {
			feedback = String.format(Constants.MESSAGE_CHANGE_CATEGORY_SUCCESSFUL, taskCategory);
		} else {
			feedback = String.format(Constants.MESSAGE_CHANGE_CATEGORY_UNSUCCESSFUL, taskCategory);
		}
		return feedback;
	}
	
	private static String getFeedbackDetails(String feedback, TaskObject taskObject) {
		feedback = getFeedbackName(feedback, taskObject);
		if(taskObject.getTaskType() != null) {
			feedback = getFeedbackDateTime(feedback, taskObject);
		}
		feedback = getFeedbackLocation(feedback, taskObject);
		return feedback;
	}
	
	private static String getUndoFeedbackDetails(String feedback) {
		String feedbackUndoOperation = String.format(feedback, undoCommandType);
		return feedbackUndoOperation;
	}
	
	private static String getRedoFeedbackDetails(String feedback) {
		String feedbackUndoOperation = String.format(feedback, redoCommandType);
		return feedbackUndoOperation;
	}
	
	private static String getFeedbackDateTime(String feedback, TaskObject taskObject){
		String taskType = taskObject.getTaskType();
		if(taskType.equalsIgnoreCase(Constants.STRING_TASKTYPE_DEADLINE)){
			feedback = getFeedbackDate(feedback, taskObject);
			feedback = getFeedbackTime(feedback,taskObject);
		}
		return feedback;
	}
	
	private static String getFeedbackName(String feedback, TaskObject taskObject) {
		//int taskIndex = taskList.indexOf(taskObject);
		int taskIndex = getLatestTaskIndex(taskObject);
		String taskName = taskObject.getTaskName();
		String feedbackName = String.format(Constants.STRING_TASK_NAME_INDEX, ++taskIndex, taskName);
		feedback = feedback.concat(feedbackName);
		return feedback;
	}
	
	private static String getFeedbackDate(String feedback, TaskObject taskObject) {
		if(!taskObject.getFormattedDate().equals(Constants.STRING_CONSTANT_EMPTY)){
			String date = String.format(Constants.STRING_TASK_DATE, taskObject.getFormattedDate());
			feedback = feedback.concat(date);
		}
		return feedback;
	}
	
	private static String getFeedbackTime(String feedback, TaskObject taskObject) {
		if(!taskObject.getFormattedTime().equals(Constants.STRING_CONSTANT_EMPTY)){
			String time = String.format(Constants.STRING_TASK_TIME, taskObject.getFormattedTime());
			feedback = feedback.concat(time);
		}
		return feedback;
	}
	
	private static String getFeedbackLocation(String feedback, TaskObject taskObject) {
		if(taskObject.getLocation() != null && !taskObject.getLocation().equals(Constants.STRING_CONSTANT_EMPTY)) {
			String location = String.format(Constants.STRING_TASK_LOCATION,taskObject.getLocation()); 
			feedback = feedback.concat(location);
		}
		return feedback;
	}
}
```
###### \src\tasknote\logic\TaskNoteControl.java
``` java
package tasknote.logic;

import tasknote.logic.Commands.Command;
import tasknote.logic.Commands.AddCommand;
import tasknote.logic.Commands.DeleteCommand;
import tasknote.logic.Commands.ChangeCategoryCommand;
import tasknote.logic.Commands.ChangeFilePathCommand;
import tasknote.logic.Commands.HelpCommand;
import tasknote.logic.Commands.SearchCommand;
import tasknote.logic.Commands.UpdateCommand;
import tasknote.logic.Commands.DoneCommand;
import tasknote.logic.Commands.UndoneCommand;
import tasknote.logic.Commands.UndoCommand;
import tasknote.logic.Commands.RedoCommand;
import tasknote.logic.Commands.ShowCommand;
import tasknote.logic.ShowCategory;
import tasknote.logic.ShowInterval;
import tasknote.parser.Parser;
import tasknote.shared.TaskObject;
import tasknote.shared.COMMAND_TYPE;
import tasknote.shared.Constants;

import java.util.ArrayList;

/**
 * This class is used to interact directly with the UI to process and execute
 * User Commands. 
 * The Command object will be used to create a new instance of
 * the corresponding Command Class. 
 * This Class interacts with the Parser Component, which parses the User Command 
 * and returns relevant data. 
 * Once each command is executed, the task list will be updated with the relevant 
 * task objects to be displayed to the User. Each method in this class that executes
 * a command returns a feedback String to the caller.
 *
 * @author Murali Girish Narayanan
 */

public class TaskNoteControl {

	private static TaskNote taskNote;
	private static Command command;
	private static Parser parser;

	public TaskNoteControl() {
		taskNote = new TaskNote();
		parser = new Parser();
		taskNote.loadTasks();
	}
	
	/**
	 * This operation returns the list to be displayed to the user
	 *
	 * @return List of TaskObjects
	 */
	public ArrayList<TaskObject> getDisplayList() {
		return taskNote.getDisplayList();
	}

	/**
	 * This operation gets the command type and executes the requested action
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */
	public String executeCommand(String userCommand) {

		COMMAND_TYPE commandType;
		try {
			parser.setInputString(userCommand);
			commandType = parser.getCommandType();
		} catch (Exception e) {
			commandType = parser.getCommandType();
		}
		String feedback = executeAction(commandType, userCommand);
		return feedback;
	}

	/**
	 * This operation executes the user command
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */
	private static String executeAction(COMMAND_TYPE commandType, String userCommand) {
		String response;
		taskNote.reIntializeSearchList();
		switch (commandType) {
		case ADD:
			response = executeAdd(userCommand);
			break;
		case DELETE:
			response = executeDelete(userCommand);
			break;
		case SEARCH:
			response = executeSearch(userCommand);
			break;
		case UPDATE:
			response = executeUpdate(userCommand);
			break;
		case UNDO:
			response = executeUndo();
			break;
		case REDO:
			response = executeRedo(userCommand);
			break;
		case DONE:
			response = executeMarkAsComplete(userCommand);
			break;
		case UNDONE:
			response = executeMarkAsIncomplete(userCommand);
			break;
		case CHANGE_FILE_PATH:
			response = executeChangeFilePath(userCommand);
			break;
		case SHOW:
			response = executeShow(userCommand);
			break;
		case CHANGE_CATEGORY:
			// TODO: Parser
			response = executeChangeCategory(userCommand);
			// response = "";
			break;
		case HELP:
			// TODO: Parser
			response = executeHelp(userCommand);
			break;
		case INVALID:
			response = Constants.WARNING_INVALID_COMMAND;
			break;
		case EXIT:
			System.exit(0);
		default:
			throw new Error("Unrecognized command type");
		}
		return response;
	}

	/**
	 * This operation executes the User's Add command
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */
	private static String executeAdd(String userCommand) {
		TaskObject taskObject;
		boolean throwException = true;
		String parserFeedback = new String(Constants.STRING_CONSTANT_SPACE);
		try {
			taskObject = parser.parseAdd(throwException);
		} catch (Exception e) {
			throwException = false;
			parserFeedback = e.getMessage();
			taskObject = parser.parseAdd(throwException);
		}
		command = new AddCommand(taskNote, taskObject);
		command.execute();
		command.refreshDisplay();
		String response = command.getFeedBack();
		response = response.concat(Constants.STRING_CONSTANT_NEWLINE).concat(parserFeedback);
		return response;
	}

	/**
	 * This operation executes the User's Delete command
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */
	private static String executeDelete(String userCommand) {
		ArrayList<Integer> deleteIds;
		boolean throwException = true;
		String parserFeedback = new String(Constants.STRING_CONSTANT_SPACE);
		try {
			deleteIds = parser.parseDelete(throwException);
		} catch (Exception e) {
			throwException = false;
			parserFeedback = e.getMessage();
			//deleteIds = parser.parseDelete(throwException);
			deleteIds = new ArrayList<Integer>();
		}
		command = new DeleteCommand(taskNote, deleteIds);
		command.execute();
		command.refreshDisplay();
		String response = command.getFeedBack();
		response = response.concat(Constants.STRING_CONSTANT_NEWLINE).concat(parserFeedback);
		return response;
	}

	/**
	 * This operation executes the User's Search command
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */
	private static String executeSearch(String userCommand) {
		ArrayList<TaskObject> displayList = taskNote.getDisplayList();
		ArrayList<Integer> searchIds;
		boolean throwException = true;
		String parserFeedback = new String(Constants.STRING_CONSTANT_SPACE);
		try {
			searchIds = parser.parseSearch(displayList, throwException);
		} catch (Exception e) {
			throwException = false;
			parserFeedback = e.getMessage();
			searchIds = parser.parseSearch(displayList, throwException);
		}
		command = new SearchCommand(taskNote, searchIds);
		command.execute();
		command.refreshDisplay();
		String response = command.getFeedBack();
		response = response.concat(Constants.STRING_CONSTANT_NEWLINE).concat(parserFeedback);
		return response;
	}

	/**
	 * This operation executes the User's Update command
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */
	private static String executeUpdate(String userCommand) {
		int updateTaskId;
		TaskObject updatedTaskObject;
		boolean throwException = true;
		String parserUpdateIdFeedback = new String(Constants.STRING_CONSTANT_SPACE);
		String parserUpdateObjectFeedback = new String(Constants.STRING_CONSTANT_SPACE);

		try {
			updateTaskId = parser.getTaskId(throwException);
		} catch (Exception e) {
			throwException = false;
			parserUpdateIdFeedback = e.getMessage();
			updateTaskId = parser.getTaskId(throwException);
		}

		TaskObject oldTaskObject = null;
		throwException = true;
		if (taskNote.isValidTaskId(updateTaskId)) {
			ArrayList<TaskObject> displayList = taskNote.getDisplayList();
			oldTaskObject = displayList.get(updateTaskId);
			try {
				updatedTaskObject = parser.parseUpdate(oldTaskObject, throwException);
			} catch (Exception e) {
				throwException = false;
				parserUpdateObjectFeedback = e.getMessage();
				updatedTaskObject = parser.parseUpdate(oldTaskObject, throwException);
			}
		} else {
			updatedTaskObject = null;
		}
		ArrayList<TaskObject> taskList = taskNote.getTaskList();
		int originalUpdateTaskId = taskList.indexOf(oldTaskObject);
		command = new UpdateCommand(taskNote, originalUpdateTaskId, updatedTaskObject);
		command.execute();
		command.refreshDisplay();
		String response = command.getFeedBack();
		response = response.concat(Constants.STRING_CONSTANT_NEWLINE).concat(parserUpdateIdFeedback);
		response = response.concat(Constants.STRING_CONSTANT_NEWLINE).concat(parserUpdateObjectFeedback);
		return response;
	}

	/**
	 * This operation executes the User's Undo command
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */
	private static String executeUndo() {
		command = new UndoCommand(taskNote);
		command.execute();
		command.refreshDisplay();
		String response = command.getFeedBack();
		return response;
	}

	/**
	 * This operation executes the User's Redo command
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */
	private static String executeRedo(String userCommand) {
		command = new RedoCommand(taskNote);
		command.execute();
		command.refreshDisplay();
		String response = command.getFeedBack();
		return response;
	}

	/**
	 * This operation executes the User's Mark As Completed command
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */
	private static String executeMarkAsComplete(String userCommand) {
		int taskId;
		boolean throwException = true;
		String parserFeedback = new String(Constants.STRING_CONSTANT_SPACE);
		try {
			taskId = parser.getTaskId(throwException);
		} catch (Exception e) {
			throwException = false;
			parserFeedback = e.getMessage();
			taskId = parser.getTaskId(throwException);
		}
		command = new DoneCommand(taskNote, taskId);
		command.execute();
		command.refreshDisplay();
		String response = command.getFeedBack();
		response = response.concat(Constants.STRING_CONSTANT_NEWLINE).concat(parserFeedback);
		return response;
	}

	/**
	 * This operation executes the User's Mark As Incomplete command
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */
	private static String executeMarkAsIncomplete(String userCommand) {
		int taskId;
		boolean throwException = true;
		String parserFeedback = new String(Constants.STRING_CONSTANT_SPACE);
		try {
			taskId = parser.getTaskId(throwException);
		} catch (Exception e) {
			throwException = false;
			parserFeedback = e.getMessage();
			taskId = parser.getTaskId(throwException);
		}
		command = new UndoneCommand(taskNote, taskId);
		/*TaskObject taskObject;
		if (taskNote.isValidTaskId(taskId)) {
			ArrayList<TaskObject> displayList = taskNote.getDisplayList();
			taskObject = displayList.get(taskId);
		} else {
			taskObject = null;
		}
		command = new UndoneCommand(taskNote, taskObject);
		*/
		command.execute();
		command.refreshDisplay();
		String response = command.getFeedBack();
		response = response.concat(Constants.STRING_CONSTANT_NEWLINE).concat(parserFeedback);
		return response;
	}

	/**
	 * This operation executes the User's request to change the directory the
	 * task file exists in
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */
	private static String executeChangeFilePath(String userCommand) {
		String filePath;
		boolean throwException = true;
		String parserFeedback = new String(Constants.STRING_CONSTANT_SPACE);
		try {
			filePath = parser.parseFilePath(throwException);
		} catch (Exception e) {
			throwException = false;
			parserFeedback = e.getMessage();
			filePath = parser.parseFilePath(throwException);
		}
		command = new ChangeFilePathCommand(taskNote, filePath);
		command.execute();
		command.refreshDisplay();
		String response = command.getFeedBack();
		response = response.concat(Constants.STRING_CONSTANT_NEWLINE).concat(parserFeedback);
		return response;
	}

	/**
	 * This operation executes the User's request to show all tasks whose
	 * deadlines are within the specified time interval
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */

	private static String executeShow(String userCommand) {
		ShowInterval timeInterval;
		int countInterval;
		boolean throwException = true;
		String parserShowFeedback = new String(Constants.STRING_CONSTANT_SPACE);
		String parserIntervalFeedback = new String(Constants.STRING_CONSTANT_SPACE);

		try {
			timeInterval = parser.parseShow(throwException);
		} catch (Exception e) {
			throwException = false;
			parserShowFeedback = e.getMessage();
			timeInterval = parser.parseShow(throwException);
		}

		throwException = true;
		try {
			countInterval = parser.getInterval(throwException);
		} catch (Exception e) {
			throwException = false;
			parserIntervalFeedback = e.getMessage();
			countInterval = parser.getInterval(throwException);
		}
		command = new ShowCommand(taskNote, timeInterval, countInterval);
		command.execute();
		command.refreshDisplay();
		String response = command.getFeedBack();
		response = response.concat(Constants.STRING_CONSTANT_NEWLINE).concat(parserShowFeedback);
		response = response.concat(Constants.STRING_CONSTANT_NEWLINE).concat(parserIntervalFeedback);
		return response;
	}

	/**
	 * This operation executes the User's request to show all tasks whose
	 * deadlines are within the specified time interval
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */
	private static String executeChangeCategory(String userCommand) {
		// TODO: Parser
		ShowCategory category;
		boolean throwException = true;
		String parserFeedback = new String(Constants.STRING_CONSTANT_SPACE);
		try {
			category = parser.parseChangeCategory(throwException);
		} catch (Exception e) {
			throwException = false;
			parserFeedback = e.getMessage();
			// category = Parser.parseChangeCateogry(userCommand,
			// throwException);
		}
		category = parseChangeCategory(userCommand);
		command = new ChangeCategoryCommand(taskNote, category);
		command.execute();
		command.refreshDisplay();
		String response = command.getFeedBack();
		response = response.concat(Constants.STRING_CONSTANT_NEWLINE).concat(parserFeedback);
		return response;
	}
	
	private static ShowCategory parseChangeCategory(String userCommand) {
		String[] parts = userCommand.split("\\s+");
		String category = parts[1];
		if (category.equalsIgnoreCase("ALL")) {
			return ShowCategory.ALL;
		} else if (category.equalsIgnoreCase("OUTSTANDING")) {
			return ShowCategory.OUTSTANDING;
		} else if (category.equalsIgnoreCase("OVERDUE")) {
			return ShowCategory.OVERDUE;
		} else if (category.equalsIgnoreCase("COMPLETED")) {
			return ShowCategory.COMPLETED;
		} else {
			return ShowCategory.COMPLETED;
		}
	}

	/**
	 * This operation executes the User's request to show the General 
	 * Help message as well as the Help message for specific commands
	 *
	 * @param User
	 *            Command
	 * @return Status of Operation
	 */
	private static String executeHelp(String userCommand) {
		boolean throwException = true;
		String parserFeedback = new String(Constants.STRING_CONSTANT_SPACE);
		COMMAND_TYPE commandType;
		try {
			commandType = parser.parseHelp(throwException);
		} catch (Exception e) {
			throwException = false;
			parserFeedback = e.getMessage();
			commandType = parser.parseHelp(throwException);
		}
		command = new HelpCommand(taskNote, commandType);
		command.execute();
		command.refreshDisplay();
		String response = command.getFeedBack();
		response = response.concat(Constants.STRING_CONSTANT_NEWLINE).concat(parserFeedback);
		return response;
	}
}
```
###### \src\tasknote\shared\Constants.java
``` java
package tasknote.shared;

import javafx.beans.property.SimpleStringProperty;

public class Constants {

	/*
	 * These are the String Constants that will be displayed before or after
	 * each user operation
	 */
	public static final String MESSAGE_ADD_SUCCESSFUL = "Added Task Successfully\n";
	public static final String MESSAGE_ADD_UNSUCCESSFUL = "Add Failed";
	public static final String MESSAGE_DELETE_SUCCESSFUL = "Deleted %d task(s) Successfully";
	public static final String MESSAGE_DELETE_UNSUCCESSFUL = "Deletion Failed";
	public static final String MESSAGE_SEARCH_UNSUCCESSFUL = "No tasks contain the entered search string";
	public static final String MESSAGE_SEARCH_SUCCESSFUL = "Search Successful: %d Result(s) Retrieved";
	public static final String MESSAGE_UPDATE_SUCCESSFUL = "Task was Successfully Updated\n";
	public static final String MESSAGE_UPDATE_UNSUCCESSFUL = "Update Failed";
	public static final String MESSAGE_UNDO_SUCCESSFUL = "The Last %s Operation has been Undone Successfully\n\n";
	public static final String MESSAGE_UNDO_UNSUCCESSFUL = "Undo Command Failed to be executed";
	public static final String MESSAGE_REDO_SUCCESSFUL = "The Last %s Operation has been re-done Successfully\n\n";
	public static final String MESSAGE_REDO_UNSUCCESSFUL = "Redo Command Failed to be executed";
	public static final String MESSAGE_DONE_SUCCESSFUL = "Task \"%s\" has been marked as completed Successfully";
	public static final String MESSAGE_DONE_UNSUCCESSFUL = "Mark as complete failed\n";
	public static final String MESSAGE_UNDONE_SUCCESSFUL = "Task \"%s\" has been marked as Incomplete Successfully";
	public static final String MESSAGE_UNDONE_UNSUCCESSFUL = "Mark as Incomplete failed\n";
	public static final String MESSAGE_SHOW_SUCCESSFUL_DEADLINE_INTERVAL = "%d Deadline Task(s) due [ %d %s ]";
	public static final String MESSAGE_SHOW_SUCCESSFUL_DEADLINE = "%d Deadline Task(s) due [ %s ]";
	public static final String MESSAGE_SHOW_SUCCESSFUL_ALL = "All Tasks are displayed";
	public static final String MESSAGE_SHOW_NO_RESULTS = "No Deadline Tasks are due within this period";
	public static final String MESSAGE_SHOW_UNSUCCESSFUL = "Unable to show deadline tasks within this period";
	public static final String MESSAGE_CHANGE_PATH_SUCCESSFUL = "File path successfully changed to: %s";
	public static final String MESSAGE_CHANGE_PATH_UNSUCCESSFUL = "Unsuccessful operation. Unable to change file path to: %s";
	public static final String MESSAGE_CHANGE_CATEGORY_SUCCESSFUL = "%s tasks have been successfully displayed";
	public static final String MESSAGE_CHANGE_CATEGORY_UNSUCCESSFUL = "Unsuccessful operation. Unable to display %s tasks";
	
	
	/*
	 * These are strings that are used to display about tasks to users in notifications
	 */
	public static final String STRING_TASK_NAME_INDEX = "\nTask Index: \t%d"
			  										  + "\nTask Name: \t%s";
	public static final String STRING_TASK_LOCATION = "\nLocation: \t%s";
	public static final String STRING_TASK_DATE = "\nDate: \t\t%s";
	public static final String STRING_TASK_TIME = "\nTime: \t\t%s";
	
	/*
	 * These are the Messages to be displayed to inform user of valid 
	 * command entries
	 * 
	 * Format:
	 * 
	 * 	ADD
	 * 		Add deadline task: 
	 * 			add <TaskName> on <time> by <date>
	 * 		Add floating task:
	 * 			add <TaskName>
	 * 		Keywords: on, by, after ...
	 * 		Note: Place double quotes (E.g. Meet at "Gardens by the bay")
	 * 
	 */
	public static final String MESSAGE_HELP = "The Following are the List of Valid Commands: \n"
											+ "1. To add task: ADD\n"
											+ "2. To edit task: EDIT\n"
											+ "3. To do a sub string search for tasks: SEARCH\n"
											+ "4. To do exact search for tasks: SEARCH EXACT\n"
											+ "5. To delete task: DELETE\n"
											+ "6. To reverse previous action: UNDO\n"
											+ "7. To reverse previous Undo action: REDO\n"
											+ "8. To change file path: RELOCATE\n"
											+ "9. To display deadline tasks within specified time interval: SHOW\n"
											+ "10. To mark task as complete: DONE\n"
											+ "11. To mark task as incomplete: UNDONE\n\n"
											+ "For specific usage of a command, enter: HELP <Command>\n";
	public static final String MESSAGE_HELP_ADD = "ADD\n"
												+ "1. Add a Floating task (without deadline):\n"
												+ "		add <TaskName>\n\n"
												+ "2. Add a Deadline task:\n"
												+ "		add <TaskName> on <time> by <date> at <location>\n\n"
												+ "3. Add an Event task:\n"
												+ "		add <TaskName> from <start time> to <end time> by <date> at <location>";
	public static final String MESSAGE_HELP_DELETE = "DELETE\n"
													+ "1. Delete space separated IDs:\n"
													+ "		delete <TaskID> <more TaskIDs...>\n\n"
													+ "2. Delete range of IDs:\n"
													+ "		delete <start TaskID> to <end TaskID>";
	public static final String MESSAGE_HELP_SEARCH = "SEARCH\n"
												   + "1. Substring Search on single/multiple keywords:\n"
												   + "		search <keyword> <more keywords...>\n\n"
												   + "2. Exact search on single/multiple keywords:\n"
												   + "		search exact <keyword> <more keywords...>";
	public static final String MESSAGE_HELP_UPDATE = "EDIT\n"
												   + "Edit Task properties:\n"
												   + "		edit <TaskID> <new TaskName> on <time> by <date> at <location>";
	public static final String MESSAGE_HELP_UNDO = "UNDO\n"
												 + "Revert last operation:\n"
												 + "	undo";
	public static final String MESSAGE_HELP_REDO = "REDO\n"
												 + "Revert last undo operation:\n"
												 + "	redo";
	public static final String MESSAGE_HELP_DONE = "DONE\n"
												 + "Marked task with TaskID as Complete:\n"
												 + "	done <TaskID>";
	public static final String MESSAGE_HELP_UNDONE = "UNDONE\n"
			 									 + "Marked task with TaskID as Incomplete:\n"
			 									 + "	undone <TaskID>";
	public static final String MESSAGE_HELP_CHANGE_FILE_PATH = "RELOCATE\n"
															 + "Change file path:"
															 + "	relocate <new file path>";
	public static final String MESSAGE_HELP_SHOW = "SHOW\n"
												+ "1. Show All Tasks:"
												+ "		show all\n\n"
												+ "2. Show Tasks that are due today:\n"
												+ "		show today\n\n"
												+ "3. Show Tasks that are due tomorrow:\n"
												+ "		show tomorrow\n\n"
												+ "4. Show tasks that are due within next <d> days\n"
												+ "		show next <d> days\n"
												+ "		show next [next ... ] days\n\n"
												+ "3. Show tasks that are due within next <w> weeks\n"
												+ "		show next <w> weeks\n"
												+ "		show next [next ...] weeks";
	public static final String MESSAGE_HELP_CHANGE_CATEGORY = "";
	public static final String MESSAGE_HELP_EXIT = "EXIT\n"
												 + "Exit application:\n"
												 + "	exit";
	
	
	/*
	 * These are the warnings that will be displayed in the logs if the user
	 * does not enter valid commands
	 */
	public static final String WARNING_NULL_COMMAND = "Command type string cannot be null!";
	public static final String WARNING_INVALID_COMMAND = "Invalid Command. Please try again.";
	public static final String WARNING_INVALID_DELETE_INDEX = "Invalid Deletion Index found. Please enter valid task IDs to delete tasks.";
	public static final String WARNING_EMPTY_DELETEID_LIST = "• No Delete IDs specified to Delete Tasks.\n• Please specify Task ID(s) to delete corresponding Task(s).";
	public static final String WARNING_EXECUTE_ADD_FAILURE = "Error occured while ADDING task: %s";
	public static final String WARNING_EXECUTE_ADD_INVALID_OBJECT = "Invalid object (NULL) passed to be added. Add failure: %s";
	public static final String WARNING_EXECUTE_DELETE_FAILURE = "Error occured while DELETING task(s): %s";
	public static final String WARNING_EXECUTE_DELETE_INVALID_LIST = "Delete ID list is either EMPTY or contains INVALID IDs: %s";
	public static final String WARNING_EXECUTE_UPDATE_FAILURE = "Error occured while UPDATING task(s): %s";
	public static final String WARNING_EXECUTE_UPDATE_INVALID_OBJECTID = "Task object Update Error: Either Update ID is INVALID or updated object is NULL: %s";
	public static final String WARNING_EXECUTE_DONE_INVALID_ID = "Invalid task ID specified: %d.\nPlease Specify a valid TaskID to mark Task as Completed.";
	public static final String WARNING_EXECUTE_DONE_TASK_COMPLETED = "Task %d is already marked as completed.\nTo mark task as incomplete, use the UNDONE command.";
	public static final String WARNING_EXECUTE_DONE_TASK_INCOMPLETE = "Task %d is still outstanding.\nTo mark task as complete, use the DONE command.";
	public static final String WARNING_EXECUTE_SEARCH_FAILURE = "Error occured while SEARCHING and RETRIEVING results from task list: %s";
	public static final String WARNING_EXECUTE_SEARCH_NO_RESULT = "No valid search results due to empty Search ID list received: %s";
	public static final String WARNING_EXECUTE_COMPLETE_FAILURE = "Error occured while marking task as DONE: %s";
	public static final String WARNING_EXECUTE_COMPLETE_INVALID_OBJECT = "Invalid Task Object Error(not found in task list): %s";
	public static final String WARNING_EXECUTE_INCOMPLETE_FAILURE = "Error occured while marking task as UNDONE: %s";
	public static final String WARNING_EXECUTE_INCOMPLETE_INVALID_OBJECT = "Invalid Task Object Error(not found in task list): %s";
	public static final String WARNING_EXECUTE_UNDO = "Error occured while executing UNDO operation: %s";
	public static final String WARNING_EXECUTE_REDO = "Error occured while executing REDO operation: %s";
	public static final String WARNING_EXECUTE_SHOW_FAILURE = "Error while attempting to retrieve and SHOW taks for specifed time interval: %s";
	public static final String WARNING_EXECUTE_SHOW_INVALID_INTERVAL = "Invalid number of days/weeks entered: %s";
	public static final String WARNING_EXECUTE_CHANGE_PATH_FALSE = "Unable to execute change of file path. False returned by Storage";
	public static final String WARNING_EXECUTE_CHANGE_PATH_FAILURE = "Error: Change File Path to [ %s ] failed: %s";
	public static final String WARNING_EXECUTE_SHOW_INVALID_FILEPATH = "Error: Change File Path. Invalid file path [ %s ]";
	public static final String WARNING_EXECUTE_SHOW_CATEGORY_FAILURE = "Error: Unable to display tasks specified in category [ %s ] ;  Error: %s";
	public static final String WARNING_EXECUTE_SHOW_CATEGORY_INVALID = "Invalid Task Status Category specified. Valid Categories: [ALL, OUTSTANDING, OVERDUE, COMPLETED]; Error: %s";
	public static final String WARNING_EXECUTE_SORT_SAVE = "Error occured while SORTING tasks and SAVING to storage: %s";

	public static final String WARNING_INVALID_DELETE_ID = "Invalid DELETE ID: %d. Unable to execute DELETE operation.";

	/*
	 * These are the Info statements that will be displayed in the logs while
	 * executing each user operation
	 */
	public static final String INFO_DELETE_LIST = "No valid delete IDs have been specified. Size of Delete ID list = %d";
	public static final String INFO_ADD_SUCCESSFUL = "Task added to task list successfully";
	public static final String INFO_DONE_SUCCESSFUL = "Task marked as COMPLETE successfully";
	public static final String INFO_UNDONE_SUCCESSFUL = "Task marked as INCOMPLETE successfully";
	public static final String INFO_SEARCH_SUCCESSFUL = "Search result(s) retrieved successfully";
	public static final String INFO_UNDO_SUCCESSFUL = "Last operation is undone successfully";
	public static final String INFO_REDO_SUCCESSFUL = "Last operation is re-done successfully";
	public static final String INFO_EXECUTE_CHANGE_PATH_SUCCESSFUL = "File path has been successfully changed to: %s";
	
	public static final String FINE_DELETE_LIST_VALIDITY = "Checking validity of %d entries to be deleted from List";
	public static final String FINER_VALID_DELETE_ID = "Processed Valid ID [%d] : %s";

	/*
	 * These are the error messages that will be displayed if feedback is
	 * requested before and user requested action is performed
	 */
	public static final String ERROR_FEEDBACK = "Error: Feedback requested before action execution";
	
	/*
	 * These are strings that are used for taskType in TaskObject
	 */
	public static final String STRING_TASKTYPE_DEADLINE = "DEADLINE";
	public static final String STRING_TASKTYPE_FLOATING = "FLOATING";
	
```
###### \src\tasknote\shared\Constants.java
``` java
	/*
	 * These are the integer constants used in the program while executing
	 * specific user operations
	 */
	public static final int EMPTY_LIST_SIZE_CONSTANT = 0;
	public static final int ZERO_TIME_INTERVAL_CONSTANT = 0;
	public static final int PRECEDING_OBJECTS_CONSTANT = 2;
	public static final int DECREMENT_PRECEDING_OBJECTS_CONSTANT = 1;
	public static final int INCREMENT_DAY_TOMORROW_CONSTANT = 1;
	public static final int INCREMENT_COUNT_CONSTANT = 1;
	public static final int INVALID_VALUE_CONSTANT = -1;
	public static final int TIME_LATEST_HOUR_CONSTANT = 11;
	public static final int TIME_LATEST_MINUTE_CONSTANT = 59;
	
```
