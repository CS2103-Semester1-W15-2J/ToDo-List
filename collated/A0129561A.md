# A0129561A
###### \bin\tasknote\ui\resources\css\theme-monotone-dark.css
``` css

/**************************************************
 * Theme: Monotone-dark
 **************************************************/
* {
	-fx-commandline-container-background: #1e2123;
	-fx-commandline-node: #313437;
	-fx-task-container-background: #26292c;
	-fx-task-item-node: #313437;
	-fx-notification-exit-node: #888888;
	-fx-notification-background: #1e2123;
	-fx-sidebar-container-background: #26292c;
	-fx-sidebar-selected-node: #313437;
	-fx-default-text-color: #ffffff;
}

.root {
	-fx-font-size: 12pt;
}

/**************************************************
 * COMMAND LINE CONTAINER
 **************************************************/
.commandline-container {
	-fx-background-color: -fx-commandline-container-background;
	-fx-padding: 10 15 10 15;
}

.commandline {
	-fx-background-color: -fx-commandline-node;
	-fx-text-inner-color: -fx-default-text-color;
}

.commandline-enter-button {
	-fx-background-color: -fx-commandline-node;
	-fx-font-weight: bold;
	-fx-text-fill: -fx-default-text-color;
}

/**************************************************
 * TASKS CONTAINER
 **************************************************/
 .tasks-container {
 	-fx-background-color: -fx-task-container-background;
 	-fx-padding: 10 15 10 15;
 }
 
 .tasks-list {
 	-fx-background-color: -fx-task-item-node;
 	-fx-background-radius: 5;
 }
 
 .tasks-list-cell {
 	-fx-background-color: -fx-task-item-node;
 }
 
/**************************************************
 * SIDEBAR CONTAINER
 **************************************************/
 .sidebar-container {
 	-fx-padding: 10 15 10 15;
 	-fx-background-color: -fx-sidebar-container-background;
 }
 
 #sidebar-separator {
 	-fx-padding: 10 0 0 0;
 }
 
 #sidebar-navigation {
 	-fx-padding: 40 0 0 0;
 	-fx-background-color: -fx-sidebar-container-background;
 }
 
 #sidebar-navigation .list-cell:empty {
 	-fx-background-color: inherit;
 }
 
 #sidebar-navigation:focused .list-cell:filled:selected,
 #sidebar-navigation:focused .list-cell:filled:selected .label,
 #sidebar-navigation .list-cell:selected, 
 #sidebar-navigation .list-cell:selected .label {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-background-color: -fx-sidebar-selected-node;
 }
 
 .sidebar-navigation-cell {
 	-fx-font-weight: bold;
	-fx-font-size: 12pt;
 }
 
/**************************************************
 * CLOCK CONTAINER
 **************************************************/
 .clock-container {
 	
 }
 
 .clock-label-month-date {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-font-size: 16pt;
 }
 
 .clock-label-hour-minute-second {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-font-size: 16pt;
 }
 
 .clock-label-day-of-week {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-font-size: 25pt;
	-fx-font-weight: bold;
 }
 
/**************************************************
 * NOTIFICATION
 **************************************************/
 .notification-content {
	-fx-background-color: -fx-notification-background;
 	-fx-background-radius: 10;
 	-fx-padding: 20 20 20 20;
 }
 
 .notification-title {
 	-fx-fill: -fx-default-text-color;
 	-fx-font-weight: bold;
	-fx-font-size: 12pt;
 }
 
 .notification-exit-button {
 	-fx-fill: -fx-notification-exit-node;
 	-fx-font-size: 12pt;
 }
 
 .notification-exit-button:hover {
 	-fx-fill: -fx-default-text-color;
 	-fx-font-weight: bold;
 	-fx-font-size: 12pt;
 }
 
 .notification-alert-message {
 	-fx-fill: -fx-default-text-color;
 	-fx-font-size: 12pt;
 }
```
###### \bin\tasknote\ui\resources\css\theme-wunderlist.css
``` css

/**************************************************
 * Theme: Wunderlist
 **************************************************/
 * { 
	-fx-commandline-container-background: #1e2123;
	-fx-commandline-node: #313437;
	-fx-task-container-scrollbar: #fdfcee;
	-fx-sidebar-container-background: #26292c;
	-fx-sidebar-unselected-text-color: #9d9d9d;
	-fx-sidebar-selected-node: #313437;
	-fx-notification-background: #1e2123;
	-fx-notification-exit-node: #888888;
	-fx-default-text-color: #ffffff;
 }

 .root {
	-fx-font-size: 12pt; 
 }

/**************************************************
 * COMMAND LINE CONTAINER
 **************************************************/
 .commandline-container {
	-fx-background-color: -fx-commandline-container-background;
	-fx-padding: 10 15 10 15;
 }

 .commandline {
	-fx-background-color: -fx-commandline-node;
	-fx-text-inner-color: -fx-default-text-color;
 }

 .commandline-enter-button {
	-fx-background-color: -fx-commandline-node;
	-fx-font-weight: bold;
	-fx-text-fill: -fx-default-text-color;
 }

/**************************************************
 * TASKS CONTAINER
 **************************************************/
 .tasks-container {
 	-fx-padding: 10 15 10 15;
 }
 
 .tasks-container .scroll-bar:vertical,
 .tasks-container .scroll-bar:horizontal {
 	-fx-background-color: transparent;
 }
 
 .tasks-container .scroll-bar:horizontal .increment-button,
 .tasks-container .scroll-bar:horizontal .increment-button:hover,
 .tasks-container .scroll-bar:horizontal .decrement-button,
 .tasks-container .scroll-bar:horizontal .decrement-button:hover{
    -fx-background-color: transparent;
    -fx-background-radius: 0;
    -fx-background-insets: 0;
    -fx-padding: 0;
    -fx-shape: null;
 }
 
 .tasks-container .scroll-bar .increment-arrow,
 .tasks-container .scroll-bar .increment-arrow:hover,
 .tasks-container .scroll-bar .decrement-arrow,
 .tasks-container .scroll-bar .decrement-arrow:hover {
    -fx-background-color: transparent;
    -fx-background-radius: 0;
    -fx-background-insets: 0;
    -fx-padding: 0 8px;
    -fx-shape: null;
 }

 .tasks-container .scroll-bar:horizontal .thumb,
 .tasks-container .scroll-bar:vertical .thumb {
    -fx-background-color: -fx-task-container-scrollbar;
    -fx-background-insets: 0 5px;
    -fx-opacity: 0.2;
	-fx-background-radius: 20px;
 }
 
 .tasks-container .scroll-bar:horizontal .thumb:hover,
 .tasks-container .scroll-bar:vertical .thumb:hover {
    -fx-opacity: 0.3;
 }
 
 .tasks-list {
 	-fx-padding: 3px;
 	-fx-background-color: inherit;
 	-fx-background-radius: 5;
 }
 
 .tasks-list-cell {
 	-fx-padding: 5px 0 20px 15px;
    -fx-background-color: -fx-default-text-color;
    -fx-background-radius: 10;
    -fx-background-insets: 0 0 10px 0;
 }
 
 .tasks-list-cell:empty {
    -fx-padding: 0;
    -fx-background-color: transparent;
    -fx-background-insets: 0;
 }
 
/**************************************************
 * SIDEBAR CONTAINER
 **************************************************/
 .sidebar-container {
 	-fx-padding: 10 15 10 15;
 	-fx-background-color: -fx-sidebar-container-background;
 }
 
 #sidebar-separator {
 	-fx-padding: 10 0 0 0;
 }
 
 #sidebar-navigation {
 	-fx-padding: 40 0 0 0;
 	-fx-background-color: -fx-sidebar-container-background;
 }
 
 #sidebar-navigation .list-cell:empty {
 	-fx-background-color: inherit;
 }
 
 #sidebar-navigation .list-cell:filled,
 #sidebar-navigation .list-cell:filled .label {
 	-fx-text-fill: -fx-sidebar-unselected-text-color;
 }
 
 #sidebar-navigation:focused .list-cell:filled:selected,
 #sidebar-navigation:focused .list-cell:filled:selected .label,
 #sidebar-navigation .list-cell:selected, 
 #sidebar-navigation .list-cell:selected .label {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-background-color: -fx-sidebar-selected-node;
 }
 
 .sidebar-navigation-cell {
 	-fx-font-weight: bold;
	-fx-font-size: 12pt;
 }
 
/**************************************************
 * CLOCK CONTAINER
 **************************************************/
 .clock-container {
 	
 }
 
 .clock-label-month-date {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-font-size: 16pt;
 }
 
 .clock-label-hour-minute-second {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-font-size: 16pt;
 }
 
 .clock-label-day-of-week {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-font-size: 25pt;
	-fx-font-weight: bold;
 }
 
/**************************************************
 * NOTIFICATION
 **************************************************/
 .notification-content {
	-fx-background-color: -fx-notification-background;
 	-fx-background-radius: 10;
 	-fx-padding: 20 20 20 20;
 }
 
 .notification-title {
 	-fx-fill: -fx-default-text-color;
 	-fx-font-weight: bold;
	-fx-font-size: 12pt;
 }
 
 .notification-exit-button {
 	-fx-fill: -fx-notification-exit-node;
 	-fx-font-size: 12pt;
 }
 
 .notification-exit-button:hover {
 	-fx-fill: -fx-default-text-color;
 	-fx-font-weight: bold;
 	-fx-font-size: 12pt;
 }
 
 .notification-alert-message {
 	-fx-fill: -fx-default-text-color;
 	-fx-font-size: 12pt;
 }
```
###### \src\tasknote\shared\JunitTests\SystemIntegrationTest.java
``` java
package tasknote.shared.JunitTests;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import javafx.application.Application;
import javafx.collections.ObservableList;
import javafx.scene.control.TextField;
import tasknote.logic.TaskNoteControl;
import tasknote.parser.Parser;
import tasknote.shared.TaskListIOException;
import tasknote.shared.TaskObject;
import tasknote.storage.Storage;
import tasknote.ui.CommandLineContainer;
import tasknote.ui.FloatingTasksContainer;
import tasknote.ui.GuiController;
import tasknote.ui.TasksContainer;

public class SystemIntegrationTest {
    private static ArrayList<String> fileContent;
    
    private static String FILE_PATH_CONTENT = "pathContents.txt";
    
    private static String MESSAGE_INTEGRATION_TEST_BEGINS = "SystemIntegrationTest will thus commence...";
    private static String MESSAGE_INTEGRATION_TEST_RESTORE_ORIGINAL_STORAGE_CONTENT = "SystemIntegrationTest's restore is called...";
    private static String MESSAGE_INTEGRATION_TEST_ENDS = "End of SystemIntegrationTest's testing.";

    @BeforeClass
    public static void initialise() throws InterruptedException {
        System.out.println(MESSAGE_INTEGRATION_TEST_BEGINS);
        fileContent = new ArrayList<String>();
        taskContentsFileTransfer();
 
        Application.launch(GuiController.class, new String[0]);
    }

    /*
     * taskContentsFileTransfer() is called to transfer the contents of the file
     * used by storage to a temporary file, to prevent the actual content from
     * interfering with the testing. At the conclusion of the test, its
     * counterpart, taskContentsFileRestore() will be called to undo the
     * transfer made by taskContentsFileTransfer().
     */
    private static void taskContentsFileTransfer() {
        // Transfer text file to temporary file
        try {
            String taskContentsFilePath, taskContents;
            BufferedReader taskContentsLocation = new BufferedReader(new FileReader(FILE_PATH_CONTENT));
            taskContentsFilePath = taskContentsLocation.readLine();

            if (taskContentsFilePath != null) {
                BufferedReader taskContentsReader = new BufferedReader(new FileReader(taskContentsFilePath));

                taskContents = taskContentsReader.readLine();
                while (taskContents != null) {
                    fileContent.add(taskContents);
                    taskContents = taskContentsReader.readLine();
                }
                taskContentsReader.close();
                // Clear file
                PrintWriter pw = new PrintWriter(taskContentsFilePath);
                pw.close();
            }
            taskContentsLocation.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /*
     * taskContentsFileRestore() will restore contents stored in the temp file
     * to the current file that storage is using. This method should be called
     * at the conclusion of the testing.
     */
    private static void taskContentsFileRestore() {
        try {
            String taskContentsFilePath;
            BufferedReader taskContentsLocation = new BufferedReader(new FileReader(FILE_PATH_CONTENT));
            taskContentsFilePath = taskContentsLocation.readLine();

            if (taskContentsFilePath != null) {
                PrintWriter taskContentsWriter = new PrintWriter(taskContentsFilePath);
                for (String content : fileContent) {
                    taskContentsWriter.println(content);
                }
                taskContentsWriter.close();
            }
            taskContentsLocation.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    @Test
    public void testCommandLineBehaviour() {
        TasksContainer events = TasksContainer.getInstance();
        ObservableList<TaskObject> observableEventList = events.getTasksList();
        FloatingTasksContainer floating = FloatingTasksContainer.getInstance();
        ObservableList<TaskObject> observableFloatList = floating.getFloatingTasksList();
        CommandLineContainer commandLineContainer = CommandLineContainer.getInstance();
        TextField commandLine = commandLineContainer.getCommandLine();
        TaskNoteControl logic = new TaskNoteControl();
        Parser parser = new Parser();
        Storage storage = new Storage();
        
        String commandAddingFloatingTask = "add floating task 0";

        commandLine.setText(commandAddingFloatingTask);
        GuiController.retrieveCommand(commandLine);
        parser.setInputString(commandAddingFloatingTask);
        TaskObject floatingTask1 = parser.parseAdd(true);
        try {
            assertTrue(storage.loadTasks().contains(floatingTask1));
        } catch (IOException | TaskListIOException e) {
            e.printStackTrace();
        }
        assertTrue(logic.getDisplayList().contains(floatingTask1));
        assertTrue(observableFloatList.contains(floatingTask1));
        assertTrue(observableEventList.isEmpty());
    }

    @Test
    public void testAddingOfTask() {
        TasksContainer events = TasksContainer.getInstance();
        ObservableList<TaskObject> observableEventList = events.getTasksList();
        FloatingTasksContainer floating = FloatingTasksContainer.getInstance();
        ObservableList<TaskObject> observableFloatList = floating.getFloatingTasksList();
        TaskNoteControl logic = new TaskNoteControl();
        Parser parser = new Parser();
        Storage storage = new Storage();
        
        String commandAddingFloatingTask = "add floating task 0";
        String commandAddingDeadlineTask = "add deadline task 1 on 1/1/2050 by 12:34";

        // Testing Gui, Logic, Parser and Storage on adding a floating task.
        GuiController.executeCommand(commandAddingFloatingTask);
        parser.setInputString(commandAddingFloatingTask);
        TaskObject floatingTask1 = parser.parseAdd(true);
        assertTrue(floatingTask1.getTaskType().equals(TaskObject.TASK_TYPE_FLOATING));
        try {
            assertTrue(storage.loadTasks().contains(floatingTask1));
        } catch (IOException | TaskListIOException e) {
            e.printStackTrace();
        }
        assertTrue(logic.getDisplayList().contains(floatingTask1));
        assertTrue(observableFloatList.contains(floatingTask1));
        assertTrue(observableFloatList.size() == 1);
        assertTrue(observableEventList.isEmpty());

        // Testing Gui, Logic, Parser and Storage on adding a deadline task.
        GuiController.executeCommand(commandAddingDeadlineTask);
        parser.setInputString(commandAddingDeadlineTask);
        TaskObject deadlineTask1 = parser.parseAdd(true);
        try {
            assertTrue(storage.loadTasks().contains(deadlineTask1));
        } catch (IOException | TaskListIOException e) {
            e.printStackTrace();
        }
        assertTrue(logic.getDisplayList().contains(floatingTask1));
        assertTrue(logic.getDisplayList().size() == 2);
        assertTrue(observableFloatList.contains(floatingTask1));
        assertTrue(observableFloatList.size() == 1);
        assertTrue(observableEventList.contains(deadlineTask1));
        assertTrue(observableFloatList.size() == 1);
    }    

    @Test
    public void testDeletingOfTask() {
        TasksContainer events = TasksContainer.getInstance();
        ObservableList<TaskObject> observableEventList = events.getTasksList();
        FloatingTasksContainer floating = FloatingTasksContainer.getInstance();
        ObservableList<TaskObject> observableFloatList = floating.getFloatingTasksList();
        TaskNoteControl logic = new TaskNoteControl();
        Storage storage = new Storage();

        GuiController.executeCommand("add floating task 0");
        GuiController.executeCommand("add floating task 1");
        GuiController.executeCommand("add floating task 2");
        GuiController.executeCommand("add floating task 3");
        GuiController.executeCommand("add event task 4 at 1/1/2016 by 12:34");
        GuiController.executeCommand("add event task 5 at 1/1/2016 by 12:35");
        for (int count = 5; count >= 0; count--) {
            GuiController.executeCommand("delete 1");
            try {
                assertTrue(storage.loadTasks().size() == count);
            } catch (IOException | TaskListIOException e) {
                e.printStackTrace();
            }
            assertTrue(logic.getDisplayList().size() == count);
            assertTrue(observableFloatList.size() + observableEventList.size() == count);
        }
    }

    @Test
    public void testUndoAndRedoOfTask() {
        TasksContainer events = TasksContainer.getInstance();
        ObservableList<TaskObject> observableEventList = events.getTasksList();
        FloatingTasksContainer floating = FloatingTasksContainer.getInstance();
        ObservableList<TaskObject> observableFloatList = floating.getFloatingTasksList();
        TaskNoteControl logic = new TaskNoteControl();
        Storage storage = new Storage();

        GuiController.executeCommand("add floating task 0");
        GuiController.executeCommand("add event task 4 at 1/1/2016 by 12:34");
        try {
            assertTrue(storage.loadTasks().size() == 2);
        } catch (IOException | TaskListIOException e) {
            e.printStackTrace();
        }
        assertTrue(logic.getDisplayList().size() == 2);
        assertTrue(observableFloatList.size() + observableEventList.size() == 2);
        GuiController.executeCommand("delete 1");
        try {
            assertTrue(storage.loadTasks().size() == 1);
        } catch (IOException | TaskListIOException e) {
            e.printStackTrace();
        }
        assertTrue(logic.getDisplayList().size() == 1);
        assertTrue(observableFloatList.size() + observableEventList.size() == 1);

        GuiController.executeCommand("undo");
        try {
            assertTrue(storage.loadTasks().size() == 2);
        } catch (IOException | TaskListIOException e) {
            e.printStackTrace();
        }
        assertTrue(logic.getDisplayList().size() == 2);
        //assertTrue()
        assertTrue(observableFloatList.size() + observableEventList.size() == 2);

        GuiController.executeCommand("redo");
        try {
            assertTrue(storage.loadTasks().size() == 1);
        } catch (IOException | TaskListIOException e) {
            e.printStackTrace();
        }
        assertTrue(logic.getDisplayList().size() == 1);
        assertTrue(observableFloatList.size() + observableEventList.size() == 1);
    }

    @Test
    public void testSearchForTask() throws IOException, TaskListIOException {
        TasksContainer events = TasksContainer.getInstance();
        ObservableList<TaskObject> observableEventList = events.getTasksList();
        FloatingTasksContainer floating = FloatingTasksContainer.getInstance();
        ObservableList<TaskObject> observableFloatList = floating.getFloatingTasksList();
        Parser parser = new Parser();
        TaskNoteControl logic = new TaskNoteControl();
        
        String searchQuery = "search man";
        // Search should match exact strings, case insensitive strings, and substrings.
        String expectedQueryResultExactMatch = "add Watch man";
        String expectedQueryResultIgnoreCase = "add mAN";
        String expectedQuerySubstring = "add Watch Batman vs Superman: Dawn Of Justice on 1/1/2017 by 3pm at Cathay";
        parser.setInputString(expectedQueryResultExactMatch);
        TaskObject taskObjectExactMatch = parser.parseAdd(true);
        parser.setInputString(expectedQueryResultIgnoreCase);
        TaskObject taskObjectIgnoreCase = parser.parseAdd(true);
        parser.setInputString(expectedQuerySubstring);
        TaskObject taskObjectSubstring = parser.parseAdd(true);
        
        String taskNotContainingQuery = "add irrelevant task";
        String taskQuerySplitByPunctuation = "add M.anderson is coming to town";
        parser.setInputString(taskNotContainingQuery);
        TaskObject taskObjectNotContainingQuery = parser.parseAdd(true);
        parser.setInputString(taskQuerySplitByPunctuation);
        TaskObject taskObjectSplitByPunctuation = parser.parseAdd(true);
        
        ArrayList<TaskObject> searchQueryResult = null;

        GuiController.executeCommand(expectedQueryResultExactMatch);
        GuiController.executeCommand(expectedQueryResultIgnoreCase);
        GuiController.executeCommand(expectedQuerySubstring);
        GuiController.executeCommand(taskNotContainingQuery);
        GuiController.executeCommand(taskQuerySplitByPunctuation);
        
        GuiController.executeCommand(searchQuery);
        
        searchQueryResult = logic.getDisplayList();
        assertTrue(searchQueryResult.contains(taskObjectExactMatch));
        assertTrue(searchQueryResult.contains(taskObjectIgnoreCase));
        assertTrue(searchQueryResult.contains(taskObjectSubstring));
        assertFalse(searchQueryResult.contains(taskObjectNotContainingQuery));
        assertFalse(searchQueryResult.contains(taskObjectSplitByPunctuation));
        
        assertTrue(observableFloatList.size() == 2);
        assertTrue(observableEventList.size() == 1);
    }
    
    @After
    public void clearTaskContents() {
        try {
            BufferedReader taskContentsLocation = new BufferedReader(new FileReader(FILE_PATH_CONTENT));
            String taskContentsFilePath = taskContentsLocation.readLine();
            // Clear file
            PrintWriter pw = new PrintWriter(taskContentsFilePath);
            pw.close();
            taskContentsLocation.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @AfterClass
    public static void restore() {
        System.out.println(MESSAGE_INTEGRATION_TEST_RESTORE_ORIGINAL_STORAGE_CONTENT);
        taskContentsFileRestore();
        System.out.println(MESSAGE_INTEGRATION_TEST_ENDS);
    }
}
```
###### \src\tasknote\shared\JunitTests\TaskObjectTest.java
``` java
package tasknote.shared.JunitTests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import tasknote.shared.Constants;
import tasknote.shared.TaskObject;
import tasknote.shared.TaskObject.TaskStatus;

public class TaskObjectTest {

    @Rule
    public final ExpectedException exception = ExpectedException.none();

    @Test
    public void setAndGetTaskName() {
        TaskObject testTaskObjectOne = new TaskObject("Task 1");
        assertTrue(testTaskObjectOne.getTaskName().equals("Task 1"));
        testTaskObjectOne.setTaskName("Modified Task 1");
        assertEquals("Modified Task 1", testTaskObjectOne.getTaskName());

        TaskObject testTaskObjectTwo = new TaskObject();
        assertTrue(testTaskObjectTwo.getTaskName().isEmpty());
        testTaskObjectTwo.setTaskName("Modified Task 2");
        assertEquals("Modified Task 2", testTaskObjectTwo.getTaskName());
    }

    @Test
    public void setAndGetTaskDateYear() {
        TaskObject testTaskObject = new TaskObject("Task 1");
        assertEquals(testTaskObject.DEFAULT_DATETIME_VALUE, testTaskObject.getDateYear());

        testTaskObject.setDateYear(2000);
        assertEquals(2000, testTaskObject.getDateYear());
    }

    @Test
    public void setAndGetTaskDateMonth() {
        TaskObject testTaskObject = new TaskObject("Task 1");
        assertEquals(testTaskObject.DEFAULT_DATETIME_VALUE, testTaskObject.getDateYear());

        testTaskObject.setDateMonth(1);
        assertEquals(1, testTaskObject.getDateMonth());
    }

    @Test
    public void setAndGetTaskDateDay() {
        TaskObject testTaskObject = new TaskObject("Task 1");
        assertEquals(testTaskObject.DEFAULT_DATETIME_VALUE, testTaskObject.getDateYear());

        testTaskObject.setDateMonth(4);
        assertEquals(4, testTaskObject.getDateMonth());
    }

    @Test
    public void setAndGetTaskDateHour() {
        TaskObject testTaskObject = new TaskObject("Task 1");
        assertEquals(testTaskObject.DEFAULT_DATETIME_VALUE, testTaskObject.getDateYear());

        testTaskObject.setDateMonth(10);
        assertEquals(10, testTaskObject.getDateMonth());
    }

    @Test
    public void setAndGetTaskDateMinute() {
        TaskObject testTaskObject = new TaskObject("Task 1");
        assertEquals(testTaskObject.DEFAULT_DATETIME_VALUE, testTaskObject.getDateYear());

        testTaskObject.setDateMonth(30);
        assertEquals(30, testTaskObject.getDateMonth());
    }

    @Test
    public void getTaskFormattedDate() {
        TaskObject testTaskObject = new TaskObject("Task 1");
        assertEquals("", testTaskObject.getFormattedDate());

        testTaskObject.setDateYear(2000);
        testTaskObject.setDateMonth(1);
        testTaskObject.setDateDay(1);
        assertEquals("1 January 2000", testTaskObject.getFormattedDate());

        testTaskObject.setDateDay(2);
        assertEquals("2 January 2000", testTaskObject.getFormattedDate());

        testTaskObject.setDateMonth(2);
        assertEquals("2 February 2000", testTaskObject.getFormattedDate());

        testTaskObject.setDateYear(2010);
        assertEquals("2 February 2010", testTaskObject.getFormattedDate());

        exception.expect(IndexOutOfBoundsException.class);
        testTaskObject.setDateMonth(13);
        testTaskObject.getFormattedDate();
    }

    @Test
    public void getTaskFormattedEndDate() {
        TaskObject testTaskObject = new TaskObject("Task 1");
        assertEquals("", testTaskObject.getFormattedEndDate());

        testTaskObject.setEndDateYear(2000);
        testTaskObject.setEndDateMonth(1);
        testTaskObject.setEndDateDay(1);
        assertEquals("1 January 2000", testTaskObject.getFormattedEndDate());

        testTaskObject.setEndDateDay(2);
        assertEquals("2 January 2000", testTaskObject.getFormattedEndDate());

        testTaskObject.setEndDateMonth(2);
        assertEquals("2 February 2000", testTaskObject.getFormattedEndDate());

        testTaskObject.setEndDateYear(2010);
        assertEquals("2 February 2010", testTaskObject.getFormattedEndDate());

        exception.expect(IndexOutOfBoundsException.class);
        testTaskObject.setEndDateMonth(13);
        testTaskObject.getFormattedEndDate();
    }

    @Test
    public void getTaskFormattedTime() {
        TaskObject testTaskObject = new TaskObject("Task 1");
        assertEquals("", testTaskObject.getFormattedTime());

        testTaskObject.setDateYear(2000);
        testTaskObject.setDateMonth(1);
        testTaskObject.setDateDay(1);
        testTaskObject.setDateHour(10);
        testTaskObject.setDateMinute(10);
        assertEquals("10:10AM", testTaskObject.getFormattedTime());

        testTaskObject.setDateHour(12);
        assertEquals("12:10PM", testTaskObject.getFormattedTime());

        testTaskObject.setDateHour(20);
        testTaskObject.setDateMinute(30);
        assertEquals("08:30PM", testTaskObject.getFormattedTime());
    }

    @Test
    public void getTaskFormattedEndTime() {
        TaskObject testTaskObject = new TaskObject("Task 1");
        assertEquals("", testTaskObject.getFormattedEndTime());

        testTaskObject.setEndDateYear(2000);
        testTaskObject.setEndDateMonth(1);
        testTaskObject.setEndDateDay(1);
        testTaskObject.setEndDateHour(10);
        testTaskObject.setEndDateMinute(10);
        assertEquals("10:10AM", testTaskObject.getFormattedEndTime());

        testTaskObject.setEndDateHour(12);
        assertEquals("12:10PM", testTaskObject.getFormattedEndTime());

        testTaskObject.setEndDateHour(20);
        testTaskObject.setEndDateMinute(30);
        assertEquals("08:30PM", testTaskObject.getFormattedEndTime());
    }

    @Test
    public void testSetTaskStatus() {
        TaskObject testTaskObjectSetStatusWithEnum = new TaskObject("Task 1");
        TaskObject testTaskObjectSetStatusWithString = new TaskObject("Task 2");
        assertEquals(TaskStatus.TASK_OUTSTANDING, testTaskObjectSetStatusWithEnum.getTaskStatus());
        assertTrue(testTaskObjectSetStatusWithString.getTaskStatus() == testTaskObjectSetStatusWithEnum.getTaskStatus());
        
        testTaskObjectSetStatusWithEnum.setTaskStatus(TaskStatus.TASK_OVERDUE);
        testTaskObjectSetStatusWithString.setTaskStatus(Constants.STRING_TASKSTATUS_OVERDUE);
        assertTrue(testTaskObjectSetStatusWithString.getTaskStatus() == testTaskObjectSetStatusWithEnum.getTaskStatus());
        
        testTaskObjectSetStatusWithEnum.setTaskStatus(TaskStatus.TASK_COMPLETED);
        testTaskObjectSetStatusWithString.setTaskStatus(Constants.STRING_TASKSTATUS_COMPLETED);
        assertTrue(testTaskObjectSetStatusWithString.getTaskStatus() == testTaskObjectSetStatusWithEnum.getTaskStatus());
        
        testTaskObjectSetStatusWithEnum.setTaskStatus(TaskStatus.TASK_INVALID_STORAGE);
        testTaskObjectSetStatusWithString.setTaskStatus(Constants.STRING_TASKSTATUS_INVALID_STORAGE);
        assertTrue(testTaskObjectSetStatusWithString.getTaskStatus() == testTaskObjectSetStatusWithEnum.getTaskStatus());
        
        testTaskObjectSetStatusWithEnum.setTaskStatus(TaskStatus.TASK_OUTSTANDING);
        testTaskObjectSetStatusWithString.setTaskStatus(Constants.STRING_TASKSTATUS_OUTSTANDING);
        assertTrue(testTaskObjectSetStatusWithString.getTaskStatus() == testTaskObjectSetStatusWithEnum.getTaskStatus());
    }

    @Test
    public void testDeepClone() {
        TaskObject testTaskObject = new TaskObject("Task 1");
        testTaskObject.setDateYear(2000);
        testTaskObject.setDateMonth(1);
        testTaskObject.setDateDay(1);
        testTaskObject.setDateHour(10);
        testTaskObject.setDateMinute(10);

        TaskObject cloneOfTestTaskObject = new TaskObject("Task 2");
        cloneOfTestTaskObject.deepCopy(testTaskObject);

        assertEquals(testTaskObject, cloneOfTestTaskObject);
    }

    @Test
    public void testTaskTypeSet() {
        TaskObject testTaskObject = new TaskObject("Task 1");
        assertTrue(testTaskObject.isTaskTypeSet());
        assertEquals(testTaskObject.getTaskType(), TaskObject.TASK_TYPE_FLOATING);

        testTaskObject.setDateYear(2000);
        testTaskObject.setDateMonth(1);
        testTaskObject.setDateDay(1);
        testTaskObject.setDateHour(10);
        testTaskObject.setDateMinute(10);
        assertTrue(testTaskObject.isTaskTypeSet());
        assertEquals(testTaskObject.getTaskType(), TaskObject.TASK_TYPE_DEADLINE);

        testTaskObject.setEndDateYear(2000);
        testTaskObject.setEndDateMonth(1);
        testTaskObject.setEndDateDay(1);
        testTaskObject.setEndDateHour(10);
        testTaskObject.setEndDateMinute(11);
        testTaskObject.setDuration(1);
        assertTrue(testTaskObject.isTaskTypeSet());
        assertEquals(testTaskObject.getTaskType(), TaskObject.TASK_TYPE_EVENT);

        testTaskObject.setDuration(-1);
        assertFalse(testTaskObject.isTaskTypeSet());
    }
}
```
###### \src\tasknote\shared\TaskObject.java
``` java
     * @return Returns the TaskStatus, as represented by a class implementing
     *         the interface ObservableValue.
     */
    public SimpleStringProperty getObservableTaskStatus() {
        return this.taskStatus;
    }

    private boolean isYearMonthDayDefault() {
        return (getDateYear() == DEFAULT_DATETIME_VALUE && getDateMonth() == DEFAULT_DATETIME_VALUE
                && getDateDay() == DEFAULT_DATETIME_VALUE);
    }

    private boolean isYearMonthDayNonDefault() {
        return (getDateYear() != DEFAULT_DATETIME_VALUE && getDateMonth() != DEFAULT_DATETIME_VALUE
                && getDateDay() != DEFAULT_DATETIME_VALUE);
    }

    private boolean isEndYearMonthDayNonDefault() {
        return (getEndDateDay() != DEFAULT_DATETIME_VALUE && getEndDateMonth() != DEFAULT_DATETIME_VALUE
                && getEndDateYear() != DEFAULT_DATETIME_VALUE);
    }

    private boolean isHourMinuteDefault() {
        return (getDateHour() == DEFAULT_DATETIME_VALUE && getDateMinute() == DEFAULT_DATETIME_VALUE);
    }

    private boolean isHourMinuteNonDefault() {
        return (getDateHour() != DEFAULT_DATETIME_VALUE && getDateMinute() != DEFAULT_DATETIME_VALUE);
    }

    private boolean isEndHourMinuteNonDefault() {
        return (getEndDateMinute() != DEFAULT_DATETIME_VALUE && getEndDateHour() != DEFAULT_DATETIME_VALUE);
    }

    /**
     * Set the taskType based on its current properties.
     * 
     * @return If TaskObject is set to either floating, deadline, or event based
     *         on its current properties.
     */
    public boolean isTaskTypeSet() {
        if (isYearMonthDayDefault() && isHourMinuteDefault() && getDuration() == DEFAULT_DURATION_VALUE) {
            setTaskType(TASK_TYPE_FLOATING);
            return true;
        } else if (isYearMonthDayNonDefault() && getDuration() == DEFAULT_DURATION_VALUE) {
            setTaskType(TASK_TYPE_DEADLINE);
            return true;
        } else if (isYearMonthDayNonDefault() && isHourMinuteNonDefault() && getDuration() > DEFAULT_DURATION_VALUE) {
            setTaskType(TASK_TYPE_EVENT);
            return true;
        } else {
            return false;
        }
    }

    /**
     * @return Get formatted date. If date is not set, will return empty string.
     */
    public String getFormattedDate() {
        String taskDate = "";

        if (isYearMonthDayNonDefault()) {
            assert (0 <= dateDay && dateDay <= 31);
            assert (0 <= dateMonth && dateMonth <= 12);

            taskDate = String.format(FORMAT_DATE, dateDay, monthInString[dateMonth], dateYear);
        }

        return taskDate;
    }

    /**
     * @return Get formatted time. If time is not set, will return empty string.
     */
    public String getFormattedTime() {
        String taskTime = "";

        if (isHourMinuteNonDefault()) {
            assert (0 <= dateMinute && dateMinute <= 59);
            assert (0 <= dateHour && dateHour <= 23);

            if (dateHour < 12) {
                taskTime = String.format(FORMAT_TIME_MORNING, dateHour, dateMinute);
            } else if (dateHour == 12) {
                taskTime = String.format(FORMAT_TIME_EVENING, dateHour, dateMinute);
            } else if (dateHour > 12) {
                taskTime = String.format(FORMAT_TIME_EVENING, (dateHour - 12), dateMinute);
            }
        }

        return taskTime;
    }

    /**
     * @return Get formatted end date. If end date is not set, will return empty
     *         string.
     */
    public String getFormattedEndDate() {
        String taskDate = "";

        if (isEndYearMonthDayNonDefault()) {
            assert (0 <= endDateDay && endDateDay <= 31);
            assert (0 <= endDateMonth && endDateMonth <= 12);

            taskDate = String.format(FORMAT_DATE, endDateDay, monthInString[endDateMonth], endDateYear);
        }

        return taskDate;
    }

    /**
     * @return Get formatted end time. If end time is not set, will return empty
     *         string.
     */
    public String getFormattedEndTime() {
        String taskTime = "";

        if (isEndHourMinuteNonDefault()) {
            assert (0 <= endDateMinute && endDateMinute <= 59);
            assert (0 <= endDateHour && endDateHour <= 23);

            if (endDateHour < 12) {
                taskTime = String.format(FORMAT_TIME_MORNING, endDateHour, endDateMinute);
            } else if (endDateHour == 12) {
                taskTime = String.format(FORMAT_TIME_EVENING, endDateHour, endDateMinute);
            } else if (endDateHour > 12) {
                taskTime = String.format(FORMAT_TIME_EVENING, (endDateHour - 12), endDateMinute);
            }
        }

        return taskTime;
    }

    /**
     * isFloatingTask() checks if the taskStatus is floating.
```
###### \src\tasknote\ui\ClockContainer.java
``` java
package tasknote.ui;

import static tasknote.ui.GuiConstant.SPACING_BETWEEN_COMPONENTS;

import java.util.Calendar;
import java.util.Locale;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Label;
import javafx.scene.layout.GridPane;
import javafx.util.Duration;

public class ClockContainer extends GridPane {
    private static final Calendar _currentTime = Calendar.getInstance();
    private static ClockContainer _timerContainer = null;
    private static Label _monthAndDateLabel = new Label();
    private static Label _hourMinuteAndSecondLabel = new Label();
    private static Label _dayOfWeekLabel = new Label();

    private final int INTERVAL_SECOND_ANIMATION = 1;
    private final int MAXIMUM_WORD_LENGTH = 3;

    private final String FORMAT_TIME = "%1$02d:%2$02d:%3$02d %4$s";
    private final String FORMAT_DATE = "%1$3s %2$ 2d";
    private final String FORMAT_DAY = "%1$3s";

    private String CSS_CLASS_CLOCK_CONTAINER = "clock-container";
    private String CSS_CLASS_CLOCK_LABEL_HOUR_MINUTE_SECOND = "clock-label-hour-minute-second";
    private String CSS_CLASS_CLOCK_LABEL_MONTH_DATE = "clock-label-month-date";
    private String CSS_CLASS_CLOCK_LABEL_DAY_OF_WEEK = "clock-label-day-of-week";

    private ClockContainer() {
        // Only one instance of ClockContainer is permitted
    }

    /**
     * getInstance() allows user to get an instance of ClockContainer.
     * 
     * @return The one instance of ClockContainer.
     */
    public static ClockContainer getInstance() {
        if (_timerContainer == null) {
            _timerContainer = new ClockContainer();
            _timerContainer.setupClockContainer();
        }

        return _timerContainer;
    }

    private void setupClockContainer() {
        setClockContainerPresentation();
        setLabelsPresentation();

        _timerContainer.getChildren().addAll(_monthAndDateLabel, _hourMinuteAndSecondLabel, _dayOfWeekLabel);

        setLabelAnimation();
    }

    private void setClockContainerPresentation() {
        this.getStyleClass().add(CSS_CLASS_CLOCK_CONTAINER);
        this.setHgap(SPACING_BETWEEN_COMPONENTS);
    }

    private void setLabelsPresentation() {
        _monthAndDateLabel.getStyleClass().add(CSS_CLASS_CLOCK_LABEL_MONTH_DATE);
        _hourMinuteAndSecondLabel.getStyleClass().add(CSS_CLASS_CLOCK_LABEL_HOUR_MINUTE_SECOND);
        _dayOfWeekLabel.getStyleClass().add(CSS_CLASS_CLOCK_LABEL_DAY_OF_WEEK);

        GridPane.setConstraints(_dayOfWeekLabel, 0, 0);
        GridPane.setConstraints(_monthAndDateLabel, 1, 0);
        GridPane.setConstraints(_hourMinuteAndSecondLabel, 1, 1);

        setLabelsToCurrentTime();
    }

    private void setLabelAnimation() {
        Timeline timeline = new Timeline(
                new KeyFrame(Duration.seconds(INTERVAL_SECOND_ANIMATION), new EventHandler<ActionEvent>() {
                    @Override
                    public void handle(ActionEvent actionEvent) {
                        setLabelsToCurrentTime();
                    }
                }), new KeyFrame(Duration.seconds(INTERVAL_SECOND_ANIMATION)));
        timeline.setCycleCount(Animation.INDEFINITE);
        timeline.play();
    }
    
    private void setLabelsToCurrentTime() {
        _currentTime.setTimeInMillis(System.currentTimeMillis());
        
        int dayOfMonth = _currentTime.get(Calendar.DAY_OF_MONTH);
        int hours = _currentTime.get(Calendar.HOUR) == 0 ? 12 : _currentTime.get(Calendar.HOUR);
        int minutes = _currentTime.get(Calendar.MINUTE);
        int seconds = _currentTime.get(Calendar.SECOND);
        
        String monthString = _currentTime.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.ENGLISH)
                          .substring(0, MAXIMUM_WORD_LENGTH);
        String dayOfWeek = _currentTime.getDisplayName(Calendar.DAY_OF_WEEK, Calendar.LONG, Locale.ENGLISH)
                          .toUpperCase().substring(0, MAXIMUM_WORD_LENGTH);
        String ampmString = _currentTime.get(Calendar.AM_PM) == Calendar.AM ? "AM" : "PM";
        
        _dayOfWeekLabel.setText(String.format(FORMAT_DAY, dayOfWeek));
        _monthAndDateLabel.setText(String.format(FORMAT_DATE, monthString, dayOfMonth));
        _hourMinuteAndSecondLabel.setText(String.format(FORMAT_TIME, hours, minutes, seconds, ampmString));
    }
}
```
###### \src\tasknote\ui\CommandLineContainer.java
``` java
package tasknote.ui;

import static tasknote.ui.GuiConstant.COMMAND_ADD;
import static tasknote.ui.GuiConstant.COMMAND_DELETE;
import static tasknote.ui.GuiConstant.COMMAND_DONE;
import static tasknote.ui.GuiConstant.COMMAND_EDIT;
import static tasknote.ui.GuiConstant.COMMAND_EXIT;
import static tasknote.ui.GuiConstant.COMMAND_HELP;
import static tasknote.ui.GuiConstant.COMMAND_REDO;
import static tasknote.ui.GuiConstant.COMMAND_RELOCATE;
import static tasknote.ui.GuiConstant.COMMAND_SEARCH;
import static tasknote.ui.GuiConstant.COMMAND_CATEGORY;
import static tasknote.ui.GuiConstant.COMMAND_SHOW;
import static tasknote.ui.GuiConstant.COMMAND_UNDO;
import static tasknote.ui.GuiConstant.COMMAND_UNDONE;
import static tasknote.ui.GuiConstant.DEFAULT_COMMAND;
import static tasknote.ui.GuiConstant.SPACING_BETWEEN_COMPONENTS;
import static tasknote.ui.GuiConstant.UNINITIALIZED_STRING;
import static tasknote.ui.GuiConstant.commands;

import java.util.ArrayList;
import java.util.Arrays;

import javafx.event.EventHandler;
import javafx.scene.control.Button;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;

public class CommandLineContainer extends HBox {
    private static CommandLineContainer _commandLineContainer = null;
    private TextField _commandLine = new TextField();
    private Button _enterButton = new Button();

    private final String BUTTON_SUBMIT_COMMAND = "enter";

    /** For methods getPrevValidCommand() & getNextValidCommand(). */
    private final int INDEX_FIRST_COMMAND = 0;
    private final int INDEX_LAST_COMMAND = (commands.size() - 1);
    private final int INDEX_MODIFIED_COMMAND = -1;
    /** Saves last command input in command line upon cycling through various valid commands. */
    private String lastModifiedCommand = UNINITIALIZED_STRING;

    private String CSS_CLASS_COMMANDLINE_CONTAINER = "commandline-container";
    private String CSS_CLASS_COMMANDLINE_ENTER_BUTTON = "commandline-enter-button";
    private String CSS_CLASS_COMMANDLINE = "commandline";

    /** For command history. */
    private ArrayList<String> historyCommandEntered = new ArrayList<String>(Arrays.asList(UNINITIALIZED_STRING));
    private int historyCommandIndex = 0;

    private CommandLineContainer() {
        // Only one instance of CommandLineContainer is permitted
    }

    /**
     * getInstance() allows user to get an instance of CommandLineContainer.
     * 
     * @return The one instance of CommandLineContainer.
     */
    public static CommandLineContainer getInstance() {
        if (_commandLineContainer == null) {
            _commandLineContainer = new CommandLineContainer();
            _commandLineContainer.setupCommandLineContainer();
        }
        return _commandLineContainer;
    }

    /**
     * getCommandLine() allows user to get the command line contained within
     * CommandLineContainer.
     * 
     * @return The command line in CommandLineContainer.
     */
    public TextField getCommandLine() {
        return _commandLine;
    }

    /**
     * clearLastModifiedCommand() set the last modified command to be an empty
     * string, effectively clearing it.
     */
    public void clearLastModifiedCommand() {
        setLastModifiedCommand(UNINITIALIZED_STRING);
    }
    
    /**
     * resetCommandHistoryIndex() indicates that user is currently not trying to recover 
     * commands used.
     */
    public void resetCommandHistoryIndex() {
        historyCommandIndex = 0;
    }

    /**
     * Adds command executed in the command line. 
     * @param commandLine Command Line of the program.
     */
    public void addCommandHistory(TextField commandLine) {
        String command = commandLine.getText();
        historyCommandEntered.add(command);
    }

    private void setupCommandLineContainer() {
        setCommandLineContainerPresentation();
        setCommandLinePresentation();
        setEnterButtonPresentation();

        setCommandLineBehaviour();
        setEnterButtonBehaviour();

        this.getChildren().addAll(_commandLine, _enterButton);
    }

    private void setCommandLineContainerPresentation() {
        this.getStyleClass().add(CSS_CLASS_COMMANDLINE_CONTAINER);
        this.setSpacing(SPACING_BETWEEN_COMPONENTS);
    }

    private void setCommandLinePresentation() {
        _commandLine.getStyleClass().add(CSS_CLASS_COMMANDLINE);
        _commandLine.setText(DEFAULT_COMMAND);
        HBox.setHgrow(_commandLine, Priority.ALWAYS);
    }

    private void setEnterButtonPresentation() {
        _enterButton.getStyleClass().add(CSS_CLASS_COMMANDLINE_ENTER_BUTTON);
        _enterButton.setText(BUTTON_SUBMIT_COMMAND);
    }

    private void setCommandLineBehaviour() {
        _commandLine.setOnKeyPressed(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent key) {
                switch (key.getCode()) {
                    case ENTER:
                        resetCommandHistoryIndex();
                        GuiController.retrieveCommand(_commandLine);
                        break;
                    case UP:
                        if (key.isControlDown()) {
                            resetCommandHistoryIndex();
                            getPrevValidCommand(_commandLine);
                        } else {
                            getPrevEnteredCommand(historyCommandEntered, _commandLine);
                            key.consume();
                        }
                        break;
                    case DOWN:
                        if (key.isControlDown()) {
                            resetCommandHistoryIndex();
                            getNextValidCommand(_commandLine);
                        } else {
                            getNextEnteredCommand(historyCommandEntered, _commandLine);
                        }
                        break;
                    case SPACE:
                        resetCommandHistoryIndex();
                        isDefaultCommandTruncated(_commandLine);
                        break;
                    case Z:
                        if (key.isControlDown()) {
                            GuiController.executeCommand(COMMAND_UNDO);
                        } else {
                            resetCommandHistoryIndex();
                        }
                        break;
                    case Y:
                        if (key.isControlDown()) {
                            GuiController.executeCommand(COMMAND_REDO);
                        } else {
                            resetCommandHistoryIndex();
                        }
                        break;
                    default:
                        resetCommandHistoryIndex();
                        break;
                }
            }
        });
    }

    private void setEnterButtonBehaviour() {
        _enterButton.setOnAction(e -> GuiController.retrieveCommand(_commandLine));
    }

    private void getPrevEnteredCommand(ArrayList<String> history, TextField commandLine) {
        int numberOfCommandsEntered = history.size();
        // Permits cycling through command history by wrapping
        // historyCommandIndex around variable history's size.
        if (historyCommandIndex == 0) {
            historyCommandIndex = (numberOfCommandsEntered - 1);
        } else {
            historyCommandIndex--;
        }

        commandLine.setText(history.get(historyCommandIndex));
        commandLine.end();
    }

    private void getNextEnteredCommand(ArrayList<String> history, TextField commandLine) {
        int numberOfCommandsEntered = history.size();
        // Permits cycling through command history by wrapping
        // historyCommandIndex around variable history's size.
        if (historyCommandIndex == (numberOfCommandsEntered - 1)) {
            historyCommandIndex = 0;
        } else {
            historyCommandIndex++;
        }

        commandLine.setText(history.get(historyCommandIndex));
        commandLine.end();
    }

    /*
     * getNextCommand() permits user to cycle through a list of valid commands,
     * followed by the user's last edited command.
     */
    private void getNextValidCommand(TextField commandLine) {
        String originalCommand = commandLine.getText();
        String command = originalCommand.trim().toLowerCase();

        int position = commands.lastIndexOf(command);

        if (position == INDEX_MODIFIED_COMMAND) {
            String newCommand = commands.get(0);
            commandLine.setText(newCommand);
            setLastModifiedCommand(originalCommand);
        } else if (position == INDEX_LAST_COMMAND) {
            commandLine.setText(getLastModifiedCommand());
        } else {
            String newCommand = commands.get(position + 1);
            commandLine.setText(newCommand + " ");
        }
        commandLine.end();
    }

    /*
     * Similarly, getPrevCommand() permits user to cycle (in reverse) through
     * the user's last edited command, followed by a list of valid commands.
     */
    private void getPrevValidCommand(TextField commandLine) {
        String originalCommand = commandLine.getText();
        String command = originalCommand.trim().toLowerCase();

        int position = commands.lastIndexOf(command);

        if (position == INDEX_MODIFIED_COMMAND) {
            String newCommand = commands.get(INDEX_LAST_COMMAND);
            commandLine.setText(newCommand + " ");
            setLastModifiedCommand(originalCommand);
        } else if (position == INDEX_FIRST_COMMAND && !getLastModifiedCommand().isEmpty()) {
            commandLine.setText(getLastModifiedCommand());
        } else if (position == INDEX_FIRST_COMMAND && getLastModifiedCommand().isEmpty()) {
            String newCommand = commands.get(INDEX_LAST_COMMAND);
            commandLine.setText(newCommand + " ");
        } else {
            String newCommand = (position == 1) ? (commands.get(position - 1)) : (commands.get(position - 1) + " ");
            commandLine.setText(newCommand);
        }

        commandLine.end();
    }

    private void setLastModifiedCommand(String commandLine) {
        lastModifiedCommand = commandLine;
    }

    private String getLastModifiedCommand() {
        return lastModifiedCommand;
    }
    
    /*
     * Truncate text in command line if it fits the following format:
     * "add <command> " -> "<command> "
     */
    private boolean isDefaultCommandTruncated(TextField commandLine) {
        String command = commandLine.getText();

        switch (command) {
            case (DEFAULT_COMMAND + COMMAND_ADD):
                commandLine.setText(COMMAND_ADD);
                commandLine.end();
                return true;
            case (DEFAULT_COMMAND + COMMAND_EDIT):
                commandLine.setText(COMMAND_EDIT);
                commandLine.end();
                return true;
            case (DEFAULT_COMMAND + COMMAND_DONE):
                commandLine.setText(COMMAND_DONE);
                commandLine.end();
                return true;
            case (DEFAULT_COMMAND + COMMAND_DELETE):
                commandLine.setText(COMMAND_DELETE);
                commandLine.end();
                return true;
            case (DEFAULT_COMMAND + COMMAND_UNDO):
                commandLine.setText(COMMAND_UNDO);
                commandLine.end();
                return true;
            case (DEFAULT_COMMAND + COMMAND_REDO):
                commandLine.setText(COMMAND_REDO);
                commandLine.end();
                return true;
            case (DEFAULT_COMMAND + COMMAND_SEARCH):
                commandLine.setText(COMMAND_SEARCH);
                commandLine.end();
                return true;
            case (DEFAULT_COMMAND + COMMAND_EXIT):
                commandLine.setText(COMMAND_EXIT);
                commandLine.end();
                return true;
            case (DEFAULT_COMMAND + COMMAND_UNDONE):
                commandLine.setText(COMMAND_UNDONE);
                commandLine.end();
                return true;
            case (DEFAULT_COMMAND + COMMAND_HELP):
                commandLine.setText(COMMAND_HELP);
                commandLine.end();
                return true;
            case (DEFAULT_COMMAND + COMMAND_RELOCATE):
                commandLine.setText(COMMAND_RELOCATE);
                commandLine.end();
                return true;
            case (DEFAULT_COMMAND + COMMAND_CATEGORY):
            	commandLine.setText(COMMAND_CATEGORY);
	            commandLine.end();
	            return true;
            case (DEFAULT_COMMAND + COMMAND_SHOW):
                commandLine.setText(COMMAND_SHOW);
                commandLine.end();
                return true;
            default:
                break;
        }
        return false;
    }
}
```
###### \src\tasknote\ui\FloatingTasksContainer.java
``` java
package tasknote.ui;

import static tasknote.ui.GuiConstant.SPACING_BETWEEN_COMPONENTS;

import javafx.beans.Observable;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.util.Callback;
import tasknote.shared.TaskObject;

public class FloatingTasksContainer extends HBox {
    private static FloatingTasksContainer _floatingTasksContainer = null;
    private ListView<TaskObject> _observableListRepresentation = new ListView<TaskObject>();
    private ObservableList<TaskObject> _floatingTasksList = FXCollections
            .observableArrayList(taskobject -> new Observable[] { taskobject.getObservableTaskStatus() });

    private String CSS_CLASS_TASKS_CONTAINER = "tasks-container";
    private String CSS_CLASS_TASKS_LIST = "tasks-list";
    private String CSS_CLASS_TASKS_LIST_CELL = "tasks-list-cell";

    private FloatingTasksContainer() {
        // Only one instance of FloatingTasksContainer is permitted
    }

    /**
     * getInstance() allows user to get an instance of FloatingTasksContainer.
     * 
     * @return The one instance of FloatingTasksContainer.
     */
    public static FloatingTasksContainer getInstance() {
        if (_floatingTasksContainer == null) {
            _floatingTasksContainer = new FloatingTasksContainer();
            _floatingTasksContainer.setupFloatingTasksContainer();
        }
        return _floatingTasksContainer;
    }

    /**
     * getFloatingTasksList() allows user to get the observable list contained
     * within FloatingTasksContainer.
     * 
     * @return The ObservableList in FloatingTasksContainer.
     */
    public ObservableList<TaskObject> getFloatingTasksList() {
        return _floatingTasksList;
    }

    /*
     * As per name, set up floating tasks container.
     */
    private void setupFloatingTasksContainer() {
        setFloatingTasksContainerPresentation();
        setFloatingTasksListPresentation();

        setFloatListBehaviour();

        this.getChildren().addAll(_observableListRepresentation);
    }

    /*
     * Set up the presentation of the floating tasks container.
     */
    private void setFloatingTasksContainerPresentation() {
        this.getStyleClass().add(CSS_CLASS_TASKS_CONTAINER);
        this.setSpacing(SPACING_BETWEEN_COMPONENTS);
    }

    /*
     * Set up the presentation of the (observable) list containing all the
     * floating tasks.
     */
    private void setFloatingTasksListPresentation() {
        _observableListRepresentation.getStyleClass().add(CSS_CLASS_TASKS_LIST);
        _observableListRepresentation.setItems(_floatingTasksList);
        HBox.setHgrow(_observableListRepresentation, Priority.ALWAYS);
    }

    private void setFloatListBehaviour() {
        _observableListRepresentation.setCellFactory(new Callback<ListView<TaskObject>, ListCell<TaskObject>>() {
            @Override
            public ListCell<TaskObject> call(ListView<TaskObject> param) {
                return new ListCell<TaskObject>() {
                    @Override
                    public void updateItem(TaskObject task, boolean empty) {
                        super.updateItem(task, empty);
                        this.getStyleClass().add(CSS_CLASS_TASKS_LIST_CELL);
                        if (!isEmpty()) {
                            setGraphic(TasksContainer.getFormattedText(task));
                        } else {
                            setText(null);
                            setGraphic(null);
                        }
                    }
                };
            }
        });
    }
}
```
###### \src\tasknote\ui\GuiConstant.java
``` java
package tasknote.ui;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public abstract class GuiConstant {
    private GuiConstant() {
        // Prevent instantiation of GuiConstant.
    }

    public static final String COMMAND_ADD = "add";
    public static final String COMMAND_EDIT = "edit";
    public static final String COMMAND_DONE = "done";
    public static final String COMMAND_DELETE = "delete";
    public static final String COMMAND_UNDO = "undo";
    public static final String COMMAND_REDO = "redo";
    public static final String COMMAND_EXIT = "exit";
    public static final String COMMAND_SEARCH = "search";
    public static final String COMMAND_SHOW = "show";
    public static final String COMMAND_RELOCATE = "relocate";
    public static final String COMMAND_CATEGORY = "category";
    public static final String COMMAND_HELP = "help";
    public static final String COMMAND_UNDONE = "undone";

    public static final String DEFAULT_COMMAND = COMMAND_ADD + " ";

    public static final String UNINITIALIZED_STRING = "";

    public static final List<String> commands = Collections.unmodifiableList(Arrays.asList(
            UNINITIALIZED_STRING, COMMAND_ADD, COMMAND_EDIT, COMMAND_DONE, 
            COMMAND_DELETE, COMMAND_UNDO, COMMAND_HELP, COMMAND_EXIT));

    public static final String PROPERTY_BACKGROUND_COLOR = "-fx-background-color: %1$s;";
    public static final String PROPERTY_BACKGROUND_RADIUS = "-fx-background-radius: %1$d;";
    public static final String PROPERTY_FONT_WEIGHT = "-fx-font-weight: %1$s;";
    public static final String PROPERTY_FONT_SIZE = "-fx-font-size: %1$dpt;";
    public static final String PROPERTY_TEXT_INNER_COLOR = "-fx-text-inner-color: %1$s;";
    public static final String PROPERTY_TEXT_FILL = "-fx-text-fill: %1$s;";

    public static int SPACING_BETWEEN_COMPONENTS = 10;
}
```
###### \src\tasknote\ui\GuiController.java
``` java
package tasknote.ui;

import static tasknote.ui.GuiConstant.COMMAND_ADD;
import static tasknote.ui.GuiConstant.COMMAND_REDO;
import static tasknote.ui.GuiConstant.COMMAND_SEARCH;
import static tasknote.ui.GuiConstant.COMMAND_UNDO;
import static tasknote.ui.GuiConstant.DEFAULT_COMMAND;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import javafx.application.Application;
import javafx.collections.ObservableList;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.ListView;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundImage;
import javafx.scene.layout.BackgroundPosition;
import javafx.scene.layout.BackgroundRepeat;
import javafx.scene.layout.BackgroundSize;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;
import tasknote.logic.TaskNoteControl;
import tasknote.shared.TaskObject;
import tasknote.shared.TaskObject.TaskStatus;

public class GuiController extends Application {
    private static final Logger logger = Logger.getLogger(GuiController.class.getName());
    private static final String WARNING_ATTEMPT_TO_EXECUTE_INVALID_INPUT = "An invalid input (empty string, or simple \"add\") is passed for command execution.";
    private static TaskNoteControl _tasknoteControl = new TaskNoteControl();

    private final String APPLICATION_NAME = "TaskNote";
    private final String APPLICATION_ICON_PATH = "resources/image/tasknote-icon.png";
    private final String APPLICATION_BACKGROUND_IMAGE = "resources/image/wood-background.png";

    private final String CSS_GUICONTROLLER = "resources/css/theme-wunderlist.css";

    private final double WINDOW_MIN_WIDTH = 450.0;
    private final double WINDOW_MIN_HEIGHT = 450.0;

    private final String SHOW_ALL_COMMAND = "show all";

    @Override
    public void start(Stage stage) {
        BorderPane frame = new BorderPane();
        Scene scene = new Scene(frame);

        setFramePresentation(frame);
        setSceneBehaviour(scene);
        setSceneAndStagePresentation(stage, scene);

        setSidebarNavigationBehaviour();
        changeViewOfSidebarNavigation(SidebarContainer.NAVIGATION_TAG_OUTSTANDING);

        setSchedulerBehaviour();
        focusOnCommandLine();
    }

    private void setFramePresentation(BorderPane frame) {
        CommandLineContainer commandLineContainer = CommandLineContainer.getInstance();
        TasksContainer tasksContainer = TasksContainer.getInstance();
        FloatingTasksContainer floatingTasksContainer = FloatingTasksContainer.getInstance();
        SidebarContainer sidebarContainer = SidebarContainer.getInstance();

        Background background = setBackgroundPresentation();

        frame.setBackground(background);
        frame.setLeft(sidebarContainer);
        frame.setCenter(tasksContainer);
        frame.setRight(floatingTasksContainer);
        frame.setBottom(commandLineContainer);
    }

    private Background setBackgroundPresentation() {
        Image image = new Image(GuiController.class.getResourceAsStream(APPLICATION_BACKGROUND_IMAGE));
        BackgroundSize backgroundSize = new BackgroundSize(100, 100, true, true, true, true);
        BackgroundImage backgroundImage = new BackgroundImage(image, BackgroundRepeat.REPEAT,
                BackgroundRepeat.NO_REPEAT, BackgroundPosition.CENTER, backgroundSize);
        Background background = new Background(backgroundImage);

        return background;
    }

    private void setSceneBehaviour(Scene scene) {
        CommandLineContainer commandLineContainer = CommandLineContainer.getInstance();
        TextField commandLine = commandLineContainer.getCommandLine();
        scene.setOnKeyPressed(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent key) {
                switch (key.getCode()) {
                    case ESCAPE:
                        executeCommand(SHOW_ALL_COMMAND);
                        break;
                    case Z:
                        if (key.isControlDown()) {
                            executeCommand(COMMAND_UNDO);
                        }
                        break;
                    case Y:
                        if (key.isControlDown()) {
                            executeCommand(COMMAND_REDO);
                        }
                        break;
                    case F:
                        if (key.isControlDown()) {
                            commandLineContainer.resetCommandHistoryIndex();
                            commandLine.setText(COMMAND_SEARCH + " ");
                            commandLine.end();
                        }
                        break;
                    default:
                        break;
                }
            }
        });
    }

    private void setSceneAndStagePresentation(Stage stage, Scene scene) {
        scene.getStylesheets().add(getClass().getResource(CSS_GUICONTROLLER).toExternalForm());

        stage.setTitle(APPLICATION_NAME);
        stage.setScene(scene);
        stage.getIcons().add(new Image(GuiController.class.getResourceAsStream(APPLICATION_ICON_PATH)));
        stage.show();
        stage.setMaximized(true);
        stage.setMinWidth(WINDOW_MIN_WIDTH);
        stage.setMinHeight(WINDOW_MIN_HEIGHT);
    }

    private void setSchedulerBehaviour() {
        Scheduler schedulerManager = new Scheduler(_tasknoteControl);
        schedulerManager.runOutstandingTaskCheck();
    }

    /**
     * Pass commands to TaskNoteController for command execution based on text input.
     * 
     * @param commandLine Pass the command line which will extract the text for command execution.
     */
    public static void retrieveCommand(TextField commandLine) {
        String command = commandLine.getText();
        CommandLineContainer commandLineContainer = CommandLineContainer.getInstance();

        executeCommand(command);

        commandLineContainer.addCommandHistory(commandLine);
        commandLine.setText(DEFAULT_COMMAND);
        commandLine.end();
        commandLineContainer.clearLastModifiedCommand();
    }

    /**
     * Pass string to TaskNOteController for command execution.
     * 
     * @param command String meant for execution.
     */
    public static void executeCommand(String command) {
        if (command == null || command.trim().equals(COMMAND_ADD) || command.isEmpty()) {
            logger.log(Level.WARNING, WARNING_ATTEMPT_TO_EXECUTE_INVALID_INPUT);
            return;
        }

        Stage primaryWindow = (Stage) CommandLineContainer.getInstance().getScene().getWindow();

        String feedback = _tasknoteControl.executeCommand(command);
        Notification.setupNotification(primaryWindow, feedback);

        changeViewOfSidebarNavigation(SidebarContainer.NAVIGATION_TAG_VIEW_ALL);
    }

    private void focusOnCommandLine() {
        CommandLineContainer commandLineContainer = CommandLineContainer.getInstance();
        TextField commandLine = commandLineContainer.getCommandLine();

        if (commandLine != null) {
            commandLine.requestFocus();
            commandLine.end();
        }
    }

    /*
     * Segregate them based on floating, or non-floating tasks.
     * This method will not filter task(s) based on task status.
     */
    private static void displayUpdatedTaskList() {
        TasksContainer tasksContainer = TasksContainer.getInstance();
        ObservableList<TaskObject> tasksListToBeDisplayed = tasksContainer.getTasksList();
        FloatingTasksContainer floatingTasksContainer = FloatingTasksContainer.getInstance();
        ObservableList<TaskObject> floatingTasksListToBeDisplayed = floatingTasksContainer.getFloatingTasksList();

        ArrayList<TaskObject> displayList = _tasknoteControl.getDisplayList();

        for (int index = 0; index < displayList.size(); index++) {
            displayList.get(index).setTaskID(index + 1);
        }

        ArrayList<TaskObject> tasksList = new ArrayList<TaskObject>();
        ArrayList<TaskObject> floatsList = new ArrayList<TaskObject>();

        for (TaskObject task : displayList) {
            switch (task.getTaskType()) {
                case TaskObject.TASK_TYPE_FLOATING:
                    floatsList.add(task);
                    break;
                case TaskObject.TASK_TYPE_DEADLINE:
                case TaskObject.TASK_TYPE_EVENT:
                    tasksList.add(task);
                    break;
                default:
                    break;
            }
        }

        tasksListToBeDisplayed.setAll(tasksList);
        floatingTasksListToBeDisplayed.setAll(floatsList);
    }

    /*
     * Filter tasks based on TaskStatus, then segregate them based on floating,
     * or non-floating tasks.
     */
    private static void displayTaskList(String navigationTag) {
        ArrayList<TaskObject> displayList = _tasknoteControl.getDisplayList();
        TasksContainer tasksContainer = TasksContainer.getInstance();
        ObservableList<TaskObject> tasksListToBeDisplayed = tasksContainer.getTasksList();
        FloatingTasksContainer floatingTasksContainer = FloatingTasksContainer.getInstance();
        ObservableList<TaskObject> floatingTasksListToBeDisplayed = floatingTasksContainer.getFloatingTasksList();

        for (int index = 0; index < displayList.size(); index++) {
            displayList.get(index).setTaskID(index + 1);
        }

        ArrayList<TaskObject> tasksList = new ArrayList<TaskObject>();
        ArrayList<TaskObject> floatsList = new ArrayList<TaskObject>();

        TaskStatus taskTypeRequired = null;

        switch (navigationTag) {
            case SidebarContainer.NAVIGATION_TAG_OUTSTANDING:
                taskTypeRequired = TaskStatus.TASK_OUTSTANDING;
                break;
            case SidebarContainer.NAVIGATION_TAG_OVERDUE:
                taskTypeRequired = TaskStatus.TASK_OVERDUE;
                break;
            case SidebarContainer.NAVIGATION_TAG_COMPLETED:
                taskTypeRequired = TaskStatus.TASK_COMPLETED;
        }

        for (TaskObject task : displayList) {
            if (task.getTaskStatus() != taskTypeRequired) {
                continue;
            }

            switch (task.getTaskType()) {
                case TaskObject.TASK_TYPE_FLOATING:
                    floatsList.add(task);
                    break;
                case TaskObject.TASK_TYPE_DEADLINE:
                case TaskObject.TASK_TYPE_EVENT:
                    tasksList.add(task);
                    break;
                default:
                    break;
            }
        }

        tasksListToBeDisplayed.setAll(tasksList);
        floatingTasksListToBeDisplayed.setAll(floatsList);
    }

    private void setSidebarNavigationBehaviour() {
        SidebarContainer sidebarContainer = SidebarContainer.getInstance();
        ListView<String> sidebarNavigation = sidebarContainer.getNavigationList();

        sidebarNavigation.getSelectionModel().selectedItemProperty().addListener((obs, oldSelection, newSelection) -> {
            if (newSelection != null) {
                changeViewOfSidebarNavigation(newSelection);
            }
        });
    }

    /*
     * Set the selection of the sidebar container, and the corresponding task
     * container (i.e. the appropriate tasks based on task status will be
     * displayed).
     */
    private static void changeViewOfSidebarNavigation(String selected) {
        SidebarContainer sidebarContainer = SidebarContainer.getInstance();

        setVisibilityOfFloatingTaskContainer(selected);

        switch (selected) {
            case SidebarContainer.NAVIGATION_TAG_VIEW_ALL:
                sidebarContainer.selectNavigationCell(SidebarContainer.NAVIGATION_TAG_VIEW_ALL_INDEX);
                displayUpdatedTaskList();
                break;
            case SidebarContainer.NAVIGATION_TAG_OUTSTANDING:
                sidebarContainer.selectNavigationCell(SidebarContainer.NAVIGATION_TAG_OUTSTANDING_INDEX);
                displayTaskList(selected);
                break;
            case SidebarContainer.NAVIGATION_TAG_OVERDUE:
                sidebarContainer.selectNavigationCell(SidebarContainer.NAVIGATION_TAG_OVERDUE_INDEX);
                displayTaskList(selected);
                break;
            case SidebarContainer.NAVIGATION_TAG_COMPLETED:
                sidebarContainer.selectNavigationCell(SidebarContainer.NAVIGATION_TAG_COMPLETED_INDEX);
                displayTaskList(selected);
                break;
        }
    }

    private static void setVisibilityOfFloatingTaskContainer(String selectedTab) {
        FloatingTasksContainer floatingTasksContainer = FloatingTasksContainer.getInstance();

        if (selectedTab.equals(SidebarContainer.NAVIGATION_TAG_OVERDUE)) {
            floatingTasksContainer.setVisible(false);
            floatingTasksContainer.setManaged(false);
        } else {
            floatingTasksContainer.setVisible(true);
            floatingTasksContainer.setManaged(true);
        }
    }

    public static void main(String[] argv) {
        launch(argv);
    }
}
```
###### \src\tasknote\ui\Notification.java
``` java
package tasknote.ui;

import static tasknote.ui.GuiConstant.SPACING_BETWEEN_COMPONENTS;

import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.event.EventHandler;
import javafx.geometry.Pos;
import javafx.scene.control.Separator;
import javafx.scene.effect.DropShadow;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Text;
import javafx.stage.Popup;
import javafx.stage.Stage;
import javafx.util.Duration;

public class Notification {
    private static final int DURATION_IN_SECOND_NOTIFICATION = 5;
    private static final int MINIMUM_NOTIFICATION_WIDTH = 400;
    private static final String DEFAULT_NOTIFICATION_TITLE = "Notification";
  
    private static final double DROPDOWN_RADIUS = 5.0;
    private static final double DROPDOWN_X_OFFSET = 3.0;
    private static final double DROPDOWN_Y_OFFSET = 3.0;
    private static final Color Black = Color.rgb(19, 18, 20);
    
    private static final String NOTIFICATION_CLOSE_BUTTON = "x";
    
    private static final String CSS_CLASS_NOTIFICATION_CONTENT = "notification-content";
    private static final String CSS_CLASS_NOTIFICATION_TITLE = "notification-title";
    private static final String CSS_CLASS_NOTIFICATION_EXIT_BUTTON = "notification-exit-button";
    private static final String CSS_CLASS_NOTIFICATION_ALERT_MESSAGE = "notification-alert-message";

    private Notification() {
        // Prevent instantiation of Notification
    }

    /**
     * Create a notification.
     * 
     * @param primaryStage
     *            Enter the primary state used - that is, the "owner" of the
     *            notification.
     * @param title
     *            Set the title of the notification.
     * @param message
     *            Set the content of the notification.
     */
    public static void setupNotification(Stage primaryStage, String title, String message) {
        Popup notificationContainer = new Popup();
        VBox notificationContent = setupNotificationContent(notificationContainer, title, message);
        setNotificationContainerBehaviour(notificationContainer, notificationContent, primaryStage);
        runFadeAnimation(notificationContainer, notificationContent);
    }

    /**
     * Create a notification. However, in this case, the title is omitted, which
     * will result in "Notification" being used as title.
     * 
     * @param primaryStage
     *            Enter the primary state used - that is, the "owner" of the
     *            notification.
     * @param message
     *            Set the content of the notification.
     */
    public static void setupNotification(Stage primaryStage, String message) {
        setupNotification(primaryStage, null, message);
    }

    private static void setNotificationContainerBehaviour(Popup notificationContainer, VBox notificationContent,
            Stage primaryStage) {
        notificationContainer.setHideOnEscape(false);
        notificationContainer.getContent().add(notificationContent);
        notificationContainer.setAutoFix(true);
        notificationContainer.centerOnScreen();
        notificationContainer.show(primaryStage);
    }

    private static VBox setupNotificationContent(Popup notificationContainer, String title, String message) {
        VBox notificationContent = new VBox();
        Text titleMessage = (title == null || title.isEmpty()) ? new Text(DEFAULT_NOTIFICATION_TITLE) : new Text(title);
        Text exitButton = new Text(NOTIFICATION_CLOSE_BUTTON);
        Text alertMessage = new Text(message);
        Separator separator = new Separator();

        HBox titleContent = getNotificationTitle(titleMessage, exitButton);

        setNotificationContentPresentation(notificationContent);
        setTitleMessagePresentation(titleMessage);
        setExitButtonPresentation(exitButton);
        setAlertMessagePresentation(alertMessage);

        setExitButtonBehaviour(exitButton, notificationContainer);

        notificationContent.getChildren().addAll(titleContent, separator, alertMessage);

        return notificationContent;
    }

    private static HBox getNotificationTitle(Text titleMessage, Text exitButton) {
        HBox titleContent = new HBox();

        HBox leftCell = new HBox();
        leftCell.setAlignment(Pos.CENTER_LEFT);
        HBox.setHgrow(leftCell, Priority.ALWAYS);

        HBox rightCell = new HBox();
        rightCell.setAlignment(Pos.CENTER_RIGHT);
        HBox.setHgrow(rightCell, Priority.ALWAYS);

        leftCell.getChildren().add(titleMessage);
        rightCell.getChildren().add(exitButton);

        titleContent.getChildren().addAll(leftCell, rightCell);

        return titleContent;
    }

    private static void setNotificationContentPresentation(VBox notificationContent) {
        DropShadow dropShadow = new DropShadow();
        dropShadow.setRadius(DROPDOWN_RADIUS);
        dropShadow.setOffsetX(DROPDOWN_X_OFFSET);
        dropShadow.setOffsetY(DROPDOWN_Y_OFFSET);
        dropShadow.setColor(Black);

        notificationContent.setEffect(dropShadow);

        notificationContent.getStyleClass().add(CSS_CLASS_NOTIFICATION_CONTENT);
        notificationContent.setMinWidth(MINIMUM_NOTIFICATION_WIDTH);
        notificationContent.setSpacing(SPACING_BETWEEN_COMPONENTS);
    }

    private static void setTitleMessagePresentation(Text titleMessage) {
        titleMessage.getStyleClass().add(CSS_CLASS_NOTIFICATION_TITLE);
    }

    private static void setExitButtonPresentation(Text exitButton) {
        exitButton.getStyleClass().add(CSS_CLASS_NOTIFICATION_EXIT_BUTTON);
    }

    private static void setExitButtonBehaviour(Text exitButton, Popup notificationContainer) {
        exitButton.setOnMouseClicked((new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                notificationContainer.hide();
            }
        }));
    }

    private static void setAlertMessagePresentation(Text alertMessage) {
        alertMessage.getStyleClass().add(CSS_CLASS_NOTIFICATION_ALERT_MESSAGE);
    }

    private static void runFadeAnimation(Popup popupNotification, Pane pane) {
        Timeline timeline = new Timeline();
        KeyFrame key = new KeyFrame(Duration.seconds(DURATION_IN_SECOND_NOTIFICATION),
                new KeyValue(popupNotification.opacityProperty(), 0));
        timeline.getKeyFrames().add(key);
        timeline.setOnFinished((event) -> popupNotification.hide());
        timeline.play();

        pane.setOnMouseEntered((new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                timeline.stop();
            }
        }));

        pane.setOnMouseExited((new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                timeline.play();
            }
        }));
    }
}
```
###### \src\tasknote\ui\resources\css\theme-monotone-dark.css
``` css

/**************************************************
 * Theme: Monotone-dark
 **************************************************/
* {
	-fx-commandline-container-background: #1e2123;
	-fx-commandline-node: #313437;
	-fx-task-container-background: #26292c;
	-fx-task-item-node: #313437;
	-fx-notification-exit-node: #888888;
	-fx-notification-background: #1e2123;
	-fx-sidebar-container-background: #26292c;
	-fx-sidebar-selected-node: #313437;
	-fx-default-text-color: #ffffff;
}

.root {
	-fx-font-size: 12pt;
}

/**************************************************
 * COMMAND LINE CONTAINER
 **************************************************/
.commandline-container {
	-fx-background-color: -fx-commandline-container-background;
	-fx-padding: 10 15 10 15;
}

.commandline {
	-fx-background-color: -fx-commandline-node;
	-fx-text-inner-color: -fx-default-text-color;
}

.commandline-enter-button {
	-fx-background-color: -fx-commandline-node;
	-fx-font-weight: bold;
	-fx-text-fill: -fx-default-text-color;
}

/**************************************************
 * TASKS CONTAINER
 **************************************************/
 .tasks-container {
 	-fx-background-color: -fx-task-container-background;
 	-fx-padding: 10 15 10 15;
 }
 
 .tasks-list {
 	-fx-background-color: -fx-task-item-node;
 	-fx-background-radius: 5;
 }
 
 .tasks-list-cell {
 	-fx-background-color: -fx-task-item-node;
 }
 
/**************************************************
 * SIDEBAR CONTAINER
 **************************************************/
 .sidebar-container {
 	-fx-padding: 10 15 10 15;
 	-fx-background-color: -fx-sidebar-container-background;
 }
 
 #sidebar-separator {
 	-fx-padding: 10 0 0 0;
 }
 
 #sidebar-navigation {
 	-fx-padding: 40 0 0 0;
 	-fx-background-color: -fx-sidebar-container-background;
 }
 
 #sidebar-navigation .list-cell:empty {
 	-fx-background-color: inherit;
 }
 
 #sidebar-navigation:focused .list-cell:filled:selected,
 #sidebar-navigation:focused .list-cell:filled:selected .label,
 #sidebar-navigation .list-cell:selected, 
 #sidebar-navigation .list-cell:selected .label {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-background-color: -fx-sidebar-selected-node;
 }
 
 .sidebar-navigation-cell {
 	-fx-font-weight: bold;
	-fx-font-size: 12pt;
 }
 
/**************************************************
 * CLOCK CONTAINER
 **************************************************/
 .clock-container {
 	
 }
 
 .clock-label-month-date {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-font-size: 16pt;
 }
 
 .clock-label-hour-minute-second {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-font-size: 16pt;
 }
 
 .clock-label-day-of-week {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-font-size: 25pt;
	-fx-font-weight: bold;
 }
 
/**************************************************
 * NOTIFICATION
 **************************************************/
 .notification-content {
	-fx-background-color: -fx-notification-background;
 	-fx-background-radius: 10;
 	-fx-padding: 20 20 20 20;
 }
 
 .notification-title {
 	-fx-fill: -fx-default-text-color;
 	-fx-font-weight: bold;
	-fx-font-size: 12pt;
 }
 
 .notification-exit-button {
 	-fx-fill: -fx-notification-exit-node;
 	-fx-font-size: 12pt;
 }
 
 .notification-exit-button:hover {
 	-fx-fill: -fx-default-text-color;
 	-fx-font-weight: bold;
 	-fx-font-size: 12pt;
 }
 
 .notification-alert-message {
 	-fx-fill: -fx-default-text-color;
 	-fx-font-size: 12pt;
 }
```
###### \src\tasknote\ui\resources\css\theme-wunderlist.css
``` css

/**************************************************
 * Theme: Wunderlist
 **************************************************/
 * { 
	-fx-commandline-container-background: #1e2123;
	-fx-commandline-node: #313437;
	-fx-task-container-scrollbar: #fdfcee;
	-fx-sidebar-container-background: #26292c;
	-fx-sidebar-unselected-text-color: #9d9d9d;
	-fx-sidebar-selected-node: #313437;
	-fx-notification-background: #1e2123;
	-fx-notification-exit-node: #888888;
	-fx-default-text-color: #ffffff;
 }

 .root {
	-fx-font-size: 12pt; 
 }

/**************************************************
 * COMMAND LINE CONTAINER
 **************************************************/
 .commandline-container {
	-fx-background-color: -fx-commandline-container-background;
	-fx-padding: 10 15 10 15;
 }

 .commandline {
	-fx-background-color: -fx-commandline-node;
	-fx-text-inner-color: -fx-default-text-color;
 }

 .commandline-enter-button {
	-fx-background-color: -fx-commandline-node;
	-fx-font-weight: bold;
	-fx-text-fill: -fx-default-text-color;
 }

/**************************************************
 * TASKS CONTAINER
 **************************************************/
 .tasks-container {
 	-fx-padding: 10 15 10 15;
 }
 
 .tasks-container .scroll-bar:vertical,
 .tasks-container .scroll-bar:horizontal {
 	-fx-background-color: transparent;
 }
 
 .tasks-container .scroll-bar:horizontal .increment-button,
 .tasks-container .scroll-bar:horizontal .increment-button:hover,
 .tasks-container .scroll-bar:horizontal .decrement-button,
 .tasks-container .scroll-bar:horizontal .decrement-button:hover{
    -fx-background-color: transparent;
    -fx-background-radius: 0;
    -fx-background-insets: 0;
    -fx-padding: 0;
    -fx-shape: null;
 }
 
 .tasks-container .scroll-bar .increment-arrow,
 .tasks-container .scroll-bar .increment-arrow:hover,
 .tasks-container .scroll-bar .decrement-arrow,
 .tasks-container .scroll-bar .decrement-arrow:hover {
    -fx-background-color: transparent;
    -fx-background-radius: 0;
    -fx-background-insets: 0;
    -fx-padding: 0 8px;
    -fx-shape: null;
 }

 .tasks-container .scroll-bar:horizontal .thumb,
 .tasks-container .scroll-bar:vertical .thumb {
    -fx-background-color: -fx-task-container-scrollbar;
    -fx-background-insets: 0 5px;
    -fx-opacity: 0.2;
	-fx-background-radius: 20px;
 }
 
 .tasks-container .scroll-bar:horizontal .thumb:hover,
 .tasks-container .scroll-bar:vertical .thumb:hover {
    -fx-opacity: 0.3;
 }
 
 .tasks-list {
 	-fx-padding: 3px;
 	-fx-background-color: inherit;
 	-fx-background-radius: 5;
 }
 
 .tasks-list-cell {
 	-fx-padding: 5px 0 20px 15px;
    -fx-background-color: -fx-default-text-color;
    -fx-background-radius: 10;
    -fx-background-insets: 0 0 10px 0;
 }
 
 .tasks-list-cell:empty {
    -fx-padding: 0;
    -fx-background-color: transparent;
    -fx-background-insets: 0;
 }
 
/**************************************************
 * SIDEBAR CONTAINER
 **************************************************/
 .sidebar-container {
 	-fx-padding: 10 15 10 15;
 	-fx-background-color: -fx-sidebar-container-background;
 }
 
 #sidebar-separator {
 	-fx-padding: 10 0 0 0;
 }
 
 #sidebar-navigation {
 	-fx-padding: 40 0 0 0;
 	-fx-background-color: -fx-sidebar-container-background;
 }
 
 #sidebar-navigation .list-cell:empty {
 	-fx-background-color: inherit;
 }
 
 #sidebar-navigation .list-cell:filled,
 #sidebar-navigation .list-cell:filled .label {
 	-fx-text-fill: -fx-sidebar-unselected-text-color;
 }
 
 #sidebar-navigation:focused .list-cell:filled:selected,
 #sidebar-navigation:focused .list-cell:filled:selected .label,
 #sidebar-navigation .list-cell:selected, 
 #sidebar-navigation .list-cell:selected .label {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-background-color: -fx-sidebar-selected-node;
 }
 
 .sidebar-navigation-cell {
 	-fx-font-weight: bold;
	-fx-font-size: 12pt;
 }
 
/**************************************************
 * CLOCK CONTAINER
 **************************************************/
 .clock-container {
 	
 }
 
 .clock-label-month-date {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-font-size: 16pt;
 }
 
 .clock-label-hour-minute-second {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-font-size: 16pt;
 }
 
 .clock-label-day-of-week {
 	-fx-text-fill: -fx-default-text-color;
 	-fx-font-size: 25pt;
	-fx-font-weight: bold;
 }
 
/**************************************************
 * NOTIFICATION
 **************************************************/
 .notification-content {
	-fx-background-color: -fx-notification-background;
 	-fx-background-radius: 10;
 	-fx-padding: 20 20 20 20;
 }
 
 .notification-title {
 	-fx-fill: -fx-default-text-color;
 	-fx-font-weight: bold;
	-fx-font-size: 12pt;
 }
 
 .notification-exit-button {
 	-fx-fill: -fx-notification-exit-node;
 	-fx-font-size: 12pt;
 }
 
 .notification-exit-button:hover {
 	-fx-fill: -fx-default-text-color;
 	-fx-font-weight: bold;
 	-fx-font-size: 12pt;
 }
 
 .notification-alert-message {
 	-fx-fill: -fx-default-text-color;
 	-fx-font-size: 12pt;
 }
```
###### \src\tasknote\ui\Scheduler.java
``` java
package tasknote.ui;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.util.Duration;
import tasknote.logic.TaskNoteControl;
import tasknote.shared.TaskObject;
import tasknote.shared.TaskObject.TaskStatus;

public class Scheduler {
    private TaskNoteControl _logic = null;
    private SimpleDateFormat dateFormat = new SimpleDateFormat("dd MMMMM yyyy");
    private SimpleDateFormat dateTimeFormat = new SimpleDateFormat("dd MMMMM yyyy hh:mma");

    private final int INTERVAL_SECOND_CHECK_OVERDUE_TASK = 5;

    /**
     * Initialize a Scheduler which will keep track of tasks that will soon be
     * overdue.
     * 
     * @param logic
     *            A TaskNoteControl to get access to the array of TaskObjects.
     */
    public Scheduler(TaskNoteControl logic) {
        this._logic = logic;
    }

    /**
     * Check for overdue task(s) periodically, and change their status
     * accordingly.
     */
    public void runOutstandingTaskCheck() {
        Timeline timeline = new Timeline(
                new KeyFrame(Duration.seconds(INTERVAL_SECOND_CHECK_OVERDUE_TASK), new EventHandler<ActionEvent>() {
                    @Override
                    public void handle(ActionEvent event) {
                        runCheck();
                    }
                }));
        timeline.setCycleCount(Timeline.INDEFINITE);
        timeline.play();
    }

    private void runCheck() {
        ArrayList<TaskObject> displayList = _logic.getDisplayList();

        try {
            checkForOutstandingTasks(displayList);
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }

    private void checkForOutstandingTasks(ArrayList<TaskObject> taskObjectList) throws ParseException {
        long currentTimeInMillisecond = System.currentTimeMillis();

        for (TaskObject task : taskObjectList) {
            if (task.getTaskType() == TaskObject.TASK_TYPE_FLOATING || task.getTaskStatus() == TaskStatus.TASK_COMPLETED) {
                continue;
            }

            String date = task.getFormattedDate();
            String time = task.getFormattedTime();

            Date dateObject = null;

            if (date.isEmpty() && time.isEmpty()) {
                continue;
            } else if (!date.isEmpty() && time.isEmpty()) {
                dateObject = dateFormat.parse(date);
            } else if (!date.isEmpty() && !time.isEmpty()) {
                dateObject = dateTimeFormat.parse(date + " " + time);
            }

            if (dateObject != null && dateObject.getTime() < currentTimeInMillisecond) {
                task.setTaskStatus(TaskStatus.TASK_OVERDUE);
            }
        }
    }
}
```
###### \src\tasknote\ui\SidebarContainer.java
``` java
package tasknote.ui;

import static tasknote.ui.GuiConstant.SPACING_BETWEEN_COMPONENTS;

import com.pepperonas.fxiconics.FxIconicsLabel;
import com.pepperonas.fxiconics.MaterialColor;
import com.pepperonas.fxiconics.cmd.FxFontCommunity.Icons;
import com.pepperonas.fxiconics.oct.FxFontOcticons;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Insets;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.Separator;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.util.Callback;

public class SidebarContainer extends VBox{
    public static final String NAVIGATION_TAG_VIEW_ALL = "View All";
    public static final String NAVIGATION_TAG_OUTSTANDING = "Outstanding";
    public static final String NAVIGATION_TAG_OVERDUE = "Overdue";
    public static final String NAVIGATION_TAG_COMPLETED = "Completed";
    public static final String NAVIGATION_TAG_SETTINGS = "Settings";
    
    public static final int NAVIGATION_TAG_VIEW_ALL_INDEX = 0;
    public static final int NAVIGATION_TAG_OUTSTANDING_INDEX = 1;
    public static final int NAVIGATION_TAG_OVERDUE_INDEX = 2;
    public static final int NAVIGATION_TAG_COMPLETED_INDEX = 3;
    
    private static SidebarContainer _sidebarContainer = null;
    private ClockContainer _clock = ClockContainer.getInstance();
    private ListView<String> _observableListRepresentation = new ListView<String>();
    private ObservableList<String> _navigationMenu = FXCollections.observableArrayList();
    private Separator _separator = new Separator();
    
    private String CSS_CLASS_SIDEBAR_CONTAINER = "sidebar-container";
    private String CSS_CLASS_SIDEBAR_SEPARATOR = "sidebar-separator";
    private String CSS_CLASS_SIDEBAR_NAVIGATION = "sidebar-navigation";
    private String CSS_CLASS_SIDEBAR_NAVIGATION_CELL = "sidebar-navigation-cell";
       
    private SidebarContainer() {
        // Only one instance of SidebarContainer is permitted
    }
    
    /**
     * getInstance() allows user to get an instance of SidebarContainer.
     * 
     * @return The one instance of SidebarContainer.
     */
    public static SidebarContainer getInstance() {
        if (_sidebarContainer == null) {
            _sidebarContainer = new SidebarContainer();
            _sidebarContainer.setupSidebarContainer();
        }
        return _sidebarContainer;
    }
    
    /**
     * getNavigationList() allows user to get the observable list contained
     * within SidebarContainer.
     * 
     * @return The ObservableList in SidebarContainer.
     */
    public ListView<String> getNavigationList() {
        return _observableListRepresentation;
    } 
    
    /**
     * This method allows the caller to select the 
     * list item based on the item index.
     * 
     * @param index Index of item in navigation bar.
     */
    public void selectNavigationCell(int index) {
        if(index > _navigationMenu.size()) {
            return;
        } else {
            _observableListRepresentation.getSelectionModel().select(index);
        }
    }

    private void setupSidebarContainer() {
        setSidebarContainerPresentation();
        setNavigationPresentation();
        setSeparatorPresentation();
        setNavigationBehaviour();
        
        this.getChildren().addAll(_clock, _separator, _observableListRepresentation);
    }
    
    private void setSidebarContainerPresentation() {
        this.getStyleClass().add(CSS_CLASS_SIDEBAR_CONTAINER);
        this.setSpacing(SPACING_BETWEEN_COMPONENTS);
    }
    
    private void setSeparatorPresentation() {
        _separator.setId(CSS_CLASS_SIDEBAR_SEPARATOR);
    }
    
    private void setNavigationPresentation() {
        _observableListRepresentation.setId(CSS_CLASS_SIDEBAR_NAVIGATION);
        _navigationMenu.addAll(NAVIGATION_TAG_VIEW_ALL, NAVIGATION_TAG_OUTSTANDING, NAVIGATION_TAG_OVERDUE, NAVIGATION_TAG_COMPLETED);
        _observableListRepresentation.setItems(_navigationMenu);
    }
    
    private void setNavigationBehaviour() {
        _observableListRepresentation.setCellFactory(new Callback<ListView<String>, ListCell<String>>() {
            @Override
            public ListCell<String> call(ListView<String>param) {
                return new ListCell<String>() {
                    @Override
                    public void updateItem(String value, boolean empty) {
                        super.updateItem(value, empty);
                        this.getStyleClass().add(CSS_CLASS_SIDEBAR_CONTAINER);
                        if (!isEmpty() && !value.isEmpty()) {
                            setGraphic(setNavigationCellPresentation(value));
                        } else if (!isEmpty() && value.isEmpty()) {
                            this.setDisable(true);
                        } else {
                            setText(null);
                            setGraphic(null);
                        }
                    }
                };
            }
        });
    }
    
    private HBox setNavigationCellPresentation(String value) {
        HBox box = new HBox();
        box.setPadding(new Insets(0, 0, 0, 20));
        box.setSpacing(20);
        
        if(!value.isEmpty() && !value.equals(NAVIGATION_TAG_SETTINGS)) {
            Icons icon = getIcon(value);
            FxIconicsLabel nvigationIcon = (FxIconicsLabel) new FxIconicsLabel.Builder(icon).size(24).color(MaterialColor.GREY_500).build();
            Label navigationText = new Label(value);
            navigationText.getStyleClass().add(CSS_CLASS_SIDEBAR_NAVIGATION_CELL);
            box.getChildren().addAll(nvigationIcon, navigationText);
        } else if (value.equals(NAVIGATION_TAG_SETTINGS)) {
            com.pepperonas.fxiconics.oct.FxFontOcticons.Icons icon = FxFontOcticons.Icons.oct_gear;
            FxIconicsLabel nvigationIcon = (FxIconicsLabel) new FxIconicsLabel.Builder(icon).size(24).color(MaterialColor.GREY_500).build();
            Label navigationText = new Label(value);
            navigationText.getStyleClass().add(CSS_CLASS_SIDEBAR_NAVIGATION_CELL);
            box.getChildren().addAll(nvigationIcon, navigationText);
        }
        
        return box;
    }
    
    private Icons getIcon(String value) {
        switch(value) {
            case NAVIGATION_TAG_VIEW_ALL:
                return Icons.cmd_home;
            case NAVIGATION_TAG_OUTSTANDING:
                return Icons.cmd_alarm_multiple;
            case NAVIGATION_TAG_OVERDUE:
                return Icons.cmd_comment_alert;
            case NAVIGATION_TAG_COMPLETED:
                return Icons.cmd_checkbox_multiple_marked;
            default:
                return null;
        }
    }
}
```
###### \src\tasknote\ui\TasksContainer.java
``` java
package tasknote.ui;

import static tasknote.ui.GuiConstant.PROPERTY_FONT_SIZE;
import static tasknote.ui.GuiConstant.PROPERTY_FONT_WEIGHT;
import static tasknote.ui.GuiConstant.SPACING_BETWEEN_COMPONENTS;

import javafx.beans.Observable;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.paint.Color;
import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;
import javafx.util.Callback;
import tasknote.shared.TaskObject;
import tasknote.shared.TaskObject.TaskStatus;

public class TasksContainer extends HBox {
    private static final String FORMAT_TASK_INDEX = "%1$d. ";
    private static final String FORMAT_TASK_DATE_TIME_PROPERTY = "%n\t%1$s, %2$s";
    private static final String FORMAT_TASK_DATE_PROPERTY = "%n\t%1$s";
    private static final String FORMAT_TASK_LOCATION_PROPERTY = "%n\t%1$s";
    
    /** Color(s) are used in formatting task(s) appearance */
    private static final Color LIGHT_GRAY = Color.rgb(150,141,143);
    private static final Color RED = Color.rgb(240, 100, 100);
    
    private static TasksContainer _tasksContainer = null;
    private ListView<TaskObject> _observableListRepresentation = new ListView<TaskObject>();
    private ObservableList<TaskObject> _tasksList = FXCollections
            .observableArrayList(taskobject -> new Observable[] { taskobject.getObservableTaskStatus() });
    
    private final String CSS_CLASS_TASKS_CONTAINER = "tasks-container";
    private final String CSS_CLASS_TASKS_LIST = "tasks-list";
    private final String CSS_CLASS_TASKS_LIST_CELL = "tasks-list-cell";
    
    private TasksContainer() {
        // Only one instance of TasksContainer is permitted
    }

    /**
     * getInstance() allows user to get an instance of TasksContainer.
     * 
     * @return The one instance of TasksContainer.
     */
    public static TasksContainer getInstance() {
        if (_tasksContainer == null) {
            _tasksContainer = new TasksContainer();
            _tasksContainer.setupTasksContainer();
        }
        return _tasksContainer;
    }

    /**
     * getTasksList() allows user to get the observable list contained within
     * TasksContainer.
     * 
     * @return The ObservableList in TasksContainer.
     */
    public ObservableList<TaskObject> getTasksList() {
        return _tasksList;
    }

    private void setupTasksContainer() {
        setTasksContainerPresentation();
        setTaskListPresentation();

        setTaskListBehaviour();

        this.getChildren().addAll(_observableListRepresentation);
    }

    private void setTasksContainerPresentation() {
        this.getStyleClass().add(CSS_CLASS_TASKS_CONTAINER);
        this.setSpacing(SPACING_BETWEEN_COMPONENTS);
    }

    private void setTaskListPresentation() {
        _observableListRepresentation.getStyleClass().add(CSS_CLASS_TASKS_LIST);
        _observableListRepresentation.setItems(_tasksList);
        HBox.setHgrow(_observableListRepresentation, Priority.ALWAYS);
    }

    private void setTaskListBehaviour() {
        _observableListRepresentation.setCellFactory(new Callback<ListView<TaskObject>, ListCell<TaskObject>>() {
            @Override
            public ListCell<TaskObject> call(ListView<TaskObject> param) {
                return new ListCell<TaskObject>() {
                    @Override
                    public void updateItem(TaskObject task, boolean empty) {
                        super.updateItem(task, empty);
                        this.getStyleClass().add(CSS_CLASS_TASKS_LIST_CELL);
                        if (!isEmpty()) {
                            setGraphic(getFormattedText(task));
                        } else {
                            setText(null);
                            setGraphic(null);
                        }
                    }
                };
            }
        });
    }
    
    /**
     * Create a formatted TextFlow, based on the TaskObject passed to it.
     * Color(s) will vary based on Task_Status set.
     * 
     * @param task
     *            The TaskObject to be formatted.
     * @return The formatted text (size, color), in the form of a TextFlow.
     */
    public static TextFlow getFormattedText(TaskObject task) {        
        TaskStatus taskStatus = task.getTaskStatus();
        Text taskIndex = null;
        Text taskNameValue = new Text(task.getTaskName());
        Text taskDateTimeValue = null;
        Text taskLocationValue = null;
        Text taskEndDateTimeValue = null;

        String taskDate = task.getFormattedDate();
        String taskTime = task.getFormattedTime();
        String taskLocation = task.getLocation();
        String taskEndDate = task.getFormattedEndDate();
        String taskEndTime = task.getFormattedEndTime();

        if (task.getTaskID() > 0) {
            taskIndex = new Text(String.format(FORMAT_TASK_INDEX, task.getTaskID()));
            taskIndex.setStyle(String.format(PROPERTY_FONT_WEIGHT, "bold"));
        }

        if (!taskDate.isEmpty() && !taskTime.isEmpty()) {
            taskDateTimeValue = new Text(String.format(FORMAT_TASK_DATE_TIME_PROPERTY, taskDate, taskTime));
            taskDateTimeValue.setStyle(String.format(PROPERTY_FONT_SIZE, 10));
        } else if (!taskDate.isEmpty() && taskTime.isEmpty()) {
            taskDateTimeValue = new Text(String.format(FORMAT_TASK_DATE_PROPERTY, taskDate));
            taskDateTimeValue.setStyle(String.format(PROPERTY_FONT_SIZE, 10));
        }

        if (taskLocation == null || !taskLocation.isEmpty()) {
            taskLocationValue = new Text(String.format(FORMAT_TASK_LOCATION_PROPERTY, taskLocation));
            taskLocationValue.setStyle(String.format(PROPERTY_FONT_SIZE, 10));
        }

        if (!taskEndDate.isEmpty() && !taskEndTime.isEmpty()) {
            taskEndDateTimeValue = new Text(String.format(FORMAT_TASK_DATE_TIME_PROPERTY, taskEndDate, taskEndTime));
            taskEndDateTimeValue.setStyle(String.format(PROPERTY_FONT_SIZE, 10));
        } else if (!taskEndDate.isEmpty() && taskEndTime.isEmpty()) {
            taskEndDateTimeValue = new Text(String.format(FORMAT_TASK_DATE_PROPERTY, taskEndDate));
            taskEndDateTimeValue.setStyle(String.format(PROPERTY_FONT_SIZE, 10));
        }

        return colorise(taskStatus, taskIndex, taskNameValue, taskDateTimeValue, taskLocationValue, taskEndDateTimeValue);
    }
    
    /**
     * Set the different color(s) for the individual components of Text in
     * TextFlow according to the Task_Status that was assigned.
     */
    private static TextFlow colorise(TaskStatus status, Text taskIndex, Text taskNameValue, Text taskDateTimeValue, Text taskLocationValue, Text taskEndDateTimeValue) {
        TextFlow colorisedText = new TextFlow();

        colorisedText.setPrefWidth(0);

        switch (status) {
            case TASK_OVERDUE:
                if (taskIndex != null) {
                    taskIndex.setFill(RED);
                }
                taskNameValue.setFill(RED);
                if (taskDateTimeValue != null) {
                    taskDateTimeValue.setFill(RED);
                }
                if (taskLocationValue != null) {
                    taskLocationValue.setFill(RED);
                }
                if (taskEndDateTimeValue != null) {
                    taskEndDateTimeValue.setFill(RED);
                }
                break;
            case TASK_COMPLETED:
                if (taskIndex != null) {
                    taskIndex.setFill(Color.GRAY);
                }
                taskNameValue.setFill(Color.GRAY);
                if (taskDateTimeValue != null) {
                    taskDateTimeValue.setFill(Color.GRAY);
                }
                if (taskLocationValue != null) {
                    taskLocationValue.setFill(Color.GRAY);
                }
                if (taskEndDateTimeValue != null) {
                    taskEndDateTimeValue.setFill(Color.GRAY);
                }
                break;
            case TASK_OUTSTANDING:
            default:
                if (taskIndex != null) {
                    taskIndex.setFill(LIGHT_GRAY);
                }
                taskNameValue.setFill(Color.BLACK);
                if (taskDateTimeValue != null) {
                    taskDateTimeValue.setFill(Color.MAROON);
                }
                if (taskLocationValue != null) {
                    taskLocationValue.setFill(Color.MAROON);
                }
                if (taskEndDateTimeValue != null) {
                    taskEndDateTimeValue.setFill(Color.MAROON);
                }
                break;
        }

        if (taskIndex != null) {
            colorisedText.getChildren().addAll(taskIndex);
        }
        colorisedText.getChildren().addAll(taskNameValue);

        if (taskDateTimeValue != null) {
            colorisedText.getChildren().addAll(taskDateTimeValue);
        }

        if (taskEndDateTimeValue != null) {
            colorisedText.getChildren().addAll(taskEndDateTimeValue);
        }

        if (taskLocationValue != null) {
            colorisedText.getChildren().addAll(taskLocationValue);
        }

        colorisedText.autosize();

        return colorisedText;
    }
}
```
