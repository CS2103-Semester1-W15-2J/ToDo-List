# A0129529W
###### \src\tasknote\parser\DateMessage.java
``` java
package tasknote.parser;

public class DateMessage {
	
	// Here are the constants that are specific to DateMessage
	private static final int DEFAULT_EXTRA_WORDS = 0;
	
	// Private fields
	private int day;
	private int month;
	private int year;
	private int extraWordsUsed;
	
	private String message;
	
	public DateMessage() {
		this.setDay(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
		this.setMonth(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
		this.setYear(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
		
		this.setExtraWordsUsed(DEFAULT_EXTRA_WORDS);
		
		this.setMessage(ParserConstants.MESSAGE_DATE_UNSURE);
	}

```
###### \src\tasknote\parser\DateParser.java
``` java
package tasknote.parser; 

import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;

import tasknote.shared.Constants;

public class DateParser {

	// Static constants that are applicable for DateParser
	private static final ArrayList<String> UNINITIALIZED_ARRAYLIST = null;
	private static final String UNITIALIZED_STRING = null;
	private static final DateMessage UNINITIALIZED_DATEMESSAGE = null;
	private static final int UNINITIALIZED_INT = -1;

	// Private fields
	private ArrayList<String> allPhrases;
	private int listPointer;

	private String currentPhrase;
	private int phraseCount;

	private DateMessage dateMessage;

	public DateParser() {
		this.setAllPhrases(UNINITIALIZED_ARRAYLIST);
		this.setListPointer(UNINITIALIZED_INT);

		this.setCurrentPhrase(UNITIALIZED_STRING);
		this.setPhraseCount(UNINITIALIZED_INT);

		this.setDateMessage(UNINITIALIZED_DATEMESSAGE);
	}

	public boolean isNotReady() {
		return this.getAllPhrases().equals(UNINITIALIZED_ARRAYLIST)
				|| this.getCurrentPhrase().equals(UNITIALIZED_STRING)
				|| this.getListPointer() == UNINITIALIZED_INT
				|| this.getPhraseCount() == UNINITIALIZED_INT;
	}


```
###### \src\tasknote\parser\DateParser.java
``` java
	public DateMessage tryToParseDate() {

		if (this.isNotReady()) {
			throw new RuntimeException("Need to set up DateParser first!");
		}

		// Begin trying to parse as date, through the chain of responsibilities
		DateMessage returnMessage = new DateMessage();
		returnMessage = tryToParseAsToday(returnMessage);

		return returnMessage;
	}

	// Chain of responsibility => (start) => Today => Tomorrow
	private DateMessage tryToParseAsToday(DateMessage passedMessage) {

		String currentPhrase = this.getCurrentPhrase();

		if (currentPhrase.equals(ParserConstants.DATE_LONG_TODAY)
				|| currentPhrase.equals(ParserConstants.DATE_SHORT_TODAY)) {

			// If the word found is "today" or "tdy", then parse as today's date
			GregorianCalendar today = new GregorianCalendar();
			int todayDay = today.get(Calendar.DAY_OF_MONTH);
			int todayMonth = today.get(Calendar.MONTH) + 1;
			int todayYear = today.get(Calendar.YEAR);

			passedMessage.setDay(todayDay);
			passedMessage.setMonth(todayMonth);
			passedMessage.setYear(todayYear);
			passedMessage.setMessage(ParserConstants.MESSAGE_DATE_SURE);

			return passedMessage;
		} else {

			return tryToParseAsTomorrow(passedMessage);
		}
	}

	// Chain of responsibility => Today => Tomorrow => SlashDot
	private DateMessage tryToParseAsTomorrow(DateMessage passedMessage) {

		String currentPhrase = this.getCurrentPhrase();

		if (currentPhrase.equals(ParserConstants.DATE_LONG_TOMORRROW)
				|| currentPhrase.equals(ParserConstants.DATE_SHORT_TOMORROW)) {

			// If the word found is "tomorrow" or "tmr", then parse as
			// tomorrow's date
			// Note: Rolling of Calendar is necessary
			GregorianCalendar tomorrow = new GregorianCalendar();
			tomorrow = DateParser.rollByDays(tomorrow, 1);

			passedMessage.setDay(tomorrow.get(Calendar.DAY_OF_MONTH));
			passedMessage.setMonth(tomorrow.get(Calendar.MONTH) + 1);
			passedMessage.setYear(tomorrow.get(Calendar.YEAR));
			passedMessage.setMessage(ParserConstants.MESSAGE_DATE_SURE);

			return passedMessage;
		} else {

			return tryToParseAsDay(passedMessage);
		}
	}
	
	private DateMessage tryToParseAsDay(DateMessage passedMessage) {
		
		String currentPhrase = this.getCurrentPhrase();
		
		if (ParserConstants.DAY_SET_UNMODIFIABLE.contains(currentPhrase)) {
			
			GregorianCalendar day = new GregorianCalendar();
			int dayOfWeek = day.get(Calendar.DAY_OF_WEEK);
			int targetDayOfWeek = ParserConstants.getDayFromString(currentPhrase);
			
			while (dayOfWeek != targetDayOfWeek) {
				day = DateParser.rollByDays(day, 1);
				dayOfWeek = day.get(Calendar.DAY_OF_WEEK);
			}
			
			passedMessage.setDay(day.get(Calendar.DAY_OF_MONTH));
			passedMessage.setMonth(day.get(Calendar.MONTH) + 1);
			passedMessage.setYear(day.get(Calendar.YEAR));
			passedMessage.setMessage(ParserConstants.MESSAGE_DATE_SURE);
			
			return passedMessage;
		} else {

			return tryToParseAsSlashDot(passedMessage);
		}
	}

	// Chain of responsibility => Tomorrow => SlashDot => Written
	private DateMessage tryToParseAsSlashDot(DateMessage passedMessage) {

		String currentPhrase = this.getCurrentPhrase();

		int givenDay = ParserConstants.DEFAULT_INVALID_INT_DATETIME;
		int givenMonth = ParserConstants.DEFAULT_INVALID_INT_DATETIME;
		int givenYear = ParserConstants.DEFAULT_INVALID_INT_DATETIME;

		String[] temporaryDateHolder;

		if (currentPhrase.contains(ParserConstants.DATE_SEPARATOR_SLASH)) {
			temporaryDateHolder = currentPhrase.split(ParserConstants.DATE_SEPARATOR_SLASH);
		} else if (currentPhrase.contains(ParserConstants.DATE_SEPARATOR_DASH)) {
			temporaryDateHolder = currentPhrase.split(ParserConstants.DATE_SEPARATOR_DASH);
		} else {
			return tryToParseAsWritten(passedMessage);
		}

		try {
			givenDay = Integer.parseInt(temporaryDateHolder[0]);
			givenMonth = Integer.parseInt(temporaryDateHolder[1]);
			givenYear = Integer.parseInt(temporaryDateHolder[2]);
			
			if (ParserConstants.isValidDay(givenDay) 
					&& ParserConstants.isValidMonth(givenMonth)) {
				passedMessage.setDay(givenDay);
				passedMessage.setMonth(givenMonth);
				passedMessage.setYear(givenYear);
				passedMessage.setMessage(ParserConstants.MESSAGE_DATE_SURE);
			}
			
			return passedMessage;
			
		} catch (NumberFormatException e) {

			return tryToParseAsWritten(passedMessage);
		}
	}

	// Chain of responsibility => SlashDot => Written => (end)
	private DateMessage tryToParseAsWritten(DateMessage passedMessage) {

		ArrayList<String> allPhrases = this.getAllPhrases();
		String currentPhrase = this.getCurrentPhrase();
		int listPointer = this.getListPointer();
		int phraseCount = this.getPhraseCount();

		String possibleDay = currentPhrase;
		int extraWordsUsed = 0;

		// Try to process day first
		// If not day, we are done
		boolean hasDayValue = tryToProcessDay(passedMessage, possibleDay);

		if (!hasDayValue) {
			return passedMessage;
		}
		
		// We advance the listPointer to get the next word
		// So that we can try to process the month, if given
		listPointer = listPointer + 1;

		String possibleMonth = Constants.STRING_CONSTANT_EMPTY;

		// After day of month, is there another word after this
		// to specify the month
		if (listPointer < phraseCount) {
			possibleMonth = allPhrases.get(listPointer).toLowerCase();
		}

		// Try to process month next
		// If not month, we fill it with today's month
		boolean hasMonthValue = tryToProcessMonth(passedMessage, possibleMonth);

		String possibleYear = Constants.STRING_CONSTANT_EMPTY;
		extraWordsUsed = passedMessage.getExtraWordsUsed();
		
		// We advance the listPointer once more to get the next word
		// So that we can try to process the year, if given
		listPointer = listPointer + 1;

		// Looking for year only makes sense if the month
		if (hasMonthValue && listPointer < phraseCount) {
			possibleYear = allPhrases.get(listPointer);
		}

		try {
			int numericYear = Integer.parseInt(possibleYear);

			passedMessage.setYear(numericYear);
			extraWordsUsed++;
		} catch (NumberFormatException e) {
			GregorianCalendar today = new GregorianCalendar();
			passedMessage.setYear(today.get(Calendar.YEAR));
		}

		passedMessage.setExtraWordsUsed(extraWordsUsed);

		return passedMessage;
	}

	private boolean tryToProcessDay(DateMessage passedMessage,
			String possibleDay) {

		// Trim stuff if required
		if (possibleDay.endsWith(ParserConstants.DATE_SUFFIX_ST)
				|| possibleDay.endsWith(ParserConstants.DATE_SUFFIX_ND)
				|| possibleDay.endsWith(ParserConstants.DATE_SUFFIX_RD)
				|| possibleDay.endsWith(ParserConstants.DATE_SUFFIX_TH)) {

			possibleDay = possibleDay.substring(0, possibleDay.length() - 2);
		}

		try {
			int numericDay = Integer.parseInt(possibleDay);
			
			if (ParserConstants.isValidDay(numericDay)) {
				passedMessage.setDay(numericDay);
				passedMessage.setMessage(ParserConstants.MESSAGE_DATE_SURE);
			}
			return true;
		} catch (NumberFormatException e) {
			return false;
		}
	}
	
	private boolean tryToProcessMonth(DateMessage passedMessage, String possibleMonth) {
		
		int extraWordsUsed = passedMessage.getExtraWordsUsed();
		
		int monthValue = ParserConstants.getMonthFromString(possibleMonth);

		if (ParserConstants.isValidMonth(monthValue)) {
			extraWordsUsed++;

			// If we found a word after the number that is a valid month
			// then we know that this must be a date value
			passedMessage.setMonth(monthValue);
			passedMessage.setExtraWordsUsed(extraWordsUsed);
			passedMessage.setMessage(ParserConstants.MESSAGE_DATE_SURE);
		} else {
			GregorianCalendar today = new GregorianCalendar();
			passedMessage.setMonth(today.get(Calendar.MONTH) + 1);
		}
		
		return true;
	}

	protected static GregorianCalendar rollByDays(GregorianCalendar initialCalendar,
			int numberOfDaysToRoll) {

		// Maximum values for current calendar
		int numberOfDaysThisYear = initialCalendar
				.getActualMaximum(Calendar.DAY_OF_YEAR);

		// Roll years first
		while (numberOfDaysToRoll >= numberOfDaysThisYear) {
			numberOfDaysToRoll = numberOfDaysToRoll - numberOfDaysThisYear;
			initialCalendar.roll(Calendar.YEAR, 1);

			numberOfDaysThisYear = initialCalendar
					.getActualMaximum(Calendar.DAY_OF_YEAR);
		}

		int numberOfDaysThisMonth = initialCalendar
				.getActualMaximum(Calendar.DAY_OF_MONTH);

		while (numberOfDaysToRoll >= numberOfDaysThisMonth) {
			numberOfDaysToRoll = numberOfDaysToRoll - numberOfDaysThisMonth;
			initialCalendar.roll(Calendar.MONTH, 1);

			// Check if month roll resulted in year roll
			if (initialCalendar.get(Calendar.MONTH) == Calendar.JANUARY) {
				initialCalendar.roll(Calendar.YEAR, 1);
			}

			numberOfDaysThisMonth = initialCalendar
					.getActualMaximum(Calendar.DAY_OF_MONTH);
		}

		while (numberOfDaysToRoll > 0) {
			numberOfDaysToRoll = numberOfDaysToRoll - 1;
			initialCalendar.roll(Calendar.DAY_OF_MONTH, 1);

			if (initialCalendar.get(Calendar.DAY_OF_MONTH) == 1) {
				initialCalendar.roll(Calendar.MONTH, 1);

				if (initialCalendar.get(Calendar.MONTH) == Calendar.JANUARY) {
					initialCalendar.roll(Calendar.YEAR, 1);
				}
			}
		}

		return initialCalendar;
	}

}
```
###### \src\tasknote\parser\ForwardCheckerWithBacktracking.java
``` java
package tasknote.parser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.GregorianCalendar;

public class ForwardCheckerWithBacktracking {
	
	// This contain the constant that is only useful for ForwardCheckerWithBacktracking
	protected static String SPECIAL_SKIP_TAG = "skip";

	// This are the private date fields used by this class
	private ArrayList<String> allPhrases;
	private int listPointer;
	private String[] allPhraseTypes;
	private String commandType;

	// The default constructor is not supported here
	// Constructor requires the entire processed user input for a meaningful check
	// The forward checker checks immediately upon object construction
	public ForwardCheckerWithBacktracking(ArrayList<String> allPhrases) {
		this.allPhrases = allPhrases;
		this.listPointer = 0;
		this.allPhraseTypes = new String[allPhrases.size()];

		approximateForwardCheck();
	}

	// This returns a String array containing all the marks assigned
	// to each phrase in the user input, mapped index to index
	public String[] getAllPhraseTypes() {
		return this.allPhraseTypes;
	}

	private void approximateForwardCheck() {

		String currentPhrase = this.allPhrases.get(listPointer).toLowerCase();
		int phraseCount = allPhrases.size();

		if (currentPhrase.equals(ParserConstants.COMMAND_ADD)) {
			this.commandType = ParserConstants.COMMAND_ADD;
			this.listPointer = 1;
			this.allPhraseTypes[0] = SPECIAL_SKIP_TAG;
		} else if (currentPhrase.equals(ParserConstants.COMMAND_EDIT)) {
			this.commandType = ParserConstants.COMMAND_EDIT;
			this.listPointer = 2;
			this.allPhraseTypes[0] = SPECIAL_SKIP_TAG;
			this.allPhraseTypes[1] = SPECIAL_SKIP_TAG;
		} else {
			throw new RuntimeException(
					"Forward checking is not necessary for non-add or non-edit commands");
		}

		String currentSwitchString = ParserConstants.SWITCH_STRING_NAME;

		// Forward Checking
		for (int currentPointer = listPointer; currentPointer < phraseCount; currentPointer++) {

			currentPhrase = this.allPhrases.get(currentPointer).toLowerCase();
			
			if (currentSwitchString.equals(ParserConstants.SWITCH_STRING_REMOVE)) {
				if (currentPhrase.equals(ParserConstants.SWITCH_STRING_DATE)
						|| currentPhrase.equals(ParserConstants.SWITCH_STRING_TIME)
						|| currentPhrase.equals(ParserConstants.SWITCH_STRING_NAME)
						|| currentPhrase.equals(ParserConstants.SWITCH_STRING_LOCATION)) {
					this.allPhraseTypes[currentPointer] = currentSwitchString;
					continue;
				} else {
					currentSwitchString = ParserConstants.decideNewSwitchString(currentPhrase);
					this.allPhraseTypes[currentPointer] = currentSwitchString;
					continue;
				}
			}

			if (currentSwitchString.equals(ParserConstants.SWITCH_STRING_NAME)) {
				currentSwitchString = ParserConstants.decideNewSwitchString(currentPhrase);
				this.allPhraseTypes[currentPointer] = currentSwitchString;
			} else if (currentSwitchString.equals(ParserConstants.SWITCH_STRING_DATETIMESTART)) {
				currentSwitchString = markDateTime(currentPhrase, currentSwitchString);
				this.allPhraseTypes[currentPointer] = currentSwitchString;
			} else if (currentSwitchString.equals(ParserConstants.SWITCH_STRING_DATETIMEEND)) {
				currentSwitchString = markDateTime(currentPhrase, currentSwitchString);
				this.allPhraseTypes[currentPointer] = currentSwitchString;
			} else if (currentSwitchString.equals(ParserConstants.SWITCH_STRING_DATE)) {
				currentSwitchString = markDate(currentPhrase, true);
				this.allPhraseTypes[currentPointer] = currentSwitchString;
			} else if (currentSwitchString.equals(ParserConstants.SWITCH_STRING_TIME)) {
				currentSwitchString = markTime(currentPhrase, true);
				this.allPhraseTypes[currentPointer] = currentSwitchString;
			} else if (currentSwitchString.equals(ParserConstants.SWITCH_STRING_LOCATIONTIME)) {
				currentSwitchString = markLocationTime(currentPhrase);
				this.allPhraseTypes[currentPointer] = currentSwitchString;
			} else if (currentSwitchString.equals(ParserConstants.SWITCH_STRING_LOCATION)) {
				currentSwitchString = markLocation(currentPhrase);
				this.allPhraseTypes[currentPointer] = currentSwitchString;
			} else if (currentSwitchString.equals(ParserConstants.SWITCH_STRING_REMOVE)){
				if (this.commandType.equals(ParserConstants.COMMAND_ADD)) {
					this.allPhraseTypes[currentPointer] = ParserConstants.SWITCH_STRING_NAME;
				} else {
					this.allPhraseTypes[currentPointer] = 
							ParserConstants.SWITCH_STRING_REMOVE;
				}
			} else {
				this.allPhraseTypes[currentPointer] = ParserConstants.SWITCH_STRING_NAME;
			}
		}
		
		String lastSeen = ParserConstants.SWITCH_STRING_NAME;
		String currentSeen = ParserConstants.SWITCH_STRING_NAME;
		
		// Backtracking
		for (int currentPointer = phraseCount - 1; currentPointer >= 0; currentPointer --) {
			
			if (currentPointer == (phraseCount - 1)) {
				lastSeen = this.allPhraseTypes[currentPointer];
				currentSeen = this.allPhraseTypes[currentPointer];
				continue;
			}
			
			lastSeen = this.allPhraseTypes[currentPointer + 1];
			currentSeen = this.allPhraseTypes[currentPointer];
			currentPhrase = this.allPhrases.get(currentPointer);
			
			// Current seen is by, on, from, or to
			if (currentSeen.equals(ParserConstants.SWITCH_STRING_DATETIMESTART)
					|| currentSeen.equals(ParserConstants.SWITCH_STRING_DATETIMEEND)) {
				
				// Keyword was not used as a keyword
				if (lastSeen.equals(ParserConstants.SWITCH_STRING_NAME)) {
					this.allPhraseTypes[currentPointer] = ParserConstants.SWITCH_STRING_NAME;
				}
			}
			
			// A whole bunch of Strings at the end, preceded by an at
			if (currentSeen.equals(ParserConstants.SWITCH_STRING_LOCATIONTIME)
					|| currentSeen.equals(ParserConstants.SWITCH_STRING_LOCATION)) {
				
				if (lastSeen.equals(ParserConstants.SWITCH_STRING_NAME)) {
					
					// Iteratively convert all "name" to "location";
					for (int shadowPointer = currentPointer + 1; shadowPointer < phraseCount; shadowPointer++) {
						
						if (this.allPhraseTypes[shadowPointer].equals(ParserConstants.SWITCH_STRING_NAME)) {
							this.allPhraseTypes[shadowPointer] = ParserConstants.SWITCH_STRING_LOCATION;
						} else {
							break;
						}
					}
				}
			}
			
			// Removes all redundant locationtime switchstrings
			if (currentSeen.equals(ParserConstants.SWITCH_STRING_LOCATIONTIME)) {
				
				if (lastSeen.equals(ParserConstants.SWITCH_STRING_LOCATION) 
						&& !currentPhrase.equals(ParserConstants.KEYWORD_AT)) {
					this.allPhraseTypes[currentPointer] = ParserConstants.SWITCH_STRING_LOCATION;
				}
				
				// Date time inversion
				// At keywords means that time must precede date
				if (lastSeen.equals(ParserConstants.SWITCH_STRING_DATE)) {
					this.allPhraseTypes[currentPointer] = ParserConstants.SWITCH_STRING_TIME;
				}
			}
		}
	}

	private String markDateTime(String currentPhrase, String globalSwitchString) {

		String dateMark = markDate(currentPhrase, true);
		String timeMark = markTime(currentPhrase, true);

		if (dateMark.equals(ParserConstants.SWITCH_STRING_DATE)
				&& timeMark.equals(ParserConstants.SWITCH_STRING_TIME)) {
			return globalSwitchString;
		}

		if (dateMark.equals(ParserConstants.SWITCH_STRING_DATE)) {
			return ParserConstants.SWITCH_STRING_DATE;
		}

		if (timeMark.equals(ParserConstants.SWITCH_STRING_TIME)) {
			return ParserConstants.SWITCH_STRING_TIME;
		}

		return ParserConstants.SWITCH_STRING_NAME;

	}

	private String markLocationTime(String currentPhrase) {

		String locationMark = markLocation(currentPhrase);
		String timeMark = markTime(currentPhrase, true);

		if (locationMark.equals(ParserConstants.SWITCH_STRING_DATE)) {
			return ParserConstants.SWITCH_STRING_DATE;
		}

		if (timeMark.equals(ParserConstants.SWITCH_STRING_TIME)) {
			
			// Paranoid double-checking
			if (currentPhrase.endsWith(ParserConstants.HOUR_MOD_AM)
					|| currentPhrase.endsWith(ParserConstants.HOUR_MOD_PM)
					|| currentPhrase.contains(ParserConstants.TIME_SEPARATOR_COLON)
					|| currentPhrase.contains(ParserConstants.TIME_SEPARATOR_DOT)) {
				return ParserConstants.SWITCH_STRING_TIME;
			} else {
				return ParserConstants.SWITCH_STRING_LOCATIONTIME;
			}
		}

		return ParserConstants.SWITCH_STRING_LOCATION;
	}

	private String markDate(String currentPhrase, boolean firstCheck) {

		String defaultSwitchString = ParserConstants.SWITCH_STRING_NAME;

		if (firstCheck) {
			defaultSwitchString = markTime(currentPhrase, false);

			if (!defaultSwitchString.equals(ParserConstants.SWITCH_STRING_TIME)) {
				defaultSwitchString = ParserConstants.SWITCH_STRING_NAME;
			}
		}

		String keywordCheck = ParserConstants.decideNewSwitchString(currentPhrase);

		if (!keywordCheck.equals(ParserConstants.SWITCH_STRING_NAME)) {
			return keywordCheck;
		}
		
		if (ParserConstants.DAY_SET_UNMODIFIABLE.contains(currentPhrase)) {
			return ParserConstants.SWITCH_STRING_DATE;
		}

		if (currentPhrase.equals(ParserConstants.DATE_LONG_TOMORRROW)
				|| currentPhrase.equals(ParserConstants.DATE_SHORT_TOMORROW)
				|| currentPhrase.equals(ParserConstants.DATE_LONG_TODAY)
				|| currentPhrase.equals(ParserConstants.DATE_SHORT_TODAY)) {
			return ParserConstants.SWITCH_STRING_DATE;
		}
		
		if (currentPhrase.contains(ParserConstants.DATE_SEPARATOR_SLASH)
				|| currentPhrase.contains(ParserConstants.DATE_SEPARATOR_DASH)) {
			
			String[] temporaryDateHolder;
			
			if (currentPhrase.contains(ParserConstants.DATE_SEPARATOR_SLASH)) {
				temporaryDateHolder = currentPhrase.split(ParserConstants.DATE_SEPARATOR_SLASH);
			} else {
				temporaryDateHolder = currentPhrase.split(ParserConstants.DATE_SEPARATOR_DASH);
			}
			
			GregorianCalendar today = new GregorianCalendar();
			
			String potentialDay = temporaryDateHolder[0];
			String potentialMonth = Integer.toString(today.get(Calendar.MONTH) + 1);
			String potentialYear = Integer.toString(today.get(Calendar.YEAR));
			
			if (temporaryDateHolder.length > 1) {
				potentialMonth = temporaryDateHolder[1];
			}
			
			if (temporaryDateHolder.length > 2) {
				potentialYear = temporaryDateHolder[2];
			}
			
			try {
				int potentialDayNumeric = Integer.parseInt(potentialDay);
				int potentialMonthNumeric = Integer.parseInt(potentialMonth);
				Integer.parseInt(potentialYear);
				
				if (!ParserConstants.isValidDay(potentialDayNumeric)
						|| !ParserConstants.isValidMonth(potentialMonthNumeric)) {
					throw new NumberFormatException();
				}
				
				return ParserConstants.SWITCH_STRING_DATE;
			} catch (NumberFormatException e) {
				return ParserConstants.SWITCH_STRING_NAME;
			}
		}

		if (currentPhrase.endsWith(ParserConstants.DATE_SUFFIX_ST)
				|| currentPhrase.endsWith(ParserConstants.DATE_SUFFIX_ND)
				|| currentPhrase.endsWith(ParserConstants.DATE_SUFFIX_RD)
				|| currentPhrase.endsWith(ParserConstants.DATE_SUFFIX_TH)) {
			currentPhrase = currentPhrase.substring(0, currentPhrase.length() - 2);

			try {
				int potentialDay = Integer.parseInt(currentPhrase);
				
				if (!ParserConstants.isValidDay(potentialDay)) {
					throw new NumberFormatException();
				}
				
				return ParserConstants.SWITCH_STRING_DATE;
			} catch (NumberFormatException e) {
				return ParserConstants.SWITCH_STRING_NAME;
			}
		}

		if (ParserConstants.getMonthFromString(currentPhrase) > 0) {
			return ParserConstants.SWITCH_STRING_DATE;
		}

		// If it contains neither date suffix, nor time suffix, and is not a
		// month then it is either a number (day, year) or String
		try {
			Integer.parseInt(currentPhrase);
			return ParserConstants.SWITCH_STRING_DATE;
		} catch (NumberFormatException e) {
			return ParserConstants.SWITCH_STRING_NAME;
		}
	}

	private String markTime(String currentPhrase, boolean firstCheck) {

		String defaultSwitchString = ParserConstants.SWITCH_STRING_NAME;

		if (firstCheck) {
			defaultSwitchString = markDate(currentPhrase, false);

			if (!defaultSwitchString.equals(ParserConstants.SWITCH_STRING_DATE)) {
				defaultSwitchString = ParserConstants.SWITCH_STRING_NAME;
			}
		}

		String keywordCheck = ParserConstants.decideNewSwitchString(currentPhrase);

		if (!keywordCheck.equals(ParserConstants.SWITCH_STRING_NAME)) {
			return keywordCheck;
		}

		if (currentPhrase.endsWith(ParserConstants.HOUR_MOD_AM)
				|| currentPhrase.endsWith(ParserConstants.HOUR_MOD_PM)) {
			currentPhrase = currentPhrase.substring(0, currentPhrase.length() - 2);
		}

		String potentialHour;
		String potentialMinute;

		if (currentPhrase.contains(ParserConstants.TIME_SEPARATOR_COLON)) {
			String[] potentialHourMinute = currentPhrase
					.split(ParserConstants.TIME_SEPARATOR_COLON);
			potentialHour = potentialHourMinute[0];
			potentialMinute = potentialHourMinute[1];
		} else if (currentPhrase.contains(ParserConstants.TIME_SEPARATOR_DOT)) {
			String[] potentialHourMinute = currentPhrase
					.split(ParserConstants.TIME_SEPARATOR_ESCAPED_DOT);
			potentialHour = potentialHourMinute[0];
			potentialMinute = potentialHourMinute[1];
		} else if (currentPhrase.length() > 2) {
			potentialHour = currentPhrase.substring(0, currentPhrase.length() - 2);
			potentialMinute = currentPhrase.substring(currentPhrase.length() - 2,
					currentPhrase.length());
		} else {

			// In this case, split will not split anything, if given a
			// separator
			// that the currentPhrase does not contain
			potentialHour = currentPhrase;
			potentialMinute = ParserConstants.DEFAULT_VALID_STRING_TIME;
		}

		try {

			int potentialHourNumeric = Integer.parseInt(potentialHour);
			int potentialMinuteNumeric = ParserConstants.DEFAULT_VALID_INT_TIME;

			if (!potentialMinute.equals(ParserConstants.DEFAULT_VALID_STRING_TIME)) {
				potentialMinuteNumeric = Integer.parseInt(potentialMinute);
			}

			if (!ParserConstants.isValidHour(potentialHourNumeric)
					|| !ParserConstants.isValidMinute(potentialMinuteNumeric)) {
				throw new NumberFormatException();
			}

			return ParserConstants.SWITCH_STRING_TIME;
		} catch (NumberFormatException e) {
			return defaultSwitchString;
		}

	}

	// This method name is a little deceptive
	// Checks to ensure that today and tomorrow (and their variants) are not
	// part
	// of the currentPhrase
	// Also checks if currentPhrase does not contain a keyword
	private String markLocation(String currentPhrase) {

		String keywordCheck = ParserConstants.decideNewSwitchString(currentPhrase);

		if (!keywordCheck.equals(ParserConstants.SWITCH_STRING_NAME)) {
			return keywordCheck;
		}

		if (currentPhrase.equals(ParserConstants.DATE_LONG_TODAY)
				|| currentPhrase.equals(ParserConstants.DATE_SHORT_TODAY)
				|| currentPhrase.equals(ParserConstants.DATE_LONG_TOMORRROW)
				|| currentPhrase.equals(ParserConstants.DATE_SHORT_TOMORROW)) {
			return ParserConstants.SWITCH_STRING_DATE;
		} else {
			return ParserConstants.SWITCH_STRING_LOCATION;
		}
	}

	public void setListPointer(int listPointer) {
		this.listPointer = listPointer;
	}

	public static void main(String[] args) {

		String randomTestInputOne = "edit 1 newtaskname at place remove date remove time by 23:59 on 15th feb";
		UserStringProcessor pfp = new UserStringProcessor(randomTestInputOne);
		ArrayList<String> firstAllPhrases = pfp.getProcessedInput();

		ForwardCheckerWithBacktracking fc = new ForwardCheckerWithBacktracking(firstAllPhrases);
		String[] resultOne = fc.getAllPhraseTypes();

		System.out.println(Arrays.toString(resultOne));
	}

}
```
###### \src\tasknote\parser\Parser.java
``` java
package tasknote.parser;

import tasknote.logic.ShowCategory;
import tasknote.logic.ShowInterval;
import tasknote.shared.COMMAND_TYPE;
import tasknote.shared.TaskObject;
import tasknote.shared.Constants;

import java.nio.file.InvalidPathException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.HashSet;

public class Parser {
	
	// Constants that are applicable to Parser
	private static final int POINTER_NOT_INITIALIZED = -1;
	private static final int POINTER_INITIALIZED = 0;
	private static final int POINTER_NOT_EDIT = 1;
	private static final int POINTER_EDIT = 2;

	// Private fields
	private ArrayList<String> allPhrases;
	private int listPointer;
	private COMMAND_TYPE commandType;
	private TaskObject objectForThisCommand;

	// Public constructor for Parser
	// Only the default constructor is supported
	public Parser() {
		this.setAllPhrases(null);
		this.setListPointer(POINTER_NOT_INITIALIZED);
		this.setCommandType(COMMAND_TYPE.INVALID);
		this.setObjectForThisCommand(null);
	}

	// Important command for users of parser
	// setInputString must be the first command called, or 
    // parser object will not run
	public void setInputString(String userCommand) {
		UserStringProcessor parserFirstPass = new UserStringProcessor(userCommand);
		this.setAllPhrases(parserFirstPass.getProcessedInput());
		this.setListPointer(POINTER_INITIALIZED);
		this.setCommandType(matchCommandType());

		// Create a new TaskObject only if it makes sense
		if (this.getCommandType() == COMMAND_TYPE.ADD
				|| this.getCommandType() == COMMAND_TYPE.UPDATE) {
			this.setObjectForThisCommand(new TaskObject());
		}
	}

	/**
	 * This method accepts an entire String passed from the user through his
	 * command line, and returns the matching COMMAND_TYPE
	 * 
	 * @param userCommand
	 *            This refers to the entire String that is passed by the user
	 *            through the command line
	 * 
	 * @return A COMMAND_TYPE enum value is returned. All the COMMAND_TYPE enums
	 *         can be found in the tasknote.shared package
	 * 
	 *         In the event where the command supplied by the user, does not
	 *         match any of the valid COMMAND_TYPES, the INVALID COMMAND_TYPE
	 *         value is returned instead
	 */
	public COMMAND_TYPE getCommandType() {
		return this.commandType;
	}

	private void setCommandType(COMMAND_TYPE commandType) {
		this.commandType = commandType;
	}

	// parseHelp should only be called if the COMMAND_TYPE was valid
	public COMMAND_TYPE parseHelp(boolean throwException) {

		// Make sure that the COMMAND_TYPE is accurate
		if (this.getCommandType() != COMMAND_TYPE.HELP) {
			throw new RuntimeException("Wrong method used for non-help type input!");
		}

		ArrayList<String> allPhrase = this.getAllPhrases();
		int allPhraseCount = allPhrase.size();
		COMMAND_TYPE returnValue = COMMAND_TYPE.INVALID;

		// This handles the case where "help" is the only
		// input supplied by the user
		if (allPhraseCount == 1) {
			return COMMAND_TYPE.HELP;
		} else {
			int nextPhrasePointer = this.getListPointer() + 1;
			this.setListPointer(nextPhrasePointer);
		}

		// Finally, we check to see which COMMAND_TYPE
		// matches the command given by the user
		// If none of the COMMAND_TYPE matches, the
		// INVALID COMMAND_TYPE is returned instead
		returnValue = matchCommandType();

		return returnValue;
	}

	// Public parseAdd method that constructs a TaskObject to
	// return to Logic
	public TaskObject parseAdd(boolean throwException) {

		if (this.getCommandType() != COMMAND_TYPE.ADD) {
			throw new RuntimeException("Wrong method used for non-add type input!");
		}

		TaskObject objectCreated = constructObject(false);
		return objectCreated;
	}

	// Public parseUpdate method that constructs a TaskObject as revision
	// and overlays it over the old TaskObject
	public TaskObject parseUpdate(TaskObject reallyOldTaskObject, boolean throwException) {

		if (this.getCommandType() != COMMAND_TYPE.UPDATE) {
			throw new RuntimeException("Wrong method used for non-edit type input!");
		}

		TaskObject objectCreated = constructObject(true);
		objectCreated = overlayTaskObject(reallyOldTaskObject, objectCreated);

		return objectCreated;
	}

	private TaskObject constructObject(boolean isEdit) {

		ArrayList<String> allPhrases = this.getAllPhrases();
		int phraseCount = allPhrases.size();

		if (isEdit) {
			this.setListPointer(POINTER_EDIT);
		} else {
			this.setListPointer(POINTER_NOT_EDIT);
		}

		ForwardCheckerWithBacktracking forwardChecker = new ForwardCheckerWithBacktracking(
				allPhrases);
		String[] allMarks = forwardChecker.getAllPhraseTypes();

		StringBuilder nameBuilder = new StringBuilder();
		StringBuilder locationBuilder = new StringBuilder();
		String currentPhrase = Constants.STRING_CONSTANT_EMPTY;

		boolean toStartDate = true;
		boolean toStartTime = true;

		ArrayList<String> allStartDateInfo = new ArrayList<>();
		ArrayList<String> allEndDateInfo = new ArrayList<>();

		ArrayList<String> allStartTimeInfo = new ArrayList<>();
		ArrayList<String> allEndTimeInfo = new ArrayList<>();

		for (int i = this.getListPointer(); i < phraseCount; i++) {

			currentPhrase = allPhrases.get(i);

			if (allMarks[i].equals(ParserConstants.SWITCH_STRING_NAME)) {
				nameBuilder.append(currentPhrase);
				nameBuilder.append(Constants.STRING_CONSTANT_SPACE);
				continue;
			}

			if (allMarks[i].equals(ParserConstants.SWITCH_STRING_LOCATIONTIME)
					|| allMarks[i].equals(ParserConstants.SWITCH_STRING_DATETIMESTART)
					|| allMarks[i].equals(ParserConstants.SWITCH_STRING_DATETIMEEND)) {

				// Only push to endDate or endTime if they are already filled
				if (allMarks[i].equals(ParserConstants.SWITCH_STRING_DATETIMEEND)) {
					if (!allStartDateInfo.isEmpty()) {
						toStartDate = false;
					}
					if (!allStartTimeInfo.isEmpty()) {
						toStartTime = false;
					}
				}
				continue;
			}

			if (allMarks[i].equals(ParserConstants.SWITCH_STRING_DATE)) {
				if (toStartDate) {
					allStartDateInfo.add(currentPhrase);
				} else {
					allEndDateInfo.add(currentPhrase);
				}
				continue;
			}

			if (allMarks[i].equals(ParserConstants.SWITCH_STRING_TIME)) {
				if (toStartTime) {
					allStartTimeInfo.add(currentPhrase);
				} else {
					allEndTimeInfo.add(currentPhrase);
				}
				continue;
			}

			if (allMarks[i].equals(ParserConstants.SWITCH_STRING_LOCATION)) {
				locationBuilder.append(currentPhrase);
				locationBuilder.append(Constants.STRING_CONSTANT_SPACE);
				continue;
			}
		}

		DateMessage startDate = tryToParseDate(allStartDateInfo);
		DateMessage endDate = tryToParseDate(allEndDateInfo);

		TimeMessage startTime = tryToParseTime(allStartTimeInfo);
		TimeMessage endTime = tryToParseTime(allEndTimeInfo);

		String finalTaskName = nameBuilder.toString().trim();
		String finalLocation = locationBuilder.toString().trim();

		this.objectForThisCommand.setTaskName(finalTaskName);
		this.objectForThisCommand.setLocation(finalLocation);

		setStartTime(startTime);
		setStartDate(startDate, startTime);
		setEndTime(endTime);
		setEndDate(endDate, endTime);

		return this.objectForThisCommand;
	}

	/**
	 * @param endDate
	 * @param endTime
	 */
	private void setEndDate(DateMessage endDate, TimeMessage endTime) {
		if (endDate.getDay() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
				&& endDate.getMonth() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
				&& endDate.getYear() != ParserConstants.DEFAULT_INVALID_INT_DATETIME) {
			this.objectForThisCommand.setEndDateDay(endDate.getDay());
			this.objectForThisCommand.setEndDateMonth(endDate.getMonth());
			this.objectForThisCommand.setEndDateYear(endDate.getYear());
			this.objectForThisCommand.setTaskType(TaskObject.TASK_TYPE_EVENT);
		} else {
			if (endTime.getHour() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
					&& endTime.getMinute() != ParserConstants.DEFAULT_INVALID_INT_DATETIME) {
				this.objectForThisCommand.setEndDateDay(this.objectForThisCommand.getDateDay());
				this.objectForThisCommand.setEndDateMonth(this.objectForThisCommand.getDateMonth());
				this.objectForThisCommand.setEndDateYear(this.objectForThisCommand.getDateYear());
			}
		}
	}

	/**
	 * @param endTime
	 */
	private void setEndTime(TimeMessage endTime) {
		if (endTime.getHour() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
				&& endTime.getMinute() != ParserConstants.DEFAULT_INVALID_INT_DATETIME) {
			this.objectForThisCommand.setEndDateHour(endTime.getHour());
			this.objectForThisCommand.setEndDateMinute(endTime.getMinute());
			this.objectForThisCommand.setTaskType(TaskObject.TASK_TYPE_EVENT);
		}
	}

	/**
	 * @param startDate
	 * @param startTime
	 */
	private void setStartDate(DateMessage startDate, TimeMessage startTime) {
		if (startDate.getDay() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
				&& startDate.getMonth() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
				&& startDate.getYear() != ParserConstants.DEFAULT_INVALID_INT_DATETIME) {
			this.objectForThisCommand.setDateDay(startDate.getDay());
			this.objectForThisCommand.setDateMonth(startDate.getMonth());
			this.objectForThisCommand.setDateYear(startDate.getYear());
			this.objectForThisCommand.setTaskType(TaskObject.TASK_TYPE_DEADLINE);
		} else {
			if (startTime.getHour() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
					&& startTime.getMinute() != ParserConstants.DEFAULT_INVALID_INT_DATETIME) {

				GregorianCalendar today = new GregorianCalendar();
				int todayTime = today.get(Calendar.HOUR_OF_DAY) * 60 + today.get(Calendar.MINUTE);
				int setTime = startTime.getHour() * 60 + startTime.getMinute();

				if (todayTime > setTime) {
					today = DateParser.rollByDays(today, 1);
				}

				this.objectForThisCommand.setDateDay(today.get(Calendar.DAY_OF_MONTH));
				this.objectForThisCommand.setDateMonth(today.get(Calendar.MONTH) + 1);
				this.objectForThisCommand.setDateYear(today.get(Calendar.YEAR));
			}
		}
	}

	/**
	 * @param startTime
	 */
	private void setStartTime(TimeMessage startTime) {
		if (startTime.getHour() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
				&& startTime.getMinute() != ParserConstants.DEFAULT_INVALID_INT_DATETIME) {
			this.objectForThisCommand.setDateHour(startTime.getHour());
			this.objectForThisCommand.setDateMinute(startTime.getMinute());
			this.objectForThisCommand.setTaskType(TaskObject.TASK_TYPE_DEADLINE);
		}
	}

	private TaskObject overlayTaskObject(TaskObject oldTaskObject, TaskObject newTaskObject) {

		ArrayList<String> allPhrases = this.getAllPhrases();
		int listPointer = POINTER_EDIT;
		int phraseCount = allPhrases.size();
		ForwardCheckerWithBacktracking forwardChecker = new ForwardCheckerWithBacktracking(
				allPhrases);
		String[] allMarks = forwardChecker.getAllPhraseTypes();
		String currentPhrase = Constants.STRING_CONSTANT_EMPTY;

		for (int i = listPointer; i < phraseCount; i++) {
			currentPhrase = allPhrases.get(i);
			if (allMarks[i].equals(ParserConstants.SWITCH_STRING_REMOVE)) {
				if (currentPhrase.equals(ParserConstants.SWITCH_STRING_REMOVE)) {
					continue;
				}

				if (currentPhrase.equals(ParserConstants.SWITCH_STRING_TIME)) {
					oldTaskObject.setDateHour(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
					oldTaskObject.setEndDateHour(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
					oldTaskObject.setDateMinute(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
					oldTaskObject.setEndDateMinute(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
					continue;
				}

				if (currentPhrase.equals(ParserConstants.SWITCH_STRING_DATE)) {
					oldTaskObject.setDateDay(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
					oldTaskObject.setEndDateDay(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
					oldTaskObject.setDateMonth(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
					oldTaskObject.setEndDateMonth(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
					oldTaskObject.setDateYear(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
					oldTaskObject.setEndDateYear(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
					continue;
				}

				if (currentPhrase.equals(ParserConstants.SWITCH_STRING_NAME)) {
					oldTaskObject.setTaskName(Constants.STRING_CONSTANT_EMPTY);
					continue;
				}

				if (currentPhrase.equals(ParserConstants.SWITCH_STRING_LOCATION)) {
					oldTaskObject.setLocation(Constants.STRING_CONSTANT_EMPTY);
					continue;
				}
			}
		}

		overlayTaskName(oldTaskObject, newTaskObject);
		overlayLocation(oldTaskObject, newTaskObject);
		overlayStartDate(oldTaskObject, newTaskObject);
		overlayStartTime(oldTaskObject, newTaskObject);
		overlayEndDate(oldTaskObject, newTaskObject);
		overlayEndTime(oldTaskObject, newTaskObject);

		// If date is *still* invalid and time exists
		if (newTaskObject.getDateDay() == ParserConstants.DEFAULT_INVALID_INT_DATETIME
				|| newTaskObject.getDateMonth() == ParserConstants.DEFAULT_INVALID_INT_DATETIME
				|| newTaskObject.getDateYear() == ParserConstants.DEFAULT_INVALID_INT_DATETIME) {

			if (newTaskObject.getDateHour() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
					&& newTaskObject.getDateMinute() != ParserConstants.DEFAULT_INVALID_INT_DATETIME) {

				GregorianCalendar today = new GregorianCalendar();
				int todayTime = today.get(Calendar.HOUR_OF_DAY) * 60 + today.get(Calendar.MINUTE);
				int setTime = newTaskObject.getDateHour() * 60 + newTaskObject.getDateMinute();

				if (todayTime > setTime) {
					today = DateParser.rollByDays(today, 1);
				}

				newTaskObject.setDateDay(today.get(Calendar.DAY_OF_MONTH));
				newTaskObject.setDateMonth(today.get(Calendar.MONTH) + 1);
				newTaskObject.setDateYear(today.get(Calendar.YEAR));
			}
		}

		if (newTaskObject.getEndDateDay() == ParserConstants.DEFAULT_INVALID_INT_DATETIME
				|| newTaskObject.getEndDateMonth() == ParserConstants.DEFAULT_INVALID_INT_DATETIME
				|| newTaskObject.getEndDateYear() == ParserConstants.DEFAULT_INVALID_INT_DATETIME) {

			if (newTaskObject.getEndDateHour() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
					&& newTaskObject.getEndDateMinute() != ParserConstants.DEFAULT_INVALID_INT_DATETIME) {
				newTaskObject.setEndDateDay(newTaskObject.getDateDay());
				newTaskObject.setEndDateMonth(newTaskObject.getDateMonth());
				newTaskObject.setEndDateYear(newTaskObject.getDateYear());
			}
		}
		
		if (newTaskObject.getDateDay() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
				&& newTaskObject.getDateMonth() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
				&& newTaskObject.getDateYear() != ParserConstants.DEFAULT_INVALID_INT_DATETIME) {
			newTaskObject.setTaskType(TaskObject.TASK_TYPE_DEADLINE);
		}
		
		if (newTaskObject.getEndDateDay() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
				&& newTaskObject.getEndDateMonth() != ParserConstants.DEFAULT_INVALID_INT_DATETIME
				&& newTaskObject.getEndDateYear() != ParserConstants.DEFAULT_INVALID_INT_DATETIME) {
			newTaskObject.setTaskType(TaskObject.TASK_TYPE_EVENT);
		}

		return newTaskObject;
	}

	/**
	 * @param oldTaskObject
	 * @param newTaskObject
	 */
	private void overlayEndTime(TaskObject oldTaskObject, TaskObject newTaskObject) {
		if (newTaskObject.getEndDateHour() == ParserConstants.DEFAULT_INVALID_INT_DATETIME
				|| newTaskObject.getEndDateMinute() == ParserConstants.DEFAULT_INVALID_INT_DATETIME) {
			newTaskObject.setEndDateHour(oldTaskObject.getEndDateHour());
			newTaskObject.setEndDateMinute(oldTaskObject.getEndDateMinute());
		}
	}

	/**
	 * @param oldTaskObject
	 * @param newTaskObject
	 */
	private void overlayEndDate(TaskObject oldTaskObject, TaskObject newTaskObject) {
		if (newTaskObject.getEndDateDay() == ParserConstants.DEFAULT_INVALID_INT_DATETIME
				|| newTaskObject.getEndDateMonth() == ParserConstants.DEFAULT_INVALID_INT_DATETIME
				|| newTaskObject.getEndDateYear() == ParserConstants.DEFAULT_INVALID_INT_DATETIME) {
			newTaskObject.setEndDateDay(oldTaskObject.getEndDateDay());
			newTaskObject.setEndDateMonth(oldTaskObject.getEndDateMonth());
			newTaskObject.setEndDateYear(oldTaskObject.getEndDateYear());
		}
	}

	/**
	 * @param oldTaskObject
	 * @param newTaskObject
	 */
	private void overlayStartTime(TaskObject oldTaskObject, TaskObject newTaskObject) {
		if (newTaskObject.getDateHour() == ParserConstants.DEFAULT_INVALID_INT_DATETIME
				|| newTaskObject.getDateMinute() == ParserConstants.DEFAULT_INVALID_INT_DATETIME) {
			newTaskObject.setDateHour(oldTaskObject.getDateHour());
			newTaskObject.setDateMinute(oldTaskObject.getDateMinute());
		}
	}

	/**
	 * @param oldTaskObject
	 * @param newTaskObject
	 */
	private void overlayStartDate(TaskObject oldTaskObject, TaskObject newTaskObject) {
		if (newTaskObject.getDateDay() == ParserConstants.DEFAULT_INVALID_INT_DATETIME
				|| newTaskObject.getDateMonth() == ParserConstants.DEFAULT_INVALID_INT_DATETIME
				|| newTaskObject.getDateYear() == ParserConstants.DEFAULT_INVALID_INT_DATETIME) {
			newTaskObject.setDateDay(oldTaskObject.getDateDay());
			newTaskObject.setDateMonth(oldTaskObject.getDateMonth());
			newTaskObject.setDateYear(oldTaskObject.getDateYear());
		}
	}

	/**
	 * @param oldTaskObject
	 * @param newTaskObject
	 */
	private void overlayLocation(TaskObject oldTaskObject, TaskObject newTaskObject) {
		if (newTaskObject.getLocation().equals(Constants.STRING_CONSTANT_EMPTY)) {
			newTaskObject.setLocation(oldTaskObject.getLocation());
		}
	}

	/**
	 * @param oldTaskObject
	 * @param newTaskObject
	 */
	private void overlayTaskName(TaskObject oldTaskObject, TaskObject newTaskObject) {
		if (newTaskObject.getTaskName().equals(Constants.STRING_CONSTANT_EMPTY)) {
			newTaskObject.setTaskName(oldTaskObject.getTaskName());
		}
	}

	public ArrayList<Integer> parseDelete(boolean throwException) {

		if (this.getCommandType() != COMMAND_TYPE.DELETE) {
			throw new RuntimeException("Wrong method used for non-add type input!");
		}

		ArrayList<String> allPhrases = this.getAllPhrases();
		int listPointer = POINTER_NOT_EDIT;
		int phraseCount = allPhrases.size();

		ArrayList<Integer> list = new ArrayList<Integer>();

		for (int i = listPointer; i < phraseCount; i++) {

			String nextCommand = allPhrases.get(i).toLowerCase();

			if (nextCommand.equals("-") || nextCommand.equals("to")) {

				try {

					int endID = Integer.parseInt(allPhrases.get(i + 1)) - 1;
					int startID = list.get(list.size() - 1);

					startID++;
					i++;

					while (startID <= endID) {

						list.add(startID);
						startID++;
					}

				} catch (NumberFormatException e) {

					if (throwException) {
						NumberFormatException e2 = new NumberFormatException(
								"Cannot delete non-numeric ID");
						System.out.println(e2);
						throw e2;
					} else {

						// Let it continue running, ignoring this bad value
						continue;
					}

				} catch (IndexOutOfBoundsException e) {

					if (throwException) {
						IndexOutOfBoundsException e2 = new IndexOutOfBoundsException(
								"No start of range ID was found");
						System.out.println(e2);
						throw e2;
					} else {

						// Let it continue running, ignoring this bad value
						continue;
					}
				}
			} else {

				try {

					int nextID = Integer.parseInt(nextCommand) - 1;

					list.add(nextID);

				} catch (NumberFormatException e) {

					if (throwException) {
						NumberFormatException e2 = new NumberFormatException(
								"Cannot delete non-numeric ID");
						System.out.println(e2);
						throw e2;
					} else {
						// Let it continue running, ignoring this bad value
						continue;
					}
				}
			}
		}

		return list;
	}

	// Ahead of SuperParser
	public ArrayList<Integer> parseSearch(ArrayList<TaskObject> displayList, boolean throwException) {

		ArrayList<String> allPhrases = this.getAllPhrases();
		int phraseCount = allPhrases.size();
		int itemCount = displayList.size();
		int listPointer = POINTER_NOT_EDIT;

		HashSet<Integer> indicesToRemove = new HashSet<>();
		HashSet<Integer> indicesToReturn = new HashSet<>();

		for (int i = 0; i < itemCount; i++) {
			indicesToReturn.add(i);
		}

		String testKeyWord = allPhrases.get(listPointer).toLowerCase();
		boolean exactOnly = false;

		if (phraseCount > 2 && testKeyWord.equals("exact")) {
			exactOnly = true;
		}

		for (int i = listPointer; i < phraseCount; i++) {

			String currentPhrase = allPhrases.get(i).toLowerCase();

			if (exactOnly && i == 1) {
				continue;
			}

			for (int j = 0; j < itemCount; j++) {
				String currentTaskName = displayList.get(j).getTaskName().toLowerCase();

				if (!exactOnly) {

					if (!currentTaskName.contains(currentPhrase)) {
						indicesToRemove.add(j);
					}
				} else {

					String[] splitTaskName = currentTaskName.split(Constants.STRING_CONSTANT_SPACE);

					indicesToRemove.add(j);

					for (int k = 0; k < splitTaskName.length; k++) {
						if (currentPhrase.equals(splitTaskName[k])) {
							indicesToRemove.remove(j);
							break;
						}
					}
				}

			}

			indicesToReturn.removeAll(indicesToRemove);
		}

		ArrayList<Integer> listToReturn = new ArrayList<>();
		listToReturn.addAll(indicesToReturn);

		return listToReturn;
	}

	public ShowInterval parseShow(boolean throwException) {

		ArrayList<String> allPhrases = this.getAllPhrases();
		this.setListPointer(POINTER_NOT_EDIT);
		
		for (int i = this.getListPointer(); i < allPhrases.size(); i++) {

			String currentPhrase = allPhrases.get(i).toLowerCase();

			if (currentPhrase.equals("today")) {
				return ShowInterval.TODAY;
			}

			if (currentPhrase.equals("tomorrow")) {
				return ShowInterval.TOMORROW;
			}
			
			if (currentPhrase.equals("year") || currentPhrase.equals("years")) {
				return ShowInterval.YEAR;
			}
			
			if (currentPhrase.equals("month") || currentPhrase.equals("months")) {
				return ShowInterval.MONTH;
			}

			if (currentPhrase.equals("week") || currentPhrase.equals("weeks")) {
				return ShowInterval.WEEK;
			}

			if (currentPhrase.equals("day") || currentPhrase.equals("days")) {
				return ShowInterval.DAY;
			}

			if (currentPhrase.equals("all")) {
				return ShowInterval.ALL;
			}
		}

		// Default behaviour - consider throwing exception
		if (throwException) {
			throw new RuntimeException("Could not understand what to show!");
		} else {
			return ShowInterval.ALL;
		}

	}

	public ShowCategory parseChangeCategory(boolean throwException) {

		ArrayList<String> allPhrases = this.getAllPhrases();
		int phraseCount = allPhrases.size();

		if (phraseCount >= 2) {

			String currentPhrase = allPhrases.get(1).toLowerCase();

			if (currentPhrase.equals("outstanding")) {
				return ShowCategory.OUTSTANDING;
			}

			if (currentPhrase.equals("overdue")) {
				return ShowCategory.OVERDUE;
			}

			if (currentPhrase.equals("completed")) {
				return ShowCategory.COMPLETED;
			}

			if (currentPhrase.equals("all")) {
				return ShowCategory.ALL;
			}
		}

		// Default behaviour - consider throwing exception
		if (throwException) {
			throw new RuntimeException("Could not understand what to show!");
		} else {
			return ShowCategory.ALL;
		}
	}

	public int getInterval(boolean throwException) {

		ArrayList<String> allPhrases = this.getAllPhrases();
		int phraseCount = allPhrases.size();
		int listPointer = this.getListPointer();

		for (int i = listPointer; i < phraseCount; i++) {

			String currentPhrase = allPhrases.get(i).toLowerCase();

			if (currentPhrase.equals(ParserConstants.INTERVAL_LONG_TODAY)
					|| currentPhrase.equals(ParserConstants.INTERVAL_LONG_TOMORROW)
					|| currentPhrase.equals(ParserConstants.INTERVAL_LONG_ALL)) {
				return -1;
			}

			if (currentPhrase.equals("next")) {

				int forwardCounter = i + 1;

				// Defensive check
				if (forwardCounter == phraseCount) {
					return -1;
				}

				currentPhrase = allPhrases.get(forwardCounter).toLowerCase();

				// Trivial case
				if (currentPhrase.equals("week") || currentPhrase.equals("day")) {
					return 1;
				}

				// Recursive case
				if (currentPhrase.equals("next")) {

					int nextCount = 2;
					forwardCounter++;

					while (forwardCounter < phraseCount) {

						currentPhrase = allPhrases.get(forwardCounter).toLowerCase();

						if (currentPhrase.equals("next")) {
							nextCount++;
							forwardCounter++;
							continue;
						}

						if (currentPhrase.equals("week") || currentPhrase.equals("day")) {
							return nextCount;
						}

						if (throwException) {
							// Consider changing exception type
							RuntimeException e = new RuntimeException(
									"Could not identify how far ahead to show. "
											+ "Use the following command for more details:\n help show");
							System.out.println(e);
							throw e;
						} else {

							// Default value
							return -1;
						}

					}

					if (throwException) {
						// Consider changing exception type
						RuntimeException e = new RuntimeException(
								"Could not identify how far ahead to show. "
										+ "Use the following command for more details:\n help show");
						System.out.println(e);
						throw e;
					} else {

						// Default value
						return -1;
					}
				}

				// Numeric case + all other cases
				try {

					int placeOfWeekKeyword = forwardCounter + 1;

					// Defensive check
					if (placeOfWeekKeyword == phraseCount) {
						return -1;
					}

					int returnValue = Integer.parseInt(currentPhrase);
					currentPhrase = allPhrases.get(placeOfWeekKeyword).toLowerCase();

					if (returnValue <= 0) {
						NumberFormatException e = new NumberFormatException(
								"Unable to show negative weeks/days");
						System.out.println(e);
						throw e;
					}

					if (currentPhrase.equals("week") || currentPhrase.equals("weeks")
							|| currentPhrase.equals("day") || currentPhrase.equals("days")) {
						return returnValue;
					} else {
						if (throwException) {
							// Consider changing exception type
							RuntimeException e = new RuntimeException(
									"Could not identify how far ahead to show. "
											+ "Use the following command for more details:\n help show");
							System.out.println(e);
							throw e;
						} else {

							// Default value
							return -1;
						}
					}

				} catch (NumberFormatException e) {

					if (throwException) {
						NumberFormatException e2 = new NumberFormatException(
								"Unable to show non-numerical weeks/days");
						System.out.println(e2);
						throw e2;
					} else {

						// Default value
						return -1;
					}

				} catch (RuntimeException e) {
					if (throwException) {
						// Consider changing exception type
						RuntimeException e2 = new RuntimeException(
								"Could not identify how far ahead to show. "
										+ "Use the following command for more details:\n help show");
						System.out.println(e2);
						throw e2;
					} else {

						// Default value
						return -1;
					}
				}
			}
		}

		if (throwException) {
			// Consider changing exception type
			RuntimeException e = new RuntimeException("Could not identify how far ahead to show. "
					+ "Use the following command for more details:\n help show");
			System.out.println(e);
			throw e;
		} else {

			// Default value
			return -1;
		}
	}

	public String parseFilePath(boolean throwException) {

		ArrayList<String> allPhrases = this.getAllPhrases();
		int phraseCount = allPhrases.size();
		int listPointer = POINTER_NOT_EDIT;

		for (int i = listPointer; i < phraseCount; i++) {

			String currentPhrase = allPhrases.get(i);

			try {

				Paths.get(currentPhrase);
				return currentPhrase;

			} catch (InvalidPathException | NullPointerException e) {
				continue;
			}
		}

		if (throwException) {

			RuntimeException e = new RuntimeException(
					"Could not find valid file path in command supplied. "
							+ "Consult the following for more details:\n help relocate");
			System.out.println(e);
			throw e;
		} else {

			// Default value
			return Constants.STRING_CONSTANT_EMPTY;
		}
	}

	public int getTaskId(boolean throwException) {

		ArrayList<String> allPhrases = this.getAllPhrases();
		String currentPhrase = allPhrases.get(POINTER_NOT_EDIT);

		try {

			int returnValue = Integer.parseInt(currentPhrase) - 1;

			return returnValue;
		} catch (NumberFormatException e) {

			if (throwException) {

				NumberFormatException e2 = new NumberFormatException(
						"ID for editing task is not valid.");
				System.out.println(e2);
				throw e2;

			} else {
				return -1;
			}
		}
	}

	private DateMessage tryToParseDate(ArrayList<String> allDateInfo) {

		int listPointer = POINTER_INITIALIZED;
		int phraseCount = allDateInfo.size();

		if (phraseCount == 0) {
			return new DateMessage();
		}

		String currentPhrase = allDateInfo.get(listPointer);

		DateParser dateParser = new DateParser();
		dateParser.setAllPhrases(allDateInfo);
		dateParser.setCurrentPhrase(currentPhrase);
		dateParser.setListPointer(listPointer);
		dateParser.setPhraseCount(phraseCount);

		DateMessage returnMessage = dateParser.tryToParseDate();

		return returnMessage;
	}

	private TimeMessage tryToParseTime(ArrayList<String> allTimeInfo) {

		int listPointer = POINTER_INITIALIZED;
		int phraseCount = allTimeInfo.size();

		if (phraseCount == 0) {
			return new TimeMessage();
		}

		String currentPhrase = allTimeInfo.get(listPointer);

		TimeParser timeParser = new TimeParser();
		timeParser.setCurrentPhrase(currentPhrase);

		TimeMessage returnMessage = timeParser.tryToParseTime();

		return returnMessage;

	}

	protected boolean isNumber(String stringToTest) {

		try {
			Integer.parseInt(stringToTest);
			return true;
		} catch (NumberFormatException e) {
			return false;
		}
	}

	private boolean hasValidInputLength(COMMAND_TYPE command) {

		ArrayList<String> allPhrases = this.getAllPhrases();
		int remainingPhrasesCount = allPhrases.size() - this.getListPointer();
		int expectedMinimumLength = ParserConstants.getMinimumCommandLength(command);

		return remainingPhrasesCount >= expectedMinimumLength;
	}

	// This method does not throw exceptions or check for userCommand length
	private COMMAND_TYPE matchCommandType() {

		ArrayList<String> allPhrases = this.getAllPhrases();
		int listPointer = this.getListPointer();
		String currentPhrase = allPhrases.get(listPointer).toLowerCase();

		COMMAND_TYPE returnValue = COMMAND_TYPE.INVALID;

		// Finally, we check to see which COMMAND_TYPE
		// matches the command given by the user
		// If none of the COMMAND_TYPE matches, the
		// INVALID COMMAND_TYPE is returned instead
		if (currentPhrase.equals(ParserConstants.COMMAND_ADD)) {
			returnValue = COMMAND_TYPE.ADD;
		} else if (currentPhrase.equals(ParserConstants.COMMAND_EDIT)) {
			return COMMAND_TYPE.UPDATE;
		} else if (currentPhrase.equals(ParserConstants.COMMAND_DELETE)) {
			return COMMAND_TYPE.DELETE;
		} else if (currentPhrase.equals(ParserConstants.COMMAND_SEARCH)) {
			return COMMAND_TYPE.SEARCH;
		} else if (currentPhrase.equals(ParserConstants.COMMAND_EXIT)) {
			return COMMAND_TYPE.EXIT;
		} else if (currentPhrase.equals(ParserConstants.COMMAND_DONE)) {
			return COMMAND_TYPE.DONE;
		} else if (currentPhrase.equals(ParserConstants.COMMAND_REDO)) {
			return COMMAND_TYPE.REDO;
		} else if (currentPhrase.equals(ParserConstants.COMMAND_UNDO)) {
			return COMMAND_TYPE.UNDO;
		} else if (currentPhrase.equals(ParserConstants.COMMAND_SHOW)) {
			return COMMAND_TYPE.SHOW;
		} else if (currentPhrase.equals(ParserConstants.COMMAND_RELOCATE)) {
			return COMMAND_TYPE.CHANGE_FILE_PATH;
		} else if (currentPhrase.equals(ParserConstants.COMMAND_HELP)) {
			return COMMAND_TYPE.HELP;
		} else if (currentPhrase.equals(ParserConstants.COMMAND_UNDONE)) {
			return COMMAND_TYPE.UNDONE;
		} else if (currentPhrase.equals(ParserConstants.COMMAND_CATEGORY)) {
			return COMMAND_TYPE.CHANGE_CATEGORY;
		} else {
			return COMMAND_TYPE.INVALID;
		}

		if (!hasValidInputLength(returnValue)) {
			returnValue = COMMAND_TYPE.INVALID;
		}

		return returnValue;

	}

```
###### \src\tasknote\parser\ParserAddTest.java
``` java
package tasknote.parser;

import static org.junit.Assert.*;

import org.junit.Test;

import java.util.Calendar;
import java.util.GregorianCalendar;

import tasknote.shared.TaskObject;

public class ParserAddTest {

	Parser testParser = new Parser();

	@Test
	public void testAddBasicFloatingTask() {

		String userCommand = "add longtaskname";
		this.testParser.setInputString(userCommand);

		TaskObject expectedResult = new TaskObject("longtaskname");
		TaskObject actualResult = this.testParser.parseAdd(false);

		assertEquals(expectedResult, actualResult);
	}

	@Test
	public void testAddBasicDeadline() {

		// This should generally prevent cases where the add
		// function automatically rolls the date to the next day
		// for the purpose of checking

		TaskObject expectedResult = new TaskObject("longdeadline");

		GregorianCalendar today = new GregorianCalendar();
		expectedResult.setDateYear(today.get(Calendar.YEAR));
		expectedResult.setDateMonth(today.get(Calendar.MONTH) + 1);
		expectedResult.setDateDay(today.get(Calendar.DAY_OF_MONTH));
		expectedResult.setDateHour(23);
		expectedResult.setDateMinute(59);

		expectedResult.setTaskType("deadline");

		// Test all keywords allowed by Parser
		String[] validKeywords = { "by", "on", "at" };

		for (int i = 0; i < validKeywords.length; i++) {

			String userCommand = "add longdeadline " + validKeywords[i] + " 23:59";
			this.testParser.setInputString(userCommand);

			TaskObject actualResult = this.testParser.parseAdd(false);

			assertEquals(expectedResult, actualResult);
		}
	}

	@Test
	public void testAddBasicDeadlineBadHourBadMinute() {

		// This should generally prevent cases where the add
		// function automatically rolls the date to the next day
		// for the purpose of checking

		String[] validKeywords = { "by", "on", "at" };

		for (int i = 0; i < validKeywords.length; i++) {

			String userCommand = "add baddeadlinehourminute " + validKeywords[i] + " 76:90";
			this.testParser.setInputString(userCommand);

			TaskObject expectedResult = new TaskObject();

			// For this case, "at" keyword would treat 76:90 as location
			// since it is not a valid time
			if (validKeywords[i].equals("at")) {
				expectedResult.setTaskName("baddeadlinehourminute");
				expectedResult.setLocation("76:90");
			} else {
				expectedResult.setTaskName("baddeadlinehourminute " + validKeywords[i] + " 76:90");
			}

			TaskObject actualResult = this.testParser.parseAdd(false);

			assertEquals(expectedResult, actualResult);
		}
	}

	@Test
	public void testAddBasicDeadlineBadHour() {

		// This should generally prevent cases where the add
		// function automatically rolls the date to the next day
		// for the purpose of checking
		String userCommand = "add baddeadlinehour by 76:31";
		this.testParser.setInputString(userCommand);

		TaskObject expectedResult = new TaskObject("baddeadlinehour by 76:31");
		TaskObject actualResult = this.testParser.parseAdd(false);

		assertEquals(expectedResult, actualResult);
	}

	@Test
	public void testAddBasicDeadlineBadMinute() {

		// This should generally prevent cases where the add
		// function automatically rolls the date to the next day
		// for the purpose of checking
		String userCommand = "add baddeadlineminute by 15:99";
		this.testParser.setInputString(userCommand);

		TaskObject expectedResult = new TaskObject("baddeadlineminute by 15:99");
		TaskObject actualResult = this.testParser.parseAdd(false);

		assertEquals(expectedResult, actualResult);
	}

	@Test
	public void testAddBasicDeadlineWithDate() {

		// This should generally prevent cases where the add
		// function automatically rolls the date to the next day
		// for the purpose of checking
		String userCommand = "add longerdeadline on 1/2/2001 by 5:30";
		this.testParser.setInputString(userCommand);

		TaskObject expectedResult = new TaskObject("longerdeadline");

		expectedResult.setDateYear(2001);
		expectedResult.setDateMonth(2);
		expectedResult.setDateDay(1);
		expectedResult.setDateHour(5);
		expectedResult.setDateMinute(30);

		expectedResult.setTaskType(TaskObject.TASK_TYPE_DEADLINE);

		TaskObject actualResult = this.testParser.parseAdd(false);

		assertEquals(expectedResult, actualResult);
	}

	@Test
	public void testAddBasicDeadlineBadDay() {

		// This should generally prevent cases where the add
		// function automatically rolls the date to the next day
		// for the purpose of checking
		String userCommand = "add longerdeadlinebadday on 45/2/2001 by 23:59";
		this.testParser.setInputString(userCommand);

		TaskObject expectedResult = new TaskObject("longerdeadlinebadday on 45/2/2001");

		GregorianCalendar today = new GregorianCalendar();
		expectedResult.setDateYear(today.get(Calendar.YEAR));
		expectedResult.setDateMonth(today.get(Calendar.MONTH) + 1);
		expectedResult.setDateDay(today.get(Calendar.DAY_OF_MONTH));
		expectedResult.setDateHour(23);
		expectedResult.setDateMinute(59);

		expectedResult.setTaskType(TaskObject.TASK_TYPE_DEADLINE);

		TaskObject actualResult = this.testParser.parseAdd(false);

		assertEquals(expectedResult, actualResult);
	}

	@Test
	public void testAddBasicDeadlineBadMonth() {

		// This should generally prevent cases where the add
		// function automatically rolls the date to the next day
		// for the purpose of checking
		String userCommand = "add longerdeadlinebadmonth on 15/22/2001 by 23:59";
		this.testParser.setInputString(userCommand);

		TaskObject expectedResult = new TaskObject("longerdeadlinebadmonth on 15/22/2001");

		GregorianCalendar today = new GregorianCalendar();
		expectedResult.setDateYear(today.get(Calendar.YEAR));
		expectedResult.setDateMonth(today.get(Calendar.MONTH) + 1);
		expectedResult.setDateDay(today.get(Calendar.DAY_OF_MONTH));
		expectedResult.setDateHour(23);
		expectedResult.setDateMinute(59);

		expectedResult.setTaskType(TaskObject.TASK_TYPE_DEADLINE);

		TaskObject actualResult = this.testParser.parseAdd(false);
		
		assertEquals(expectedResult, actualResult);
	}

	@Test
	public void testAddBasicDeadlineBadDayBadMonth() {

		// This should generally prevent cases where the add
		// function automatically rolls the date to the next day
		// for the purpose of checking
		String userCommand = "add longerdeadlinebaddaybadmonth on 49/22/2001 by 23:59";
		this.testParser.setInputString(userCommand);

		TaskObject expectedResult = new TaskObject("longerdeadlinebaddaybadmonth on 49/22/2001");

		GregorianCalendar today = new GregorianCalendar();
		expectedResult.setDateYear(today.get(Calendar.YEAR));
		expectedResult.setDateMonth(today.get(Calendar.MONTH) + 1);
		expectedResult.setDateDay(today.get(Calendar.DAY_OF_MONTH));
		expectedResult.setDateHour(23);
		expectedResult.setDateMinute(59);

		expectedResult.setTaskType("deadline");

		TaskObject actualResult = this.testParser.parseAdd(false);

		assertEquals(expectedResult, actualResult);
	}

	@Test
	public void testAddBadTaskWithDateWithoutTime() {

		// In this case, the TaskObject is still assigned
		// the date field, but the GUI will ignore it
		String userCommand = "add badtask on 2/3/2002";
		this.testParser.setInputString(userCommand);

		TaskObject expectedResult = new TaskObject("badtask");

		expectedResult.setDateYear(2002);
		expectedResult.setDateMonth(3);
		expectedResult.setDateDay(2);

		TaskObject actualResult = this.testParser.parseAdd(false);

		assertEquals(expectedResult, actualResult);
	}

	@Test
	public void testAddDeadlineJoinDateTime() {

		TaskObject expectedResult = new TaskObject("joineddatetimetask");

		GregorianCalendar today = new GregorianCalendar();
		expectedResult.setDateYear(today.get(Calendar.YEAR));
		expectedResult.setDateMonth(today.get(Calendar.MONTH) + 1);
		expectedResult.setDateDay(15);

		expectedResult.setDateHour(21);
		expectedResult.setDateMinute(0);

		String[] validKeywords = { "by", "on", "at" };

		for (int i = 0; i < validKeywords.length; i++) {
			String userCommand = "add joineddatetimetask by 9pm 15th";
			this.testParser.setInputString(userCommand);

			TaskObject actualResult = this.testParser.parseAdd(false);

			assertEquals(expectedResult, actualResult);
		}
	}

	@Test
	public void testSpecialMcdonaldsThatGCalCannotHandle() {

		TaskObject expectedResult = new TaskObject("breakfast with mk");

		GregorianCalendar tomorrow = new GregorianCalendar();

		tomorrow = DateParser.rollByDays(tomorrow, 1);

		expectedResult.setDateYear(tomorrow.get(Calendar.YEAR));
		expectedResult.setDateMonth(tomorrow.get(Calendar.MONTH) + 1);
		expectedResult.setDateDay(tomorrow.get(Calendar.DAY_OF_MONTH));

		expectedResult.setDateHour(10);
		expectedResult.setDateMinute(0);

		expectedResult.setLocation("8 redhill st, mcd");

		String[] validKeywords = { "by", "on", "at" };

		for (int i = 0; i < validKeywords.length; i++) {
			String userCommand = "add breakfast with mk at 8 redhill st, mcd " + validKeywords[i]
					+ " 10am tomorrow";
			this.testParser.setInputString(userCommand);

			TaskObject actualResult = this.testParser.parseAdd(false);

			assertEquals(expectedResult, actualResult);
		}
	}
}
```
###### \src\tasknote\parser\ParserCommandReturnTest.java
``` java
package tasknote.parser;

import static org.junit.Assert.*;
import org.junit.Test;

import tasknote.shared.COMMAND_TYPE;

public class ParserCommandReturnTest {
	
	Parser testParser = new Parser();

	@Test
	public void testReturnAddCommand() {
		
		String userCommand = "add some task";
		this.testParser.setInputString(userCommand);
		
		COMMAND_TYPE expectedResult = COMMAND_TYPE.ADD;
		COMMAND_TYPE actualResult = this.testParser.getCommandType();
		
		assertEquals(expectedResult, actualResult);
	}
	
	@Test
	public void testReturnAddCommandCaseInsensitive() {
		
		String userCommand = "AdD sOmE TaSK";
		this.testParser.setInputString(userCommand);
		
		COMMAND_TYPE expectedResult = COMMAND_TYPE.ADD;
		COMMAND_TYPE actualResult = this.testParser.getCommandType();
		
		assertEquals(expectedResult, actualResult);
	}
	
	@Test
	public void testReturnSearchCommand() {
		
		String userCommand = "search stuff";
		this.testParser.setInputString(userCommand);
		
		COMMAND_TYPE expectedResult = COMMAND_TYPE.SEARCH;
		COMMAND_TYPE actualResult = this.testParser.getCommandType();
		
		assertEquals(expectedResult, actualResult);
	}
	
	@Test
	public void testReturnEditCommand() {
		
		String userCommand = "edit 3 morestuff";
		this.testParser.setInputString(userCommand);
		
		COMMAND_TYPE expectedResult = COMMAND_TYPE.UPDATE;
		COMMAND_TYPE actualResult = this.testParser.getCommandType();
		
		assertEquals(expectedResult, actualResult);
	}
	
	@Test
	public void testReturnDeleteCommand() {
		
		String userCommand = "delete 1 2 3";
		this.testParser.setInputString(userCommand);
		
		COMMAND_TYPE expectedResult = COMMAND_TYPE.DELETE;
		COMMAND_TYPE actualResult = this.testParser.getCommandType();
		
		assertEquals(expectedResult, actualResult);
	}
	
	@Test
	public void testReturnExitCommand() {
		
		String userCommand = "exit";
		this.testParser.setInputString(userCommand);
		
		COMMAND_TYPE expectedResult = COMMAND_TYPE.EXIT;
		COMMAND_TYPE actualResult = this.testParser.getCommandType();
		
		assertEquals(expectedResult, actualResult);
	}
	
	@Test
	public void testReturnInvalidtCommand() {
		
		String userCommand = "sgnsdnsgioapgo";
		this.testParser.setInputString(userCommand);
		
		COMMAND_TYPE expectedResult = COMMAND_TYPE.INVALID;
		COMMAND_TYPE actualResult = this.testParser.getCommandType();
		
		assertEquals(expectedResult, actualResult);
	}
	
	@Test
	public void testReturnInvalidAddCommand() {
		
		// Add command requires at least one other parameter to act
		// as the new task name
		String userCommand = "add";
		this.testParser.setInputString(userCommand);
		
		COMMAND_TYPE expectedResult = COMMAND_TYPE.INVALID;
		COMMAND_TYPE actualResult = this.testParser.getCommandType();
		
		assertEquals(expectedResult, actualResult);
	}
}
```
###### \src\tasknote\parser\ParserConstants.java
``` java
package tasknote.parser;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import tasknote.shared.COMMAND_TYPE;
import tasknote.shared.Constants;

// Utility class
// This class does no processing, only returns constants
public class ParserConstants {
	
	// Here are the valid commands accepted by
	// the program
	protected static final String COMMAND_ADD = "add";
	protected static final String COMMAND_EDIT = "edit";
	protected static final String COMMAND_DONE = "done";
	protected static final String COMMAND_DELETE = "delete";
	protected static final String COMMAND_UNDO = "undo";
	protected static final String COMMAND_REDO = "redo";
	protected static final String COMMAND_EXIT = "exit";
	protected static final String COMMAND_SEARCH = "search";
	protected static final String COMMAND_SHOW = "show";
	protected static final String COMMAND_RELOCATE = "relocate";
	protected static final String COMMAND_CATEGORY = "category";
	protected static final String COMMAND_HELP = "help";
	protected static final String COMMAND_UNDONE = "undone";

	// Here are the valid keywords accepted by
	// the program
	protected static final String KEYWORD_BY = "by";
	protected static final String KEYWORD_AT = "at";
	protected static final String KEYWORD_ON = "on";
	protected static final String KEYWORD_FROM = "from";
	protected static final String KEYWORD_TO = "to";
	protected static final String KEYWORD_IN = "in";
	protected static final String KEYWORD_REMOVE = "remove";
	
	protected static final String[] KEYWORDS_ALL = {KEYWORD_BY, KEYWORD_AT, KEYWORD_ON,
		KEYWORD_FROM, KEYWORD_TO, KEYWORD_IN, KEYWORD_REMOVE};
	
	protected static final HashSet<String> KEYWORD_SET = new HashSet<>(Arrays.asList(KEYWORDS_ALL));
	protected static final Set<String> KEYWORD_SET_UNMODIFIABLE = 
			Collections.unmodifiableSet(KEYWORD_SET);
	
	protected static final String SWITCH_STRING_DATETIME = "datetime";
	protected static final String SWITCH_STRING_DATETIMESTART = "datetimestart";
	protected static final String SWITCH_STRING_DATETIMEEND = "datetimeend";
	protected static final String SWITCH_STRING_LOCATIONTIME = "locationtime";
	protected static final String SWITCH_STRING_NAME = "name";
	protected static final String SWITCH_STRING_DATE = "date";
	protected static final String SWITCH_STRING_TIME = "time";
	protected static final String SWITCH_STRING_LOCATION = "location";
	protected static final String SWITCH_STRING_REMOVE = "remove";
	
	// Here are the valid day words accepted by Parser
	protected static final String DAY_LONG_SUN = "sunday";
	protected static final String DAY_LONG_MON = "monday";
	protected static final String DAY_LONG_TUE = "tuesday";
	protected static final String DAY_LONG_WED = "wednesday";
	protected static final String DAY_LONG_THU = "thursday";
	protected static final String DAY_LONG_FRI = "friday";
	protected static final String DAY_LONG_SAT = "saturday";
	

	protected static final String DAY_SHORT_SUN = "sun";
	protected static final String DAY_SHORT_MON = "mon";
	protected static final String DAY_SHORT_TUE = "tue";
	protected static final String DAY_SHORT_WED = "wed";
	protected static final String DAY_SHORT_THU = "thu";
	protected static final String DAY_SHORT_FRI = "fri";
	protected static final String DAY_SHORT_SAT = "sat";

	protected static final int DAY_WEEK_MAX = 7;
	
	protected static final String[] DAYS_ALL = {DAY_LONG_SUN, DAY_LONG_MON, DAY_LONG_TUE, 
		DAY_LONG_WED, DAY_LONG_THU, DAY_LONG_FRI, DAY_LONG_SAT, DAY_SHORT_SUN, DAY_SHORT_MON,
		DAY_SHORT_TUE, DAY_SHORT_WED, DAY_SHORT_THU, DAY_SHORT_FRI, DAY_SHORT_SAT};
	
	protected static final HashSet<String> DAY_SET = new HashSet<>(Arrays.asList(DAYS_ALL));
	protected static final Set<String> DAY_SET_UNMODIFIABLE = 
			Collections.unmodifiableSet(DAY_SET);
	
	// Here are the valid month words accepted by Parser
	protected static final String MONTH_LONG_JAN = "january";
	protected static final String MONTH_LONG_FEB = "february";
	protected static final String MONTH_LONG_MAR = "march";
	protected static final String MONTH_LONG_APR = "april";
	protected static final String MONTH_LONG_MAY = "may";
	protected static final String MONTH_LONG_JUN = "june";
	protected static final String MONTH_LONG_JUL = "july";
	protected static final String MONTH_LONG_AUG = "august";
	protected static final String MONTH_LONG_SEP = "september";
	protected static final String MONTH_LONG_OCT = "october";
	protected static final String MONTH_LONG_NOV = "november";
	protected static final String MONTH_LONG_DEC = "december";
	
	protected static final String MONTH_SHORT_JAN = "jan";
	protected static final String MONTH_SHORT_FEB = "feb";
	protected static final String MONTH_SHORT_MAR = "mar";
	protected static final String MONTH_SHORT_APR = "apr";
	protected static final String MONTH_SHORT_MAY = "may";
	protected static final String MONTH_SHORT_JUN = "jun";
	protected static final String MONTH_SHORT_JUL = "jul";
	protected static final String MONTH_SHORT_AUG = "aug";
	protected static final String MONTH_SHORT_SEP = "sep";
	protected static final String MONTH_SHORT_OCT = "oct";
	protected static final String MONTH_SHORT_NOV = "nov";
	protected static final String MONTH_SHORT_DEC = "dec";
	
	protected static final String[] MONTHS_ALL = {MONTH_LONG_JAN, MONTH_LONG_FEB, 
		MONTH_LONG_MAR, MONTH_LONG_APR, MONTH_LONG_MAY, MONTH_LONG_JUN, MONTH_LONG_JUL,
		MONTH_LONG_AUG, MONTH_LONG_SEP, MONTH_LONG_OCT, MONTH_LONG_NOV, MONTH_LONG_DEC,
		MONTH_SHORT_JAN, MONTH_SHORT_FEB, MONTH_SHORT_MAR, MONTH_SHORT_APR, 
		MONTH_SHORT_MAY, MONTH_SHORT_JUN, MONTH_SHORT_JUL, MONTH_SHORT_AUG,
		MONTH_SHORT_SEP, MONTH_SHORT_OCT, MONTH_SHORT_NOV, MONTH_SHORT_DEC};
	
	protected static final HashSet<String> MONTH_SET = new HashSet<>(Arrays.asList(MONTHS_ALL));
	protected static final Set<String> MONTH_SET_UNMODIFIABLE = 
			Collections.unmodifiableSet(MONTH_SET);
	
	// Here are the int constants for date and time
	protected static final int MONTH_MIN = 1;
	protected static final int MONTH_MAX = 12;
	
	protected static final int DAY_MIN = 1;
	protected static final int DAY_MAX = 31;
	
	protected static final int HOUR_MIN = 0;
	protected static final int HOUR_MAX = 23;
	
	protected static final int MINUTE_MIN = 0;
	protected static final int MINUTE_MAX = 59;
	
	// Here are the default time value in String and Integer
	protected static final int DEFAULT_VALID_INT_TIME = 0;
	protected static final String DEFAULT_VALID_STRING_TIME = "0";
	
	// Here are the default invalid time value in String and Integer
	protected static final int DEFAULT_INVALID_INT_DATETIME = -1;
	protected static final String DEFAULT_INVALID_STRING_DATETIME = "-1";
	
	
	// Here are the hour modifiers for time
	protected static final String HOUR_MOD_AM = "am";
	protected static final String HOUR_MOD_PM = "pm";
	
	// Here are the accepted time separators
	protected static final String TIME_SEPARATOR_DOT = ".";
	protected static final String TIME_SEPARATOR_ESCAPED_DOT = "\\.";
	protected static final String TIME_SEPARATOR_COLON = ":";
	
	// Here are the accepeted date separators
	protected static final String DATE_SEPARATOR_DASH = "-";
	protected static final String DATE_SEPARATOR_SLASH = "/";
	
	// Here are the suffixes that might appear on a date day
	protected static final String DATE_SUFFIX_ST = "st";
	protected static final String DATE_SUFFIX_ND = "nd";
	protected static final String DATE_SUFFIX_RD = "rd";
	protected static final String DATE_SUFFIX_TH = "th";
	
	// Here are all the english date "modifiers"
	protected static final String DATE_LONG_TODAY = "today";
	protected static final String DATE_LONG_TOMORRROW = "tomorrow";
	
	protected static final String DATE_SHORT_TODAY = "tdy";
	protected static final String DATE_SHORT_TOMORROW = "tmr";
	
	// Here are all the interval constants
	protected static final String INTERVAL_LONG_TODAY = "today";
	protected static final String INTERVAL_LONG_TOMORROW = "tomorrow";
	protected static final String INTERVAL_LONG_ALL = "all";
	
	// Here is the date modification qualifier
	protected static final String DATE_MOD_NEXT = "next";
	
	// Here is the date modification quantifier
	protected static final String DATE_MOD_LONG_DAY = "day";
	protected static final String DATE_MOD_LONG_DAYS = "days";
	protected static final String DATE_MOD_LONG_WEEK = "week";
	protected static final String DATE_MOD_LONG_WEEKS = "weeks";
	protected static final String DATE_MOD_LONG_MONTH = "month";
	protected static final String DATE_MOD_LONG_MONTHS = "months";
	protected static final String DATE_MOD_LONG_YEAR = "year";
	protected static final String DATE_MOD_LONG_YEARS = "years";
	
	protected static final String DATE_MOD_SHORT_DAY = "d";
	protected static final String DATE_MOD_SHORT_WEEK = "w";
	protected static final String DATE_MOD_SHORT_MONTH = "m";
	protected static final String DATE_MOD_SHORT_YEAR = "y";
	
	// Here are the values used by message passing
	// for DateMessage and TimeMessage
	protected static final String MESSAGE_DATE_UNSURE = "maybeNotDate";
	protected static final String MESSAGE_DATE_SURE = "isDate";
	
	protected static final String MESSAGE_TIME_UNSURE = "maybeNotTime";
	protected static final String MESSAGE_TIME_SURE = "isTime";
	
	// Here are all the minimum length of the expected user command
	protected static final int MINIMUM_ADD = 2;
	protected static final int MINIMUM_EDIT = 3;
	protected static final int MINIMUM_DONE = 2;
	protected static final int MINIMUM_DELETE = 2;
	protected static final int MINIMUM_UNDO = 1;
	protected static final int MINIMUM_REDO = 1;
	protected static final int MINIMUM_EXIT = 1;
	protected static final int MINIMUM_SEARCH = 2;
	protected static final int MINIMUM_SHOW = 2;
	protected static final int MINIMUM_RELOCATE = 2;
	protected static final int MINIMUM_HELP = 1;
	protected static final int MINIMUM_UNDONE = 2;
	protected static final int MINIMUM_INVALID = 0;
	protected static final int MINIMUM_CATEGORY = 2;

	protected static int getMinimumCommandLength(COMMAND_TYPE command) {
		
		int returnValue = MINIMUM_INVALID;
		
		switch (command) {
			case ADD:
				returnValue = MINIMUM_ADD;
				break;
			case UPDATE:
				returnValue = MINIMUM_EDIT;
				break;
			case DONE:
				returnValue = MINIMUM_DONE;
				break;
			case DELETE:
				returnValue = MINIMUM_DELETE;
				break;
			case UNDO:
				returnValue = MINIMUM_UNDO;
				break;
			case REDO:
				returnValue = MINIMUM_REDO;
				break;
			case EXIT:
				returnValue = MINIMUM_EXIT;
				break;
			case SEARCH:
				returnValue = MINIMUM_SEARCH;
				break;
			case SHOW:
				returnValue = MINIMUM_SHOW;
				break;
			case CHANGE_CATEGORY:
				returnValue = MINIMUM_CATEGORY;
			case CHANGE_FILE_PATH:
				returnValue = MINIMUM_RELOCATE;
				break;
			case HELP:
				returnValue = MINIMUM_HELP;
				break;
			case UNDONE:
				returnValue = MINIMUM_UNDONE;
				break;
				
			// default includes the case for which COMMAND_TYPE is INVALID
			default:
				returnValue = MINIMUM_INVALID;
				break;
		}
		
		return returnValue;
	}
	
	protected static String decideNewSwitchString(String keyword) {

		String returnValue = "name";

		switch (keyword) {

		case ParserConstants.KEYWORD_AT:
			returnValue = "locationtime";
			break;

		case ParserConstants.KEYWORD_BY:
		case ParserConstants.KEYWORD_ON:
		case ParserConstants.KEYWORD_FROM:
			returnValue = "datetimestart";
			break;

		case ParserConstants.KEYWORD_TO:
			returnValue = "datetimeend";
			break;

		case ParserConstants.KEYWORD_REMOVE:
			returnValue = "remove";
			break;
			
		default: 
			returnValue = "name";
			break;
		}

		return returnValue;
	}
	
	protected static int getMonthFromString(String lowercaseWord) {
		
		int returnValue = Constants.INVALID_VALUE_CONSTANT;
		
		// Do check only if it is a valid month
		if (MONTH_SET_UNMODIFIABLE.contains(lowercaseWord)) {
			
			for (int i = 0; i < MONTHS_ALL.length; i++) {
				if (lowercaseWord.equals(MONTHS_ALL[i])) {
					
					// Case 1: Match MONTH_LONG => i from 0 to 11
					// Case 2: Match MONTH_SHORT => i from 12 to 23 
					// => (Modulo 12) from 0 to 11
					// Need to add 1 to make month value from 1 to 12
					returnValue = (i % MONTH_MAX) + 1;
					break;
				}
			}
		}
		
		return returnValue;
	}
	
	protected static int getDayFromString(String lowercaseWord) {
		
		int returnValue = Constants.INVALID_VALUE_CONSTANT;
		
		if (DAY_SET_UNMODIFIABLE.contains(lowercaseWord)) {
			
			for (int i = 0; i < DAYS_ALL.length; i++) {
				if (lowercaseWord.equals(DAYS_ALL[i])) {
					returnValue = (i % DAY_WEEK_MAX) + 1;
					break;
				}
			}
		}
		
		return returnValue;
	}
	
	protected static boolean isValidMonth(int monthValue) {
		return (monthValue >= MONTH_MIN) && (monthValue <= MONTH_MAX);
	}
	
	protected static boolean isValidDay(int dayValue) {
		return (dayValue >= DAY_MIN) && (dayValue <= DAY_MAX);
	}
	
	protected static boolean isValidHour(int hourValue) {
		return (hourValue >= HOUR_MIN) && (hourValue <= HOUR_MAX);
	}
	
	protected static boolean isValidMinute(int minuteValue) {
		return (minuteValue >= MINUTE_MIN) && (minuteValue <= MINUTE_MAX);
	}
}
```
###### \src\tasknote\parser\ParserDeleteTest.java
``` java
package tasknote.parser;

import static org.junit.Assert.*;
import org.junit.Test;

import java.util.ArrayList;

public class ParserDeleteTest {
	
	Parser testParser = new Parser();
	
	@Test
	public void testDeleteRange() {
		
		String userCommand = "delete 1 - 3";
		this.testParser.setInputString(userCommand);
		
		ArrayList<Integer> expectedResult = new ArrayList<>();
		expectedResult.add(0);
		expectedResult.add(1);
		expectedResult.add(2);
		
		ArrayList<Integer> actualResult = this.testParser.parseDelete(false);
		
		assertEquals(expectedResult, actualResult);
	}
}
```
###### \src\tasknote\parser\TimeMessage.java
``` java
package tasknote.parser;

public class TimeMessage {
	
	// These are the constants that are applicable for TimeMessage
	private static final int DEFAULT_EXTRA_HOURS = 0;
	
	// Private fields
	private int hour;
	private int minute;
	private int extraHours;
	
	private String message;
	
	public TimeMessage() {
		this.setHour(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
		this.setMinute(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
		
		this.setExtraHours(DEFAULT_EXTRA_HOURS);
		
		this.setMessage(ParserConstants.MESSAGE_TIME_UNSURE);
	}

```
###### \src\tasknote\parser\TimeParser.java
``` java
package tasknote.parser;

public class TimeParser {

	// Here are the constants that are specific to TimeParser
	private static final String UNINITIALIZED_STRING = null;

	// Private fields
	private String currentPhrase;

	public TimeParser() {
		this.setCurrentPhrase(UNINITIALIZED_STRING);
	}

	public boolean isNotReady() {
		return this.getCurrentPhrase().equals(UNINITIALIZED_STRING);
	}

```
###### \src\tasknote\parser\TimeParser.java
``` java
	public TimeMessage tryToParseTime() {

		if (this.isNotReady()) {
			throw new RuntimeException("Need to set up TimeParser first!");
		}

		TimeMessage returnMessage = new TimeMessage();
		int givenHour = ParserConstants.DEFAULT_INVALID_INT_DATETIME;
		int givenMinute = ParserConstants.DEFAULT_INVALID_INT_DATETIME;

		String currentPhrase = this.getCurrentPhrase();
		int extraHours = 0;

		// Check if pm or am exists at the end of the currentPhrase first
		if (currentPhrase.endsWith(ParserConstants.HOUR_MOD_PM)) {
			extraHours = 12;
		}

		if (currentPhrase.endsWith(ParserConstants.HOUR_MOD_AM)
				|| currentPhrase.endsWith(ParserConstants.HOUR_MOD_PM)) {
			currentPhrase = currentPhrase.substring(0,
					currentPhrase.length() - 2);
			returnMessage.setMessage(ParserConstants.MESSAGE_TIME_SURE);
		}

		// Try as colon separated or dash separated
		if (currentPhrase.contains(ParserConstants.TIME_SEPARATOR_COLON)
				|| currentPhrase.contains(ParserConstants.TIME_SEPARATOR_DOT)) {

			String[] tempHourMinute;

			if (currentPhrase.contains(ParserConstants.TIME_SEPARATOR_COLON)) {
				tempHourMinute = currentPhrase
						.split(ParserConstants.TIME_SEPARATOR_COLON);
			} else {
				tempHourMinute = currentPhrase
						.split(ParserConstants.TIME_SEPARATOR_ESCAPED_DOT);
			}

			try {
				givenHour = Integer.parseInt(tempHourMinute[0]) + extraHours;
				givenMinute = Integer.parseInt(tempHourMinute[1]);

				returnMessage.setMessage(ParserConstants.MESSAGE_TIME_SURE);
			} catch (NumberFormatException e) {
				return returnMessage;
			}
		} else {
			
			if (currentPhrase.length() >= 3) {

				String hourString = currentPhrase.substring(0,
						currentPhrase.length() - 2);
				String minuteString = currentPhrase.substring(
						currentPhrase.length() - 2, currentPhrase.length());

				try {
					givenHour = Integer.parseInt(hourString) + extraHours;
					givenMinute = Integer.parseInt(minuteString);

					returnMessage.setMessage(ParserConstants.MESSAGE_TIME_SURE);
				} catch (NumberFormatException e) {
					return returnMessage;
				}
			}

			if (currentPhrase.length() < 3) {

				try {
					givenHour = Integer.parseInt(currentPhrase) + extraHours;
					givenMinute = 0;

				} catch (NumberFormatException e) {
					return returnMessage;

				}
			}

		}

		if (givenHour == 24) {
			givenHour = 12;
		} else if (givenHour == 12) {
			givenHour = 0;
		}

		if (!ParserConstants.isValidMinute(givenMinute)
				|| !ParserConstants.isValidHour(givenHour)) {
			returnMessage.setHour(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
			returnMessage
					.setMinute(ParserConstants.DEFAULT_INVALID_INT_DATETIME);
			returnMessage.setMessage(ParserConstants.MESSAGE_TIME_UNSURE);
		} else {
			returnMessage.setHour(givenHour);
			returnMessage.setMinute(givenMinute);
		}

		return returnMessage;

	}

}
```
###### \src\tasknote\parser\UserStringProcessor.java
``` java
package tasknote.parser;

import java.util.ArrayList;

public class UserStringProcessor {

	private String command;
	private ArrayList<String> parsedCommandWords;
	
	public UserStringProcessor(String command) {
		this.command = command;
		this.parsedCommandWords = new ArrayList<String>();
		
		rebuildWordsWithQuotes();
	}
	
	private void rebuildWordsWithQuotes() {
		
		boolean findingEndQuote = false;
		int stringLength = command.length();
		
		StringBuilder phraseBuilder = new StringBuilder();
		
		for (int i = 0; i < stringLength; i++) {
			
			char currentChar = this.command.charAt(i);
			if (findingEndQuote) {
				
				if (currentChar == '"') {
					if (!phraseBuilder.toString().trim().equals("")) {
						this.parsedCommandWords.add(phraseBuilder.toString());
						phraseBuilder.delete(0, phraseBuilder.length());
					}
					findingEndQuote = !findingEndQuote;
				} else {
					phraseBuilder.append(currentChar);
				}
			} else {
				
				if (currentChar == '"') {
					
					if (!phraseBuilder.toString().trim().equals("")) {
						this.parsedCommandWords.add(phraseBuilder.toString());
						phraseBuilder.delete(0, phraseBuilder.length());
					}
					findingEndQuote = !findingEndQuote;
				} else if (currentChar == ' ') {
					
					if (phraseBuilder.toString().trim().equals("")) {
						continue;
					} else {
						this.parsedCommandWords.add(phraseBuilder.toString());
						phraseBuilder.delete(0, phraseBuilder.length());
					}
				} else {
					phraseBuilder.append(currentChar);
				}
			}
		}
		
		if (!phraseBuilder.toString().trim().equals("")) {
			this.parsedCommandWords.add(phraseBuilder.toString());
		}
	}
	
	public ArrayList<String> getProcessedInput() {
		return this.parsedCommandWords;
	}
}
```
###### \src\tasknote\parser\UserStringProcessorTest.java
``` java
package tasknote.parser;

import static org.junit.Assert.*;
import org.junit.Test;
import java.util.ArrayList;

public class UserStringProcessorTest {

	@Test
	public void basicWordTest() {

		String userCommand = "add task1 by 5pm";
		UserStringProcessor processedInput = new UserStringProcessor(userCommand);

		ArrayList<String> expected = new ArrayList<>();
		expected.add("add");
		expected.add("task1");
		expected.add("by");
		expected.add("5pm");

		ArrayList<String> actual = processedInput.getProcessedInput();

		assertEquals(expected, actual);
	}

	@Test
	public void testWithExtraSpaces() {

		String userCommand = "  delete   task   object by 9       ";
		UserStringProcessor processedInput = new UserStringProcessor(userCommand);

		ArrayList<String> expected = new ArrayList<>();
		expected.add("delete");
		expected.add("task");
		expected.add("object");
		expected.add("by");
		expected.add("9");

		ArrayList<String> actual = processedInput.getProcessedInput();

		assertEquals(expected, actual);
	}
	
	@Test
	public void basicTestWithQuotes() {

		String userCommand = "add \"another task for tomorrow\" by 5pm";
		UserStringProcessor processedInput = new UserStringProcessor(userCommand);

		ArrayList<String> expected = new ArrayList<>();
		expected.add("add");
		expected.add("another task for tomorrow");
		expected.add("by");
		expected.add("5pm");

		ArrayList<String> actual = processedInput.getProcessedInput();

		assertEquals(expected, actual);
	}
	
	@Test
	public void testQuotesWithSpaces() {

		String userCommand = "add \"  another    task     again for tomorrow   \" by 5pm";
		UserStringProcessor processedInput = new UserStringProcessor(userCommand);

		ArrayList<String> expected = new ArrayList<>();
		expected.add("add");
		expected.add("  another    task     again for tomorrow   ");
		expected.add("by");
		expected.add("5pm");

		ArrayList<String> actual = processedInput.getProcessedInput();

		assertEquals(expected, actual);
	}
	
	@Test
	public void basicMultiQuoteTest() {

		String userCommand = "add \"here at here\" at \"there by there\"";
		UserStringProcessor processedInput = new UserStringProcessor(userCommand);

		ArrayList<String> expected = new ArrayList<>();
		expected.add("add");
		expected.add("here at here");
		expected.add("at");
		expected.add("there by there");

		ArrayList<String> actual = processedInput.getProcessedInput();

		assertEquals(expected, actual);
	}
	
	@Test
	public void multiQuoteWithSpacesTest() {

		String userCommand = "add   \" here   at here \" at \"   there  by there    \"  ";
		UserStringProcessor processedInput = new UserStringProcessor(userCommand);

		ArrayList<String> expected = new ArrayList<>();
		expected.add("add");
		expected.add(" here   at here ");
		expected.add("at");
		expected.add("   there  by there    ");

		ArrayList<String> actual = processedInput.getProcessedInput();

		assertEquals(expected, actual);
	}
}
```
###### \src\tasknote\shared\COMMAND_TYPE.java
``` java
package tasknote.shared;

public enum COMMAND_TYPE {
	ADD, DELETE, SEARCH, UPDATE, INVALID, UNDO, REDO, DONE, UNDONE, CHANGE_FILE_PATH, SHOW, HELP, CHANGE_CATEGORY, EXIT;
}
```
###### \src\tasknote\shared\Constants.java
``` java
	/*
	 * These are the String constants used in the program while executing
	 * specific user operations
	 */
	public static final String STRING_CONSTANT_EMPTY = "";
	public static final String STRING_CONSTANT_SPACE = " ";
	public static final String STRING_CONSTANT_NEWLINE = "\n";
	public static final String STRING_CONSTANT_ESCAPED_DOUBLE_QUOTES = "\"";
	
```
###### \src\tasknote\shared\TaskObject.java
``` java
package tasknote.shared;

import javafx.beans.property.SimpleStringProperty;

public class TaskObject implements Comparable<TaskObject> {
    public static final String TASK_TYPE_FLOATING = "floating";
    public static final String TASK_TYPE_DEADLINE = "deadline";
    public static final String TASK_TYPE_EVENT = "event";
    public static final boolean ISCOMPLETE = true;
    
    public String[] monthInString = {"",
    								 "January", 
    								 "February", 
    								 "March", 
    								 "April",
    								 "May", 
    								 "June", 
    								 "July", 
    								 "August", 
    								 "September", 
    								 "October", 
    								 "November", 
    								 "December"
    								 };
    
    public final int DEFAULT_DATETIME_VALUE = -1;
    public final int DEFAULT_DURATION_VALUE = 0;
    public final String DEFAULT_LOCATION_VALUE = "";
    
    private final String FORMAT_DATE = "%d %s %d";
    private final String FORMAT_TIME_MORNING = "%1$02d:%2$02dAM";
    private final String FORMAT_TIME_EVENING = "%1$02d:%2$02dPM";
    
    public static enum TaskStatus {
        TASK_DEFAULT, TASK_OUTSTANDING, TASK_COMPLETED, TASK_OVERDUE, TASK_INVALID_STORAGE
    };
    
	private String taskName;
	private int taskID;
	
	private int dateDay;
	private int dateMonth;
	private int dateYear;
	private int dateHour;
	private int dateMinute;
	
	private int endDateDay;
	private int endDateMonth;
	private int endDateYear;
	private int endDateHour;
	private int endDateMinute;
	
	private int duration;
	
	private String location;
	
	private SimpleStringProperty taskStatus = new SimpleStringProperty();
	private String taskType;
	
	private boolean isMarkedDone;
	
	/**
	 * Constructor for Storage
```
###### \src\tasknote\shared\TaskObject.java
``` java
	 * @param taskName
	 */
	public TaskObject(String taskName) {
		
		setTaskName(taskName);
		
		setDateDay(DEFAULT_DATETIME_VALUE);
		setDateMonth(DEFAULT_DATETIME_VALUE);
		setDateYear(DEFAULT_DATETIME_VALUE);
		setDateHour(DEFAULT_DATETIME_VALUE);
		setDateMinute(DEFAULT_DATETIME_VALUE);
		
		setDuration(DEFAULT_DURATION_VALUE);
		
		setEndDateDay(DEFAULT_DATETIME_VALUE);
		setEndDateMonth(DEFAULT_DATETIME_VALUE);
		setEndDateYear(DEFAULT_DATETIME_VALUE);
		setEndDateHour(DEFAULT_DATETIME_VALUE);
		setEndDateMinute(DEFAULT_DATETIME_VALUE);
		
		setLocation(DEFAULT_LOCATION_VALUE);
		
		setTaskStatus(TaskStatus.TASK_OUTSTANDING);
		setTaskType(TASK_TYPE_FLOATING);
		
		setIsMarkedDone(false);
	}

```
###### \src\tasknote\shared\TaskObject.java
``` java
	@Override
	public int compareTo(TaskObject otherTaskObject) {
		
		if (this.getDateYear() != otherTaskObject.getDateYear()) {
			return Integer.compare(this.getDateYear(), otherTaskObject.getDateYear());
		}
		
		if (this.getDateMonth() != otherTaskObject.getDateMonth()) {
			return Integer.compare(this.getDateMonth(), otherTaskObject.getDateMonth());
		}
		
		if (this.getDateDay() != otherTaskObject.getDateDay()) {
			return Integer.compare(this.getDateDay(), otherTaskObject.getDateDay());
		}
		
		if (this.getDateHour() != otherTaskObject.getDateHour()) {
			return Integer.compare(this.getDateHour(), otherTaskObject.getDateHour());
		}
		
		if (this.getDateMinute() != otherTaskObject.getDateMinute()) {
			return Integer.compare(this.getDateMinute(), otherTaskObject.getDateMinute());
		}
		
		if (this.getDuration() != otherTaskObject.getDuration()) {
			return Integer.compare(this.getDuration(), otherTaskObject.getDuration());
		}
		
		return this.getTaskName().compareTo(otherTaskObject.getTaskName());
	}
	
	public boolean equals(Object comparingObject) {
		if (!(comparingObject instanceof TaskObject)) {
			return false;
		}
		
		TaskObject comparingTaskObject = (TaskObject) comparingObject;
		
		if (isTaskObjectNameDifferent(comparingTaskObject)) {
			return false;
		}
		
		if (comparingTaskObject.getDateHour() != this.getDateHour()) {
			return false;
		}
		
		if (comparingTaskObject.getDateMinute() != this.getDateMinute()) {
			return false;
		}
		
		if (comparingTaskObject.getDateDay() != this.getDateDay()) {
			return false;
		}
		
		if (comparingTaskObject.getDateMonth() != this.getDateMonth()) {
			return false;
		}
		
		if (comparingTaskObject.getDateYear() != this.getDateYear()) {
			return false;
		}
		
		if (comparingTaskObject.getEndDateDay() != this.getEndDateDay()) {
			return false;
		}
		
		if (comparingTaskObject.getEndDateMonth() != this.getEndDateMonth()) {
			return false;
		}
		
		if (comparingTaskObject.getEndDateYear() != this.getEndDateYear()) {
			return false;
		}
		
		if (comparingTaskObject.getEndDateHour() != this.getEndDateHour()) {
			return false;
		}
		
		if (comparingTaskObject.getEndDateMinute() != this.getEndDateMinute()) {
			return false;
		}
		
		if (comparingTaskObject.getDuration() != this.getDuration()) {
			return false;
		}
		
		if (isTaskObjectLocationDifferent(comparingTaskObject)) {
			return false;
		}
		
		if (comparingTaskObject.getTaskStatus() != this.getTaskStatus()) {
			return false;
		}
		
		if (comparingTaskObject.getIsMarkedDone() != this.getIsMarkedDone()) {
			return false;
		}
		
		return true;
	}

	public void deepCopy(TaskObject sourceTaskObject) {
		
		this.setTaskName(sourceTaskObject.getTaskName());
		this.setTaskID(sourceTaskObject.getTaskID());
		this.setDateDay(sourceTaskObject.getDateDay());
		this.setDateMonth(sourceTaskObject.getDateMonth());
		this.setDateYear(sourceTaskObject.getDateYear());
		this.setDateHour(sourceTaskObject.getDateHour());
		this.setDateMinute(sourceTaskObject.getDateMinute());
		this.setDuration(sourceTaskObject.getDuration());
		this.setIsMarkedDone(sourceTaskObject.getIsMarkedDone());
		this.setLocation(sourceTaskObject.getLocation());
		this.setTaskStatus(sourceTaskObject.getTaskStatus());
		this.setTaskType(sourceTaskObject.getTaskType());
		this.setEndDateDay(sourceTaskObject.getEndDateDay());
		this.setEndDateMonth(sourceTaskObject.getEndDateMonth());
		this.setEndDateYear(sourceTaskObject.getEndDateYear());
		this.setEndDateHour(sourceTaskObject.getEndDateHour());
		this.setEndDateMinute(sourceTaskObject.getEndDateMinute());
	}

	

    /**
```
