# A0126172M
###### \src\tasknote\shared\AddDuplicateAliasException.java
``` java
package tasknote.shared;

/**
 * AddDuplicateAliasException is used to handle errors in adding duplicated
 * alias
 */
public class AddDuplicateAliasException extends Exception {

	private static final long serialVersionUID = 1L;

	public AddDuplicateAliasException() {
	}

	public AddDuplicateAliasException(String message) {
		super(message);
	}
}
```
###### \src\tasknote\shared\Constants.java
``` java
	/*
	 * These are strings that are used for taskStatus in TaskObject
	 */
	public static final String STRING_TASKSTATUS_DEFAULT = "TASK_DEFAULT";
	public static final String STRING_TASKSTATUS_OUTSTANDING = "TASK_OUTSTANDING";
	public static final String STRING_TASKSTATUS_OVERDUE = "TASK_OVERDUE";
	public static final String STRING_TASKSTATUS_COMPLETED = "TASK_COMPLETED";
	public static final String STRING_TASKSTATUS_INVALID_STORAGE = "TASK_INVALID_STORAGE";
	
	/*
	 * These are magic Strings that will be used for toString method
	 */
	private static final String STRING_TOSTRING_TASK_NAME = "TaskName = $1%s";
	private static final String STRING_TOSTRING_TASK_DATE = "\nDate = $1%s/$2%s/$3%s";
	private static final String STRING_TOSTRING_END_DATE = "\nEndDate = $1%s/$2%s/$3%s";
	private static final String STRING_TOSTRING_TIME = "\nTime = $1%s $2%s";
	private static final String STRING_TOSTRING_DURATION = "\nDuration = $1%s";
	private static final String STRING_TOSTRING_LOCATION = "\nLocation = $1%s";
	private static final String STRING_TOSTRING_NOTIFY_TIME = "\nNotifyTime = $1%s";
	private static final String STRING_TOSTRING_IS_NOTIFIED = "\nIsNotified = $1%s";
	private static final String STRING_TOSTRING_TASK_STATUS = "\nTaskStatus = $1%s";
	private static final String STRING_TOSTRING_TASK_TYPE = "\nTaskType = $1%s";
	private static final String STRING_TOSTRING_IS_MARKED_DONE = "\nisMarkedDone = $1%s";
	
	public static String produceTaskName(String taskName) {
		return String.format(STRING_TOSTRING_TASK_NAME, taskName);
	}

	public static String produceDate(int dateDay, int dateMonth, int dateYear) {
		return String.format(STRING_TOSTRING_TASK_DATE, dateDay, dateMonth, dateYear);
	}

	public static String produceEndDate(int endDateDay, int endDateMonth, int endDateYear) {
		return String.format(STRING_TOSTRING_END_DATE, endDateDay, endDateMonth, endDateYear);
	}

	public static String produceTime(int dateHour, int dateMinute) {
		return String.format(STRING_TOSTRING_TIME, dateHour, dateMinute);
	}

	public static String produceDuration(int duration) {
		return String.format(STRING_TOSTRING_DURATION, duration);
	}

	public static String produceLocation(String location) {
		return String.format(STRING_TOSTRING_LOCATION, location);
	}

	public static String produceNotifyTime(int notifyTime) {
		return String.format(STRING_TOSTRING_NOTIFY_TIME, notifyTime);
	}

	public static String produceIsNotified(boolean isNotified) {
		return String.format(STRING_TOSTRING_IS_NOTIFIED, isNotified);
	}

	public static String produceTaskStatus(SimpleStringProperty taskStatus) {
		return String.format(STRING_TOSTRING_TASK_STATUS, taskStatus);
	}
	
	public static String produceTaskType(String taskType) {
		return String.format(STRING_TOSTRING_TASK_TYPE, taskType);
	}

	public static String produceIsMarkedDone(boolean isMarkedDone) {
		return String.format(STRING_TOSTRING_IS_MARKED_DONE, isMarkedDone);
	}

}
```
###### \src\tasknote\shared\TaskListIOException.java
``` java
package tasknote.shared;

/**
 * TaskListIOException is used to handle errors in writing or reading the list
 * to/from file.
 */
public class TaskListIOException extends Exception {

	private static final long serialVersionUID = 1L;

	public TaskListIOException() {
	}

	public TaskListIOException(String message) {
		super(message);
	}
}
```
###### \src\tasknote\shared\TaskObject.java
``` java
	 */
	public TaskObject() {
		setTaskName(Constants.STRING_CONSTANT_EMPTY);
		
		setDateDay(DEFAULT_DATETIME_VALUE);
		setDateMonth(DEFAULT_DATETIME_VALUE);
		setDateYear(DEFAULT_DATETIME_VALUE);
		setDateHour(DEFAULT_DATETIME_VALUE);
		setDateMinute(DEFAULT_DATETIME_VALUE);
		
		setEndDateDay(DEFAULT_DATETIME_VALUE);
		setEndDateMonth(DEFAULT_DATETIME_VALUE);
		setEndDateYear(DEFAULT_DATETIME_VALUE);
		setEndDateHour(DEFAULT_DATETIME_VALUE);
		setEndDateMinute(DEFAULT_DATETIME_VALUE);
		
		setDuration(DEFAULT_DURATION_VALUE);
		
		setLocation(DEFAULT_LOCATION_VALUE);
		
		setTaskStatus(TaskStatus.TASK_OUTSTANDING);
		setTaskType(TASK_TYPE_FLOATING);
		
		setIsMarkedDone(false);
	}
	
	/**
	 * Constructor with taskName added
```
###### \src\tasknote\shared\TaskObject.java
``` java
     * @return true if taskObject is a floating task
     */
    public boolean isFloatingTask() {
        return this.taskType.equals(TASK_TYPE_FLOATING);
    }
    
	/**
	 * setTaskStatus(taskStatus) is for storage to set the taskStatus when read from the file
	 * @param String of taskStatus to set the current TaskStatus
	 */
	public void setTaskStatus(String taskStatus) {
		if (isDefaultTask(taskStatus)) {
		    setTaskStatus(TaskStatus.TASK_DEFAULT);
			return;
		} else if (isOutstandingTask(taskStatus)) {
		    setTaskStatus(TaskStatus.TASK_OUTSTANDING);
		    setIsMarkedDone(!ISCOMPLETE);
			return;
		} else if(isOverdueTask(taskStatus)) {
		    setTaskStatus(TaskStatus.TASK_OVERDUE);
		    setIsMarkedDone(!ISCOMPLETE);
			return;
		} else if(isCompletedTask(taskStatus)) {
		    setTaskStatus(TaskStatus.TASK_COMPLETED);
		    setIsMarkedDone(ISCOMPLETE);
			return;
		} else {
			setTaskStatus(TaskStatus.TASK_INVALID_STORAGE);
		}
	}

	private boolean isCompletedTask(String taskStatus) {
		return taskStatus.equalsIgnoreCase(Constants.STRING_TASKSTATUS_COMPLETED);
	}

	private boolean isOverdueTask(String taskStatus) {
		return taskStatus.equalsIgnoreCase(Constants.STRING_TASKSTATUS_OVERDUE);
	}

	private boolean isOutstandingTask(String taskStatus) {
		return taskStatus.equalsIgnoreCase(Constants.STRING_TASKSTATUS_OUTSTANDING);
	}

	private boolean isDefaultTask(String taskStatus) {
		return taskStatus.equalsIgnoreCase(Constants.STRING_TASKSTATUS_DEFAULT);
	}

    /**
     * isCompleted() checks if the taskStatus is completed
     * @return true if taskObject is completed
     */
    public boolean isCompleted() {
        return getTaskStatus() == TaskStatus.TASK_COMPLETED;
    }
    
	private boolean isTaskObjectLocationDifferent(TaskObject comparingTaskObject) {
		return bothLocationsAreInvalid(comparingTaskObject) ? false : bothLocationsAreDifferent(comparingTaskObject);
	}

	private boolean bothLocationsAreInvalid(TaskObject comparingTaskObject) {
		return isNull(comparingTaskObject.getLocation()) && isNull(this.getLocation());
	}
	
	private boolean bothLocationsAreDifferent(TaskObject comparingTaskObject) {
		return !comparingTaskObject.getLocation().equals(this.getLocation());
	}

	private boolean isTaskObjectNameDifferent(TaskObject comparingTaskObject) {
		return bothTaskNamesAreInvalid(comparingTaskObject) ? false : bothTaskNamesAreDifferent(comparingTaskObject);
	}

	private boolean bothTaskNamesAreInvalid(TaskObject comparingTaskObject) {
		return isNull(comparingTaskObject.getTaskName()) && isNull(this.getTaskName());
	}
	
	private boolean bothTaskNamesAreDifferent(TaskObject comparingTaskObject) {
		return !comparingTaskObject.getTaskName().equals(this.getTaskName());
	}
	
	private boolean isNull(String string) {
		return string == null;
	}
	
	/**
	 * @return produces string for printing for debugging
	 */
	public String toString() {
		return Constants.produceTaskName(taskName)
				+ Constants.produceDate(dateDay,dateMonth,dateYear)
				+ Constants.produceEndDate(endDateDay,endDateMonth,endDateYear)
				+ Constants.produceTime(dateHour,dateMinute)
				+ Constants.produceDuration(duration)
				+ Constants.produceLocation(location)
				+ Constants.produceTaskStatus(taskStatus)
				+ Constants.produceTaskType(taskType)
				+ Constants.produceIsMarkedDone(isMarkedDone);
	}
}
```
###### \src\tasknote\storage\FileManipulation.java
``` java
package tasknote.storage;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import tasknote.shared.TaskListIOException;
import tasknote.shared.TaskObject;

/**
 * FileManipulation class focuses on reading and writing of the file
 */
public class FileManipulation {

	private StorageConstants constants;
	private StorageConversion storageManipulator;

	private static File textFile;
	private static File pathFile;
	private static File aliasFile;

	private String textFileName;

	private static final Logger fileLog = Logger.getLogger(FileManipulation.class.getName());

	/**
	 * Constructor to initialize file and classes
	 */
	public FileManipulation() {
		initializeFamilyClasses();
		initializeFiles();
		createFilesIfNotExist();
	}

	private void initializeFamilyClasses() {
		constants = new StorageConstants();
		storageManipulator = new StorageConversion();
	}

	private void initializeFiles() {
		initializePathFile();
		initializeAliasFile();
		String fileName = extractFileName();
		initializeTextFile(fileName);
		storeNewTextFilePath();
	}

	private void initializePathFile() {
		pathFile = new File(getDefaultPathFileName());
	}

	private String getDefaultPathFileName() {
		return constants.getPathFileName();
	}

	private void initializeAliasFile() {
		aliasFile = new File(getDefaultAliasFileName());
	}

	private String getDefaultAliasFileName() {
		return constants.getAliasFileName();
	}

	private String extractFileName() {
		String fileName = extractCanonicalFileName();
		fileName = handleEmptyFileNameExtracted(fileName);
		return fileName;
	}

	private String extractCanonicalFileName() {
		if (isFileInvalid(pathFile)) {
			return constants.getFileName();
		}
		return readFullPathFromPathFile();
	}

	private void createFilesIfNotExist() {
		createPathFileIfNotExist();
		createAliasFileIfNotExist();
		createTextFileIfNotExist();
	}

	private void createPathFileIfNotExist() {
		if (isFileInvalid(pathFile)) {
			createNewFile(pathFile);
		}
	}

	private void createAliasFileIfNotExist() {
		if (isFileInvalid(aliasFile)) {
			createNewFile(aliasFile);
		}
	}

	private void createTextFileIfNotExist() {
		if (isFileInvalid(textFile)) {
			createNewFile(textFile);
			storeNewTextFilePath();
		}
	}

	private boolean isFileInvalid(File file) {
		return !file.exists();
	}

	private void createNewFile(File file) {
		try {
			file.createNewFile();
		} catch (IOException e) {
			fileLog.log(Level.WARNING, constants.getFailedToCreateNewFile(file.toString()));
		}
	}

	private void storeNewTextFilePath() {
		try {
			BufferedOutputStream fileWriter = new BufferedOutputStream(initializePathFileOutputStream());
			writeCanonicalTextPathToPathFile(fileWriter);
			fileWriter.close();
		} catch (IOException ioe) {
			fileLog.log(Level.WARNING, constants.getFailedToStorePathFile());
		}
	}

	private void writeCanonicalTextPathToPathFile(BufferedOutputStream fileWriter) throws IOException {
		byte[] textFileCanonicalPathName = getByteArrayOfFullPath();
		fileWriter.write(textFileCanonicalPathName, 0, textFileCanonicalPathName.length);
	}

	private byte[] getByteArrayOfFullPath() throws IOException {
		String fullPath = textFile.getCanonicalPath();
		return fullPath.getBytes();
	}

	private OutputStream initializePathFileOutputStream() throws FileNotFoundException {
		return new FileOutputStream(pathFile);
	}

	/**
	 * read full path of the current text file from pathFile able to handle one
	 * round of empty path file read
	 * 
	 * @return String of current full path stored
	 */
	public String readFullPathFromPathFile() {
		try {
			return readPathFromPathFile();
		} catch (IOException ioe) {
			return handleEmptyPathFile();
		}
	}

	private String handleEmptyPathFile() {
		try {
			initializeFiles();
			return readPathFromPathFile();
		} catch (IOException ioe) {
			fileLog.log(Level.WARNING, constants.getFailedToReadPathFile());
			return null;
		}
	}

	private String readPathFromPathFile() throws FileNotFoundException, IOException {
		BufferedReader fileReader = initializeFileReader();
		String pathFile = fileReader.readLine();
		fileReader.close();
		return pathFile;
	}

	private BufferedReader initializeFileReader() throws FileNotFoundException {
		return new BufferedReader(initializePathFileReader());
	}

	private FileReader initializePathFileReader() throws FileNotFoundException {
		return new FileReader(pathFile);
	}

	private String handleEmptyFileNameExtracted(String fileName) {
		if (isNullString(fileName)) {
			return constants.getFileName();
		}
		return fileName;
	}

	private boolean isNullString(String content) {
		return content == null;
	}

	private void initializeTextFile(String fileName) {
		textFile = new File(fileName);
		if (isFileNameEntered(fileName)) {
			textFileName = extractTextFileName(fileName);
		}
	}

	private boolean isFileNameEntered(String fileName) {
		return fileName.endsWith(constants.getTextFileEnding());
	}

	/**
	 * extract textFile name from full PATH string
	 * 
	 * @param fullPath
	 * @return String textFile name
	 */
	public String extractTextFileName(String fullPath) {
		String[] pathListNameForWindows = fullPath.split(constants.getPathDivision());
		String[] pathListNameForMac = fullPath.split(constants.getSlash());
		if (isFileNameForWindows(pathListNameForWindows, pathListNameForMac)) {
			return pathListNameForWindows[getLastIndexOfArray(pathListNameForWindows)];
		}
		return pathListNameForMac[getLastIndexOfArray(pathListNameForMac)];
	}

	private boolean isFileNameForWindows(String[] pathListNameForWindows, String[] pathListNameForMac) {
		return supposedTextFileLength(pathListNameForWindows) < supposedTextFileLength(pathListNameForMac);
	}

	private int supposedTextFileLength(String[] pathListName) {
		return pathListName[getLastIndexOfArray(pathListName)].length();
	}

	private int getLastIndexOfArray(String[] pathListName) {
		return constants.getLastIndexOfArray(pathListName.length);
	}

	/**
	 * get textFile name
	 * 
	 * @return String textFile name
	 */
	public String getTextFileName() {
		return textFileName;
	}

	/**
	 * This method reads from file and converts it into ArrayList/
	 * <TaskObject/> to return to logic
	 *
	 * @param
	 * @return ArrayList<TaskObject>
	 * @throws IOException
	 *             (implies reader got error)
	 * @throws TaskListIOException
	 *             (implies file contents got error)
	 *
	 */
	public ArrayList<TaskObject> getTasks() throws IOException, TaskListIOException {
		ArrayList<TaskObject> returnTaskList = new ArrayList<TaskObject>();
		BufferedReader fileReader = new BufferedReader(new FileReader(textFile));
		loopToGetFullTaskList(returnTaskList, fileReader);
		fileReader.close();
		return returnTaskList;
	}

	private void loopToGetFullTaskList(ArrayList<TaskObject> returnTaskList, BufferedReader fileReader)
			throws IOException, TaskListIOException, NullPointerException {
		try {
			while (true) {
				addOneTaskObjectRead(returnTaskList, fileReader);
			}
		} catch (ClassNotFoundException cnfe) {
			fileLog.log(Level.WARNING, constants.getStorageManipulatorNotInitialized());
		} catch (IOException ioe) {
			fileLog.log(Level.WARNING, constants.getFailedToReadFromTextFile());
			throw new TaskListIOException();
		} catch (NullPointerException npe) {
			// read success [NOT logged to avoid overcrowd console]
		}
	}

	private void addOneTaskObjectRead(ArrayList<TaskObject> returnTaskList, BufferedReader fileReader)
			throws IOException, ClassNotFoundException {
		String[] objectRead = new String[constants.getTotalTitles()];
		int linesRead = iterateOnceToStoreOneObject(fileReader, objectRead);
		returnTaskList.add(storageManipulator.convertStringToTaskObject(objectRead, linesRead));
	}

	private int iterateOnceToStoreOneObject(BufferedReader fileReader, String[] objectRead) throws IOException {
		int numberOfLinesRead = 0;
		String lineRead = attemptToReadLineOrEndRead(fileReader);
		while (isValidRead(numberOfLinesRead, lineRead)) {
			objectRead[numberOfLinesRead] = lineRead;
			++numberOfLinesRead;
			lineRead = attemptToReadLineOrEndRead(fileReader);
		}
		return numberOfLinesRead;
	}

	private boolean isValidRead(int numberOfLinesRead, String lineRead) {
		return !isEndOfTaskObjectRead(lineRead) && isWithinValidLinesRead(numberOfLinesRead);
	}

	private boolean isEndOfTaskObjectRead(String lineRead) {
		lineRead = lineRead.trim();
		return lineRead.equals(constants.getEmptyString());
	}

	private boolean isWithinValidLinesRead(int numberOfLinesRead) {
		return numberOfLinesRead < constants.getTotalTitles();
	}

	private String attemptToReadLineOrEndRead(BufferedReader fileReader) throws IOException {
		String lineRead = fileReader.readLine();
		throwNullPointerExceptionIfNoMoreLinesToRead(lineRead);
		return lineRead;
	}

	private void throwNullPointerExceptionIfNoMoreLinesToRead(String lineRead) {
		if (isNullString(lineRead)) {
			fileLog.log(Level.FINE, "Successfully read from text file");
			throw new NullPointerException();
		}
	}

	/**
	 * This method get ArrayList/<TaskObject/> from logic and write into file
	 *
	 * @param
	 * @param overrideTasks
	 * @throws TaskListIOException
	 *             (implies something wrong with writing)
	 *
	 */
	public void writeTasks(ArrayList<TaskObject> overrideTasks) throws TaskListIOException {
		for (int index = 0; index < overrideTasks.size(); ++index) {
			String stringToWriteToFile = storageManipulator.convertTaskObjectToString(overrideTasks.get(index));
			writeToFile(stringToWriteToFile);
		}
	}

	private void writeToFile(String stringToFile) throws TaskListIOException {
		try {
			byte[] bufferMemory = stringToFile.getBytes();
			BufferedOutputStream fileWriter = new BufferedOutputStream(initializeContinuousTextFileOutputStream());
			writeOneObjectToFile(bufferMemory, fileWriter);
			fileWriter.close();
		} catch (IOException ioe) {
			throw new TaskListIOException();
		}
	}

	private FileOutputStream initializeContinuousTextFileOutputStream() throws FileNotFoundException {
		return new FileOutputStream(textFile, true);
	}

	private void writeOneObjectToFile(byte[] bufferMemory, BufferedOutputStream fileWriter) throws IOException {
		fileWriter.write(bufferMemory, 0, bufferMemory.length);
		fileWriter.flush();
	}

	public void writeAlias(HashMap<String, String> alias) throws IOException {
		BufferedOutputStream fileWriter = new BufferedOutputStream(initializeAliasFileOutputStream());
		Map<String, String> aliasMap = alias;
		iterateAliasMapToWriteToFile(alias, fileWriter, aliasMap);
		fileWriter.close();
	}

	private FileOutputStream initializeAliasFileOutputStream() throws FileNotFoundException {
		return new FileOutputStream(aliasFile);
	}

	private void iterateAliasMapToWriteToFile(HashMap<String, String> alias, BufferedOutputStream fileWriter,
			Map<String, String> aliasMap) throws IOException {
		for (String aliasCommand : aliasMap.keySet()) {
			writeAliasPairToAliasFile(alias, fileWriter, aliasCommand);
		}
	}

	private void writeAliasPairToAliasFile(HashMap<String, String> alias, BufferedOutputStream fileWriter,
			String aliasCommand) throws IOException {
		String aliasPair = generateAliasPair(alias, aliasCommand);
		byte[] bufferMemory = aliasPair.getBytes();
		writeOneObjectToFile(bufferMemory, fileWriter);
	}

	private String generateAliasPair(HashMap<String, String> alias, String aliasCommand) {
		String command = alias.get(aliasCommand);
		return constants.getAliasPair(aliasCommand, command);
	}

	public HashMap<String, String> readAliasFromAliasFile() throws FileNotFoundException {
		HashMap<String, String> alias = new HashMap<String, String>();
		BufferedReader read = new BufferedReader(initializeAliasFileReader());
		try {
			loopReadLineToFillAlias(alias, read);
		} catch (IOException ioe) {
			fileLog.log(Level.WARNING, constants.getFailedToReadFromAliasFile());
		} catch (NullPointerException npe) {
			// read success [NOT logged to avoid overcrowd console]
		}
		closeRead(read);
		return alias;
	}

	private FileReader initializeAliasFileReader() throws FileNotFoundException {
		return new FileReader(aliasFile);
	}

	private void loopReadLineToFillAlias(HashMap<String, String> alias, BufferedReader read) throws IOException {
		while (true) {
			String aliasLine = attemptToReadLineOrEndRead(read);
			String[] aliasPair = extractAliasPair(aliasLine);
			addAliasPairToAlias(alias, aliasPair);
		}
	}

	private String[] extractAliasPair(String aliasLine) {
		return aliasLine.split(constants.getSpace());
	}

	private void addAliasPairToAlias(HashMap<String, String> alias, String[] aliasPair) {
		if (aliasPair.length == constants.getPairCount()) {
			String aliasCommand = aliasPair[constants.getAliasCommandIndex()];
			String command = aliasPair[constants.getCommandIndex()];
			alias.put(aliasCommand, command);
		}
	}

	private void closeRead(BufferedReader read) {
		try {
			read.close();
		} catch (IOException ioe) {
			fileLog.log(Level.WARNING, constants.getFailedToCloseRead());
		}
	}

	/**
	 * This method attempts to change file name into a new one desired by the
	 * user and move the file to the new path
	 *
	 * @param String
	 *            desired new file name
	 * @return boolean true for success copy of file or false if the fileName is
	 *         not valid
	 * @throws IOException
	 *             when failed to move the file
	 */

	public boolean moveFile(String fileName) throws IOException {

		assert (isFileNameEntered(fileName));

		if (isFilePathValid(fileName)) {
			copyFileAndDeletePrevious(fileName);
			initializeTextFile(fileName);
			createTextFileIfNotExist();
			storeNewTextFilePath();
			return true;
		}
		return false;
	}

	private boolean isFilePathValid(String fileName) {
		File testFile = new File(fileName);
		try {
			testFile.getCanonicalPath();
			return true;
		} catch (IOException e) {
			return false;
		}
	}

	private void copyFileAndDeletePrevious(String newFileName) throws IOException {
		String previousTextFileName = readFullPathFromPathFile();
		if(isDifferentPathEntered(newFileName, previousTextFileName)){
			duplicateFileContents(newFileName);
			deleteOldFile();
		}
	}

	private void duplicateFileContents(String newFileName) throws FileNotFoundException, IOException {
		File newFile = new File(newFileName);
		BufferedInputStream inputStream = new BufferedInputStream(initializeTextFileInputStream());
		BufferedOutputStream outputStream = new BufferedOutputStream(initializeNewFileOutputStream(newFile));
		copyFileContents(inputStream, outputStream);
		closeStream(inputStream, outputStream);
	}

	private FileOutputStream initializeNewFileOutputStream(File newFile) throws FileNotFoundException {
		return new FileOutputStream(newFile);
	}

	private FileInputStream initializeTextFileInputStream() throws FileNotFoundException {
		return new FileInputStream(textFile);
	}

	private boolean isDifferentPathEntered(String newFileName, String previousTextFileName) {
		return !previousTextFileName.equals(newFileName);
	}

	private void copyFileContents(BufferedInputStream inputStream, BufferedOutputStream outputStream)
			throws IOException {

		byte[] bufferMemory = new byte[constants.getBufferSize()];
		int length = inputStream.read(bufferMemory);
		loopCopyFileContents(inputStream, outputStream, bufferMemory, length);

	}

	private void loopCopyFileContents(BufferedInputStream inputStream, BufferedOutputStream outputStream,
			byte[] bufferMemory, int length) throws IOException {

		while (isPositive(length)) {
			outputStream.write(bufferMemory, 0, length);
			length = inputStream.read(bufferMemory);
			outputStream.flush();
		}

	}

	private void deleteOldFile() throws IOException {
		Files.delete(textFile.toPath());
		textFile.delete();
	}

	private boolean isPositive(int length) {
		return length > constants.getMaximumNonPositiveValue();
	}

	private void closeStream(BufferedInputStream inStream, BufferedOutputStream outStream) throws IOException {
		inStream.close();
		outStream.close();
	}

	/**
	 * this method cleans the textFile
	 * 
	 * @throws IOException
	 */
	public void cleanTextFile() throws IOException {
		BufferedOutputStream fileWriter = new BufferedOutputStream(initializeTextFileOutputStream());
		fileWriter.close();
	}

	/**
	 * this method cleans the aliasFile
	 * 
	 * @throws IOException
	 */
	public void cleanAliasFile() throws IOException {
		BufferedOutputStream fileWriter = new BufferedOutputStream(initializeAliasFileOutputStream());
		fileWriter.close();
	}

	private FileOutputStream initializeTextFileOutputStream() throws FileNotFoundException {
		return new FileOutputStream(textFile);
	}
}
```
###### \src\tasknote\storage\PathHistory.java
``` java
package tasknote.storage;

import java.util.Stack;

/**
 * This class deals with the history of operations of PATH using Stacks
 *
 */
public class PathHistory {
	Stack<String> history;
	Stack<String> backup;
	String current;

	/**
	 * Constructor for PathHistory
	 */
	public PathHistory() {
		initializeStackHistory();
	}

	private void initializeStackHistory() {
		history = new Stack<String>();
		backup = new Stack<String>();
	}

	/**
	 * add newPath to history Stack
	 * 
	 * @param newPath
	 */
	public void addHistory(String newPath) {
		if (isCurrentPathExist()) {
			history.push(current);
		}
		current = newPath;
		backup.clear();
	}

	private boolean isCurrentPathExist() {
		return current != null;
	}

	/**
	 * undo operation for path
	 * 
	 * @return String previous path if undo is available, or null when there is
	 *         nothing to undo
	 */
	public String undo() {
		if (history.isEmpty()) {
			return null;
		}
		setUpUndo();
		return history.pop();
	}

	private void setUpUndo() {
		backup.push(current);
		current = history.peek();
	}

	/**
	 * redo operation for path
	 * 
	 * @return String previous path if undo is available, or null when there is
	 *         nothing to undo
	 */
	public String redo() {
		if (backup.isEmpty()) {
			return null;
		}
		setUpRedo();
		return backup.pop();
	}

	private void setUpRedo() {
		history.push(current);
		current = backup.peek();
	}
}
```
###### \src\tasknote\storage\PathManipulation.java
``` java
package tasknote.storage;

import java.io.File;
import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * This class aid the PATH manipulation operations and initiate pathHistory to
 * allow undo and redo of the PATH
 * 
 */

public class PathManipulation {
	private PathHistory pathHistory;

	/**
	 * Constructor of PathManipulation
	 */
	public PathManipulation() {
		initializeFamilyClasses();
	}

	private void initializeFamilyClasses() {
		pathHistory = new PathHistory();
	}

	/**
	 * This method checks if the path is valid
	 * 
	 * @param pathName
	 * @return true if it is a valid path
	 */
	public boolean isValidFilePath(String pathName) {
		File tempFile = new File(pathName);
		File directory = tempFile.getParentFile();
		return directory.exists();
	}

	/**
	 * This method checks if the path is an absolute path
	 * 
	 * @param pathName
	 * @return true if the path is an absolute path
	 * @throws InvalidPathException
	 *             implies the the user entered path is not in a path format
	 * @throws NullPointerException
	 *             implies the user entered path is a null string
	 */
	public boolean isAbsolutePath(String pathName) throws InvalidPathException, NullPointerException {
		Path path = Paths.get(pathName);
		return path.isAbsolute();
	}

	/**
	 * this method push the pathName into history
	 * 
	 * @param pathName
	 */
	public void pushHistory(String pathName) {
		if (isValidFilePath(pathName)) {
			pathHistory.addHistory(pathName);
		}
	}

	/**
	 * this method calls PathHistory to get the previous valid PATH
	 * 
	 * @return previous valid PATH change
	 */
	public String extractUndoPathString() {
		return pathHistory.undo();
	}

	/**
	 * this method calls PathHistroy to get the undo-ed previous valid PATH
	 * 
	 * @return undo-ed valid PATH change
	 */
	public String extractRedoPathString() {
		return pathHistory.redo();
	}

	/**
	 * this methods finds the absolute path of the new path with reference to
	 * the old path
	 * 
	 * @param newPath
	 * @param oldPath
	 * @return absolute path of the relative new path with reference to the old
	 *         path
	 */
	public String extractNewFullPath(String newPath, String oldPath) {
		assert(isAbsolutePath(oldPath));
		Path previousPath = Paths.get(oldPath);
		Path nextPath = Paths.get(newPath);
		Path newFullPath = extractFullLocalizedPath(previousPath, nextPath);
		return extractAbsoluteNewFullPath(previousPath, newFullPath);
	}

	private String extractAbsoluteNewFullPath(Path previousPath, Path newFullPath) {
		newFullPath = previousPath.resolve(newFullPath).normalize();
		return newFullPath.toString();
	}

	private Path extractFullLocalizedPath(Path previousPath, Path nextPath) {
		Path combinedPath = previousPath.resolve(nextPath);
		Path newFullPath = previousPath.relativize(combinedPath);
		return newFullPath.normalize();
	}
	
	public String normalizePath(String userPath){
		Path path = Paths.get(userPath);
		return normalizedPathString(path);
	}

	private String normalizedPathString(Path path) {
		path = path.normalize();
		return path.toString();
	}
}
```
###### \src\tasknote\storage\Storage.java
``` java
package tasknote.storage;

import tasknote.shared.TaskObject;
import tasknote.shared.AddDuplicateAliasException;
import tasknote.shared.TaskListIOException;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Storage {
	private FileManipulation fileManipulator;
	private PathManipulation pathManipulator;
	private AliasManipulation aliasManipulator;
	private StorageConstants constants;

	private static final Logger storageLog = Logger.getLogger(Storage.class.getName());

	/**
	 * constructor to construct FileManipulator to manipulate items from/to file
	 */
	public Storage() {
		initializeFamilyClasses();
		readAndSetAlias();
	}

	/**
	 * read all the tasks from file and return to logic
	 * 
	 * @return ArrayList/<TaskObject/>
	 * @throws IOException
	 *             // there is something wrong with reading from textfile
	 * @throws TaskListIOException
	 *             //there is something wrong with contents in the file
	 */
	public ArrayList<TaskObject> loadTasks() throws IOException, TaskListIOException {
		ArrayList<TaskObject> tasks = fileManipulator.getTasks();
		saveTasks(tasks);
		return tasks;
	}

	/**
	 * write all the tasks from logic into file
	 * 
	 * @param overrideTasks
	 * @throws TaskListIOException
	 *             // there is something wrong with the contents in the
	 *             overrideTasks
	 * @throws IOException
	 *             // there is something wrong with writing into textfile
	 */
	public void saveTasks(ArrayList<TaskObject> overrideTasks) throws TaskListIOException, IOException {
		cleanTextFile();
		fileManipulator.writeTasks(overrideTasks);
	}

	/**
	 * clear all the contents in the textfile
	 */
	public void cleanTextFile() throws IOException {
		fileManipulator.cleanTextFile();
	}

	/**
	 * use user entered PATH to change to a new location
	 * 
	 * @param newPathName
	 * @return true if path successfully changed
	 */
	public boolean changePath(String newPathName) throws IOException {
		String textFileName = getNormalizedFullPath(newPathName);
		if (handlePathChangeForMacAndWindows(textFileName)) {
			pathManipulator.pushHistory(textFileName);
			return true;
		}

		return logFailedPathEntered(textFileName);
	}

	private String getNormalizedFullPath(String newPathName) throws IOException {
		String textFileName = concatPathIfNeeded(newPathName, fileManipulator.getTextFileName());
		textFileName = pathManipulator.normalizePath(textFileName);
		return textFileName;
	}

	/**
	 * undo PATH operation
	 * 
	 * @return true if successfully undo PATH
	 * @throws IOException
	 */
	public boolean undoPath() throws InvalidPathException, IOException {
		try {
			String previousPath = pathManipulator.extractUndoPathString();
			if (pathManipulator.isValidFilePath(previousPath)) {
				return fileManipulator.moveFile(previousPath);
			}
			throw new InvalidPathException(previousPath, constants.getFailedValidPathUsed(previousPath));
		} catch (NullPointerException npe) {
			return logUndoFailed();
		}
	}

	/**
	 * re-do PATH operation
	 * 
	 * @return true if successfully re-do PATH
	 * @throws IOException
	 */
	public boolean redoPath() throws InvalidPathException, IOException {
		try {
			String nextPath = pathManipulator.extractRedoPathString();
			if (pathManipulator.isValidFilePath(nextPath)) {
				return fileManipulator.moveFile(nextPath);
			}
			throw new InvalidPathException(nextPath, constants.getFailedValidPathUsed(nextPath));
		} catch (NullPointerException npe) {
			return logRedoFailed();
		}
	}
	
	/*
```
###### \src\tasknote\storage\Storage.java
``` java

	/*
	 * private helper methods
	 */

	private void initializeFamilyClasses() {
		fileManipulator = new FileManipulation();
		pathManipulator = new PathManipulation();
		aliasManipulator = new AliasManipulation();
		constants = new StorageConstants();
	}

	private String concatPathIfNeeded(String pathName, String previousTextFileName)
			throws InvalidPathException, NullPointerException, IOException {
		String textFileName = getFileName(pathName, previousTextFileName);
		if (!pathManipulator.isAbsolutePath(pathName)) {
			return produceFullPathWithDirectoryCommand(pathName, previousTextFileName, textFileName);
		} else if (isPathSlashEnteredAtTheEnd(pathName)) {
			return addFileNameAndProduceFullPath(pathName, textFileName);
		} else if (isFileNameEntered(pathName)) {
			return produceFullPathWithNewFileName(pathName, textFileName);
		} else {
			return addSlashAndProduceFullPath(pathName, textFileName);
		}
	}

	private boolean isFileNameEntered(String pathName) {
		return pathName.endsWith(constants.getTextFileEnding());
	}

	private boolean isPathSlashEnteredAtTheEnd(String pathName) {
		return pathName.endsWith(constants.getSlash()) || pathName.endsWith(constants.getPathSlash());
	}

	private String produceFullPathWithDirectoryCommand(String newPath, String previousTextFileName, String textFileName)
			throws IOException {
		newPath = removeFileNameFromNewPath(newPath);
		String currentPath = extractCurrentPath(previousTextFileName);
		String newFullPath = pathManipulator.extractNewFullPath(newPath, currentPath);
		return addSlashAndProduceFullPath(newFullPath, textFileName);
	}

	private String removeFileNameFromNewPath(String newPath) {
		if (isFileNameEntered(newPath)) {
			String newFileName = fileManipulator.extractTextFileName(newPath);
			return extractCurrentPath(newPath, newFileName);
		}
		return newPath;
	}

	private String extractNewCurrentFullPath(String previousTextFileName, String fileName) {
		String currentPath = extractCurrentPath(previousTextFileName);
		String newCurrentFullPath = constants.addFileNameToPath(currentPath, fileName);
		return newCurrentFullPath;
	}

	private String extractCurrentPath(String previousTextFileName) {
		String currentFullPath = fileManipulator.readFullPathFromPathFile();
		return extractCurrentPath(currentFullPath, previousTextFileName);
	}

	private String extractCurrentPath(String currentFullPath, String previousTextFileName) {
		return currentFullPath.replace(previousTextFileName, constants.getEmptyString());
	}

	private String addFileNameAndProduceFullPath(String pathName, String previousTextFileName) throws IOException {
		return constants.addFileNameToPath(pathName, previousTextFileName);
	}

	private String produceFullPathWithNewFileName(String pathName, String previousTextFileName) {
		String fileName = getFileName(pathName, previousTextFileName);
		pathName = getPathIfOnlyFileNameEntered(pathName, previousTextFileName, fileName);
		return pathName;
	}

	private String getPathIfOnlyFileNameEntered(String pathName, String previousTextFileName, String fileName) {
		if (fileName.equals(pathName)) {
			String newFullPath = extractNewCurrentFullPath(previousTextFileName, fileName);
			return newFullPath;
		}
		return pathName;
	}

	private String getFileName(String pathName, String previousTextFileName) {
		if (isFileNameEntered(pathName)) {
			return extractCorrectTextFileName(pathName, previousTextFileName);
		}
		return previousTextFileName;
	}

	private String extractCorrectTextFileName(String pathName, String previousTextFileName) {
		String fileName = fileManipulator.extractTextFileName(pathName);
		if (isEmptyFileName(fileName)) {
			return previousTextFileName;
		}
		return fileName;
	}

	private boolean isEmptyFileName(String fileName) {
		return fileName == null;
	}

	private String addSlashAndProduceFullPath(String pathName, String previousTextFileName) throws IOException {
		pathName = addSlashToFullPath(pathName);
		return concatPathIfNeeded(pathName, previousTextFileName);
	}

	private String addSlashToFullPath(String pathName) {
		return pathName.concat(constants.getSlash());
	}

	private boolean handlePathChangeForMacAndWindows(String textFileName) throws IOException {
		
		if (isValidFilePath(textFileName)) {
			return fileManipulator.moveFile(textFileName);
		}
		
		return false;
	}

	private boolean isValidFilePath(String textFileName) {
		return pathManipulator.isValidFilePath(textFileName);
	}
	
	/*
```
###### \src\tasknote\storage\Storage.java
``` java
	// logging methods

	private boolean logFailedPathEntered(String textFileName) {
		storageLog.log(Level.WARNING, String.format(constants.getFailedPathChange(), textFileName));
		return false;
	}

	private boolean logUndoFailed() {
		storageLog.log(Level.FINE, constants.getFailedUndo());
		return false;
	}

	private boolean logRedoFailed() {
		storageLog.log(Level.FINE, constants.getFailedRedo());
		return false;
	}

	private void logSaveModifiedAliasFailed() {
		storageLog.log(Level.WARNING, constants.getFailedAliasSave());
	}
	
	private void logFailedToFindAliasFile() {
		storageLog.log(Level.WARNING, constants.getFailedToFindAliasFile());
	}
}
```
###### \src\tasknote\storage\StorageConstants.java
``` java
package tasknote.storage;

/**
 * StorageConstants stores magic strings and numbers required for Storage
 */
public class StorageConstants {

	/**
	 * Magic Strings for TaskObject
	 */
	private final String[] STRING_TASKOBJECT = {"taskName:", 
												"dateDay:", 
												"dateMonth:", 
												"dateYear:", 
												"dateHour:",
												"dateMinute:", 
												"duration:", 
												"location:", 
												"taskStatus:", 
												"taskType:", 
												"endDateDay:",
												"endDateMonth:", 
												"endDateYear:", 
												"endDateHour:",
												"endDateMinute:", 
												"" };

	/**
	 * Magic Strings
	 */
	private final String STRING_SPACE = " ";
	private final String STRING_NEWLINE = "\n";
	private final String STRING_EMPTY_STRING = "";
	private final String STRING_SLASH = "/";
	private final String STRING_PATH_SLASH = "\\";
	private final String STRING_PATH_DIVISION = "\\\\";
	private final String STRING_TEXT_FILE_END = ".txt";
	private final String STRING_ALIAS_PAIR = "%1$s %2$s\n";
	private final String STRING_NULL = "null";

	/**
	 * Logging messages
	 */
	private final String LOGGING_MESSAGE_FAILED_PATH_CHANGE = "Invalid PATH. PATH trace entered: %1$s.";
	private final String LOGGING_MESSAGE_FAILED_UNDO = "This is the maximum PATH history you can undo.";
	private final String LOGGING_MESSAGE_FAILED_REDO = "This is the maximum PATH history you can redo.";
	private final String LOGGING_MESSAGE_FAILED_ALIAS_SAVE = "Failed to save modified alias.";
	private final String LOGGING_MESSAGE_FAILED_TO_FIND_ALIAS_FILE = "Failed to find alias file.";
	private final String LOGGING_MESSAGE_FAILED_TO_READ_PATH_FROM_FILE = "Failed to read path from path file.";
	private final String LOGGING_MESSAGE_FAILED_TO_WRITE_PATH_TO_FILE = "Failed to write path into path file.";
	private final String LOGGING_MESSAGE_STORAGE_MANIPULATOR_NOT_INITIALIZED = "Storage Manipulator not intialized. Failed I/O.";
	private final String LOGGING_MESSAGE_FAILED_TO_READ_FROM_TEXT_FILE = "Failed to read from textfile.";
	private final String LOGGING_MESSAGE_INVALID_PATH = "Invalid PATH: %1$s.";
	private final String LOGGING_MESSAGE_FAILED_TO_CREATE_FILE = "Failed to create new file: %1$s.";
	private final String LOGGING_MESSAGE_FAILED_TO_CLOSE_ALIAS_READ = "Failed to close alias read.";
	private final String LOGGING_MESSAGE_FAILED_TO_READ_FROM_ALIAS_FILE = "Failed to read alias from alias file.";

	/**
	 * file/path name
	 */
	private final String DEFAULT_FILE_NAME = "taskContents.txt";
	private final String DEFAULT_PATH_FILE_NAME = "pathContents.txt";
	private final String DEFAULT_ALIAS_FILE_NAME = "aliasContents.txt";

	private final String FORMAT_PATH_NAME = "%1$s%2$s";

	/**
	 * Magic Integers
	 */
	private final int SUM_OF_TASKOBJECT_ITEMS = 16;
	private final int BUFFERSIZE = 32768;
	private final int INTEGER_MONTH_NORMALIZE_CONSTANT = 1;
	private final int INTEGER_ARRAY_NORMALIZE_INDEX = 1;
	private final int INTEGER_PAIR_COUNT = 2;
	private final int INTEGER_ALIAS_COMMAND_INDEX = 0;
	private final int INTEGER_COMMAND_INDEX = 1;
	private final int INTEGER_ZERO = 0;

	public StorageConstants() {
	}

	public String getTaskObjectTitle(int index) {
		return STRING_TASKOBJECT[index];
	}

	public String getSpace() {
		return STRING_SPACE;
	}

	public String getNewLine() {
		return STRING_NEWLINE;
	}

	public String getEmptyString() {
		return STRING_EMPTY_STRING;
	}

	public String getSlash() {
		return STRING_SLASH;
	}

	public String getPathSlash() {
		return STRING_PATH_SLASH;
	}

	public String getPathDivision() {
		return STRING_PATH_DIVISION;
	}

	public String getTextFileEnding() {
		return STRING_TEXT_FILE_END;
	}

	public String getAliasPair(String aliasCommand, String command) {
		return String.format(STRING_ALIAS_PAIR, aliasCommand, command);
	}

	public Object getNullString() {
		return STRING_NULL;
	}

	public String getFailedPathChange() {
		return LOGGING_MESSAGE_FAILED_PATH_CHANGE;
	}

	public String getFailedUndo() {
		return LOGGING_MESSAGE_FAILED_UNDO;
	}

	public String getFailedRedo() {
		return LOGGING_MESSAGE_FAILED_REDO;
	}

	public String getFailedAliasSave() {
		return LOGGING_MESSAGE_FAILED_ALIAS_SAVE;
	}

	public String getFailedToFindAliasFile() {
		return LOGGING_MESSAGE_FAILED_TO_FIND_ALIAS_FILE;
	}

	public String getFailedToReadPathFile() {
		return LOGGING_MESSAGE_FAILED_TO_READ_PATH_FROM_FILE;
	}

	public String getFailedToStorePathFile() {
		return LOGGING_MESSAGE_FAILED_TO_WRITE_PATH_TO_FILE;
	}

	public String getStorageManipulatorNotInitialized() {
		return LOGGING_MESSAGE_STORAGE_MANIPULATOR_NOT_INITIALIZED;
	}

	public String getFailedToReadFromTextFile() {
		return LOGGING_MESSAGE_FAILED_TO_READ_FROM_TEXT_FILE;
	}

	public String getFailedValidPathUsed(String path) {
		return String.format(LOGGING_MESSAGE_INVALID_PATH, path);
	}

	public String getFailedToCreateNewFile(String file) {
		return String.format(LOGGING_MESSAGE_FAILED_TO_CREATE_FILE, file);
	}

	public String getFailedToCloseRead() {
		return LOGGING_MESSAGE_FAILED_TO_CLOSE_ALIAS_READ;
	}

	public String getFailedToReadFromAliasFile() {
		return LOGGING_MESSAGE_FAILED_TO_READ_FROM_ALIAS_FILE;
	}

	public String getFileName() {
		return DEFAULT_FILE_NAME;
	}

	public String getPathFileName() {
		return DEFAULT_PATH_FILE_NAME;
	}

	public String getAliasFileName() {
		return DEFAULT_ALIAS_FILE_NAME;
	}

	public int getBufferSize() {
		return BUFFERSIZE;
	}

	public int getTotalTitles() {
		return SUM_OF_TASKOBJECT_ITEMS;
	}

	public String addFileNameToPath(String pathName, String fileName) {
		return String.format(FORMAT_PATH_NAME, pathName, fileName);
	}

	public int getNormalizedMonth(int month) {
		return month + INTEGER_MONTH_NORMALIZE_CONSTANT;
	}

	public int getLastIndexOfArray(int length) {
		return length - INTEGER_ARRAY_NORMALIZE_INDEX;
	}

	public int getPairCount() {
		return INTEGER_PAIR_COUNT;
	}

	public int getAliasCommandIndex() {
		return INTEGER_ALIAS_COMMAND_INDEX;
	}

	public int getCommandIndex() {
		return INTEGER_COMMAND_INDEX;
	}

	public int getMaximumNonPositiveValue() {
		return INTEGER_ZERO;
	}
}
```
###### \src\tasknote\storage\StorageConversion.java
``` java
package tasknote.storage;

import java.io.IOException;

import tasknote.shared.TaskObject;

/**
 * StorageConversion class is a helper class for FileManipulation. It takes the
 * Strings that are read from the textFile and convert it into a TaskObject OR
 * do it in the reverse manner
 */
public class StorageConversion {
	private StorageConstants constants;
	private StorageDeadlineUpdater deadlineUpdater;

	/**
	 * constants for TaskObject cases
	 */
	private final int CASE_TASK_NAME = 0;
	private final int CASE_TASK_DATE_DAY = 1;
	private final int CASE_TASK_DATE_MONTH = 2;
	private final int CASE_TASK_DATE_YEAR = 3;
	private final int CASE_TASK_DATE_HOUR = 4;
	private final int CASE_TASK_DATE_MINUTE = 5;
	private final int CASE_TASK_DURATION = 6;
	private final int CASE_TASK_LOCATION = 7;
	private final int CASE_TASK_STATUS = 8;
	private final int CASE_TASK_TYPE = 9;
	private final int CASE_TASK_END_DATE_DAY = 10;
	private final int CASE_TASK_END_DATE_MONTH = 11;
	private final int CASE_TASK_END_DATE_YEAR = 12;
	private final int CASE_TASK_END_DATE_HOUR = 13;
	private final int CASE_TASK_END_DATE_MINUTE = 14;
	private final int CASE_TASK_END = 15;

	/**
	 * special constants for StorageConversion
	 */
	private final int NO_CONTENT = 1;
	private final int CONTENT = 1;

	/**
	 * Constructor
	 */
	public StorageConversion() {
		constants = new StorageConstants();
		deadlineUpdater = new StorageDeadlineUpdater();
	}

	/**
	 * To convert a series of Strings into one taskObject
	 * 
	 * @param tasks
	 * @return ArrayList<TaskObject>
	 * @throws IOException
	 * @throws ClassNotFoundException
	 */
	public TaskObject convertStringToTaskObject(String[] taskLinesRead, int linesRead)
			throws ClassNotFoundException, IOException {
		TaskObject returnObject = new TaskObject();

		for (int index = 0; index < linesRead; ++index) {
			storeItemIntoTaskObject(taskLinesRead[index], returnObject);
		}

		deadlineUpdater.updateTaskStatus(returnObject);
		return returnObject;
	}

	private void storeItemIntoTaskObject(String taskLine, TaskObject returnObject)
			throws IOException, ClassNotFoundException {

		if (isNullString(taskLine)) {
			return;
		}

		int taskOperation = extractTaskOperation(taskLine);
		String[] content = extractContent(taskOperation, taskLine);

		if (isNoContentFound(content)) {
			return;
		}

		setTaskOperation(returnObject, taskOperation, content);
	}

	private void setTaskOperation(TaskObject returnObject, int taskOperation, String[] content) {
		switch (taskOperation) {
			case CASE_TASK_NAME:
				setTaskName(returnObject, content);
				break;
			case CASE_TASK_DATE_DAY:
				setTaskDay(returnObject, content);
				break;
			case CASE_TASK_DATE_MONTH:
				setTaskMonth(returnObject, content);
				break;
			case CASE_TASK_DATE_YEAR:
				setTaskYear(returnObject, content);
				break;
			case CASE_TASK_DATE_HOUR:
				setTaskHour(returnObject, content);
				break;
			case CASE_TASK_DATE_MINUTE:
				setTaskMinute(returnObject, content);
				break;
			case CASE_TASK_DURATION:
				setTaskDuration(returnObject, content);
				break;
			case CASE_TASK_LOCATION:
				setTaskLocation(returnObject, content);
				break;
			case CASE_TASK_STATUS:
				setTaskStatus(returnObject, content);
				break;
			case CASE_TASK_TYPE:
				setTaskType(returnObject, content);
				break;
			case CASE_TASK_END_DATE_DAY:
				setTaskEndDateDay(returnObject, content);
				break;
			case CASE_TASK_END_DATE_MONTH:
				setTaskEndDateMonth(returnObject, content);
				break;
			case CASE_TASK_END_DATE_YEAR:
				setTaskEndDateYear(returnObject, content);
				break;
			case CASE_TASK_END_DATE_HOUR:
				setTaskEndDateHour(returnObject, content);
				break;
			case CASE_TASK_END_DATE_MINUTE:
				setTaskEndDateMinute(returnObject, content);
				break;
			default:
				break;
		}
	}

	private int extractTaskOperation(String taskObjectLine) {
		for (int titleIndex = 0; titleIndex < constants.getTotalTitles(); ++titleIndex) {
			if (taskObjectLine.startsWith(constants.getTaskObjectTitle(titleIndex))) {
				return titleIndex;
			}
		}
		return CASE_TASK_END;
	}

	private String[] extractContent(int index, String string) {
		return string.split(constants.getTaskObjectTitle(index));
	}

	private void setTaskEndDateMinute(TaskObject returnObject, String[] content) {
		returnObject.setEndDateMinute(Integer.parseInt(content[CONTENT].trim()));
	}

	private void setTaskEndDateHour(TaskObject returnObject, String[] content) {
		returnObject.setEndDateHour(Integer.parseInt(content[CONTENT].trim()));

	}

	private void setTaskEndDateYear(TaskObject returnObject, String[] content) {
		returnObject.setEndDateYear(Integer.parseInt(content[CONTENT].trim()));

	}

	private void setTaskEndDateMonth(TaskObject returnObject, String[] content) {
		returnObject.setEndDateMonth(Integer.parseInt(content[CONTENT].trim()));

	}

	private void setTaskEndDateDay(TaskObject returnObject, String[] content) {
		returnObject.setEndDateDay(Integer.parseInt(content[CONTENT].trim()));
	}

	private void setTaskType(TaskObject returnObject, String[] content) {
		returnObject.setTaskType(content[CONTENT].trim());
	}

	private void setTaskStatus(TaskObject returnObject, String[] content) {
		String taskStatus = content[CONTENT].trim();
		returnObject.setTaskStatus(taskStatus);
	}

	private void setTaskLocation(TaskObject returnObject, String[] content) {
		returnObject.setLocation(content[CONTENT].trim());
	}

	private void setTaskDuration(TaskObject returnObject, String[] content) {
		returnObject.setDuration(Integer.parseInt(content[CONTENT].trim()));
	}

	private void setTaskMinute(TaskObject returnObject, String[] content) {
		returnObject.setDateMinute(Integer.parseInt(content[CONTENT].trim()));
	}

	private void setTaskHour(TaskObject returnObject, String[] content) {
		returnObject.setDateHour(Integer.parseInt(content[CONTENT].trim()));
	}

	private void setTaskYear(TaskObject returnObject, String[] content) {
		returnObject.setDateYear(Integer.parseInt(content[CONTENT].trim()));
	}

	private void setTaskMonth(TaskObject returnObject, String[] content) {
		returnObject.setDateMonth(Integer.parseInt(content[CONTENT].trim()));
	}

	private void setTaskDay(TaskObject returnObject, String[] content) {
		returnObject.setDateDay(Integer.parseInt(content[CONTENT].trim()));
	}

	private void setTaskName(TaskObject returnObject, String[] content) {
		String name = content[CONTENT].trim();
		returnObject.setTaskName(extractNullOrName(name));
	}

	private String extractNullOrName(String name) {
		return name.equals(constants.getNullString()) ? null : name;
	}

	private boolean isNoContentFound(String[] content) {
		return content.length == NO_CONTENT;
	}

	private boolean isNullString(String string) {
		return string == null;
	}

	/**
	 * To convert one task into a string for storage
	 * 
	 * @param task
	 * @return String for store into file
	 */
	public String convertTaskObjectToString(TaskObject task) {
		StringBuffer convertedString = new StringBuffer(constants.getEmptyString());

		for (int index = 0; index < constants.getTotalTitles(); ++index) {
			convertedString.append(extractItemFromTaskObject(index, task));
		}

		return convertedString.toString();
	}

	private StringBuffer extractItemFromTaskObject(int taskObjectLine, TaskObject task) {
		StringBuffer taskObjectBuffer = initializeTempBufferLine(taskObjectLine);
		switch (taskObjectLine) {
			case CASE_TASK_NAME:
				writeTaskNameToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_DATE_DAY:
				writeTaskDayToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_DATE_MONTH:
				writeTaskMonthToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_DATE_YEAR:
				writeTaskYearToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_DATE_HOUR:
				writeTaskHourToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_DATE_MINUTE:
				writeTaskMinuteToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_DURATION:
				writeTaskDurationToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_LOCATION:
				writeTaskLocationToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_STATUS:
				writeTaskGetStatusToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_TYPE:
				writeGetTaskTypeToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_END_DATE_DAY:
				writeGetTaskEndDateDayToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_END_DATE_MONTH:
				writeGetTaskEndDateMonthToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_END_DATE_YEAR:
				writeGetTaskEndDateYearToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_END_DATE_HOUR:
				writeGetTaskEndDateHourToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_END_DATE_MINUTE:
				writeGetTaskEndDateMinuteToStringBuffer(task, taskObjectBuffer);
				break;
			case CASE_TASK_END:
				break;
			default:
				break;
		}
		taskObjectBuffer.append(constants.getNewLine());
		return taskObjectBuffer;
	}

	private StringBuffer initializeTempBufferLine(int taskObjectLine) {
		StringBuffer tempBuffer = new StringBuffer(constants.getEmptyString());
		tempBuffer.append(constants.getTaskObjectTitle(taskObjectLine));
		tempBuffer.append(constants.getSpace());
		return tempBuffer;
	}

	private void writeGetTaskEndDateMinuteToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getEndDateMinute());
	}

	private void writeGetTaskEndDateHourToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getEndDateHour());
	}

	private void writeGetTaskEndDateYearToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getEndDateYear());
	}

	private void writeGetTaskEndDateMonthToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getEndDateMonth());
	}

	private void writeGetTaskEndDateDayToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getEndDateDay());
	}

	private void writeGetTaskTypeToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getTaskType());
	}

	private void writeTaskGetStatusToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getTaskStatus());
	}

	private void writeTaskLocationToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getLocation());
	}

	private void writeTaskDurationToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getDuration());
	}

	private void writeTaskMinuteToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getDateMinute());
	}

	private void writeTaskHourToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getDateHour());
	}

	private void writeTaskYearToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getDateYear());
	}

	private void writeTaskMonthToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getDateMonth());
	}

	private void writeTaskDayToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getDateDay());
	}

	private void writeTaskNameToStringBuffer(TaskObject task, StringBuffer tempBuffer) {
		tempBuffer.append(task.getTaskName());
	}
}
```
###### \src\tasknote\storage\StorageDeadlineUpdater.java
``` java
package tasknote.storage;

import java.util.Calendar;
import java.util.GregorianCalendar;

import tasknote.shared.TaskObject;

/**
 * StorageDeadlineUpdater class checks if the deadline of the task is overdue
 * when the user first opens the application
 */
public class StorageDeadlineUpdater {

	private final GregorianCalendar clock = new GregorianCalendar();
	private StorageConstants constants;

	private int currentYear;
	private int currentMonth;
	private int currentDay;
	private int currentHour;
	private int currentMinute;

	private TaskObject taskObject;

	/**
	 * constructor for StorageDeadlingUpdater
	 */
	public StorageDeadlineUpdater() {
		constants = new StorageConstants();
	}

	/**
	 * Set the TaskObject in the class
	 * 
	 * @param taskObject
	 */
	public void setTaskObject(TaskObject taskObject) {
		this.taskObject = taskObject;
	}

	/**
	 * Update the taskObject given if overdue
	 * 
	 * @param taskObject
	 */
	public void updateTaskStatus(TaskObject taskObject) {
		setTaskObject(taskObject);
		assert isValidTaskObject();
		updateTime();
		updateTaskObject();
	}

	private boolean isValidTaskObject() {
		return this.taskObject != null;
	}

	private void updateTime() {
		updateCalendar();
		updateClock();
	}

	private void updateClock() {
		currentHour = clock.get(Calendar.HOUR_OF_DAY);
		currentMinute = clock.get(Calendar.MINUTE);
	}

	private void updateCalendar() {
		currentYear = clock.get(Calendar.YEAR);
		currentMonth = constants.getNormalizedMonth(clock.get(Calendar.MONTH));
		currentDay = clock.get(Calendar.DATE);
	}

	private void updateTaskObject() {
		boolean notOverdue = true;
		if (!taskObject.isCompleted() && !taskObject.isFloatingTask()) {
			notOverdue = isOverdue(notOverdue);
		}

		setOverdue(notOverdue);
	}

	private void setOverdue(boolean notOverdue) {
		if (!notOverdue) {
			taskObject.setTaskStatus(TaskObject.TaskStatus.TASK_OVERDUE);
		}
	}

	private boolean isOverdue(boolean notOverdue) {
		notOverdue = isOverdueYear(notOverdue);
		notOverdue = isOverdueMonth(notOverdue);
		notOverdue = isOverdueDay(notOverdue);
		notOverdue = isOverdueHour(notOverdue);
		notOverdue = isOverdueMinute(notOverdue);
		return notOverdue;
	}

	private boolean isOverdueMinute(boolean notOverdue) {
		if (isSameHour() && notOverdue) {
			notOverdue = isOverdueMinute();
		}
		return notOverdue;
	}

	private boolean isOverdueHour(boolean notOverdue) {
		if (isSameDay() && notOverdue) {
			notOverdue = isOverdueHour();
		}
		return notOverdue;
	}

	private boolean isOverdueDay(boolean notOverdue) {
		if (isSameMonth() && notOverdue) {
			notOverdue = isOverdueDay();
		}
		return notOverdue;
	}

	private boolean isOverdueMonth(boolean notOverdue) {
		if (isSameYear() && notOverdue) {
			notOverdue = isOverdueMonth();
		}
		return notOverdue;
	}

	private boolean isOverdueYear(boolean notOverdue) {
		if (notOverdue) {
			notOverdue = isOverdueYear();
		}
		return notOverdue;
	}

	private boolean isSameYear() {
		return taskObject.getDateYear() == currentYear;
	}

	private boolean isSameMonth() {
		return taskObject.getDateMonth() == currentMonth;
	}

	private boolean isSameDay() {
		return taskObject.getDateDay() == currentDay;
	}

	private boolean isSameHour() {
		return taskObject.getDateHour() == currentHour;
	}

	private boolean isOverdueYear() {
		return taskObject.getDateYear() >= currentYear;
	}

	private boolean isOverdueMonth() {
		return taskObject.getDateMonth() >= currentMonth;
	}

	private boolean isOverdueDay() {
		return taskObject.getDateDay() >= currentDay;
	}

	private boolean isOverdueHour() {
		return taskObject.getDateHour() >= currentHour;
	}

	private boolean isOverdueMinute() {
		return taskObject.getDateMinute() >= currentMinute;
	}
}
```
###### \src\tasknote\storage\StorageTest.java
``` java
package tasknote.storage;

import static org.junit.Assert.*;

import java.io.File;
import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Random;

import org.junit.Before;
import org.junit.Test;
import tasknote.shared.AddDuplicateAliasException;
import tasknote.shared.TaskListIOException;
import tasknote.shared.TaskObject;

/**
 * this class does jUnit testing for the whole Storage Component
 *
 */
public class StorageTest {
	// various different paths
	private static final String PATH_NAME_DEFAULT = "C:\\blablabla.txt";
	private static final String PATH_NAME_INVALID = "C:/z2fhi";
	private static final String PATH_NAME_WITH_TEXT_FILE = "C:/markes.txt";
	private static final String PATH_NAME_WITHOUT_SLASH = "C:/.";
	private static final String PATH_NAME_RELATIVE = "./.././../snake.txt";
	private static final String PATH_NAME_TEXT_FILE_ONLY = "W152JGroup.txt";
	private static final String PATH_NAME_RELATIVE_ONLY = ".././../.././../../..";

	// To set up random dates
	private static final int BASE_MINUTE = 1;
	private static final int BASE_DATE = 1;
	private static final int BASE_YEAR = 2017;
	private static final int RAND_RANGE_MINUTE = 60;
	private static final int RAND_RANGE_HOUR = 24;
	private static final int RAND_RANGE_DAY = 28;
	private static final int RAND_RANGE_MONTH = 11;
	private static final int RAND_RANGE_YEAR = 40;

	// To set up a confirmed overdue time that is today
	private static final GregorianCalendar calendar = new GregorianCalendar();
	private static final int YEAR = calendar.get(Calendar.YEAR);
	private static final int MONTH = calendar.get(Calendar.MONTH) + BASE_DATE;
	private static final int DAY = calendar.get(Calendar.DATE);
	private static final int HOUR = calendar.get(Calendar.HOUR_OF_DAY);
	private static final int MINUTE = calendar.get(Calendar.MINUTE) - BASE_MINUTE;

	// Magic Integers
	private static final int ARRAY_MAX_SIZE = 10;
	private static final int OVERDUE_TASK_SIZE = 1;

	// for setting up alias
	private static final String COMMAND_ADD = "add";
	private static final String COMMAND_CHANGE_PATH = "relocate";
	private static final String COMMAND_EDIT = "edit";
	private static final String COMMAND_DELETE = "delete";

	private static final String ALIAS_ADD_INCLUDE = "include";
	private static final String ALIAS_ADD_PUSH = "push";
	private static final String ALIAS_CHANGE_PATH_CD = "cd";
	private static final String ALIAS_EDIT_MODIFY = "modify";
	private static final String ALIAS_DELETE_REMOVE = "remove";

	Storage storage;
	FileManipulation fileManipulator;
	PathManipulation pathManipulator;
	Random random;

	// local variables
	private int year;
	private int month;
	private int day;
	private int hour;
	private int minute;
	private ArrayList<TaskObject> tempArrayList1;
	private ArrayList<TaskObject> tempArrayList2;
	private ArrayList<TaskObject> tempArrayList3;
	private ArrayList<TaskObject> returnedTempArrayList;
	private TaskObject randomFutureTaskObject;
	private TaskObject overdueTaskObject;
	private int tempArrayList2Size;
	private int tempArrayList3Size;
	private HashMap<String, String> fullAlias;

	@Before
	public void setUp() throws Exception {
		// set up class
		storage = new Storage();
		fileManipulator = new FileManipulation();
		pathManipulator = new PathManipulation();
		random = new Random();

		tempArrayList2Size = random.nextInt(ARRAY_MAX_SIZE);
		tempArrayList3Size = random.nextInt(ARRAY_MAX_SIZE) + OVERDUE_TASK_SIZE;

		// add a specific item
		tempArrayList1 = new ArrayList<TaskObject>();
		tempArrayList2 = new ArrayList<TaskObject>();
		tempArrayList3 = new ArrayList<TaskObject>();
		fullAlias = new HashMap<String, String>();

		overdueTaskObject = initializeOverdueTaskObject();
		randomFutureTaskObject = initializeTaskObject();

		setUpTempArrayContents();
	}

	private void setUpTempArrayContents() {
		tempArrayList1.add(randomFutureTaskObject);

		for (int index = 0; index < tempArrayList2Size; ++index) {
			tempArrayList2.add(randomFutureTaskObject);
		}

		for (int index = 1; index < tempArrayList3Size; ++index) {
			tempArrayList3.add(randomFutureTaskObject);
		}
		tempArrayList3.add(overdueTaskObject);
	}

	private TaskObject initializeOverdueTaskObject() {
		TaskObject tempTaskObject = new TaskObject();
		tempTaskObject.setDateYear(YEAR);
		tempTaskObject.setDateMonth(MONTH);
		tempTaskObject.setDateDay(DAY);
		tempTaskObject.setDateHour(HOUR);
		tempTaskObject.setDateMinute(MINUTE);
		tempTaskObject.setTaskType(TaskObject.TASK_TYPE_DEADLINE);
		return tempTaskObject;
	}

	private TaskObject initializeTaskObject() {
		TaskObject tempTaskObject = new TaskObject();
		year = random.nextInt(RAND_RANGE_YEAR) + BASE_YEAR;
		month = random.nextInt(RAND_RANGE_MONTH) + BASE_DATE;
		day = random.nextInt(RAND_RANGE_DAY) + BASE_DATE;
		hour = random.nextInt(RAND_RANGE_HOUR);
		minute = random.nextInt(RAND_RANGE_MINUTE);
		tempTaskObject.setDateYear(year);
		tempTaskObject.setDateMonth(month);
		tempTaskObject.setDateDay(day);
		tempTaskObject.setDateHour(hour);
		tempTaskObject.setDateMinute(minute);
		return tempTaskObject;
	}

	@Test
	public final void test() throws IOException, TaskListIOException, InvalidPathException {
		try {
			testReadAndWriteTaskObjects();
			testPathManipulation();
			testAliasManipulation();
		} catch (IOException ioe) {
			ioe.printStackTrace();
		} catch (TaskListIOException tlioe) {
			tlioe.printStackTrace();
		}
	}

	private void testReadAndWriteTaskObjects() throws TaskListIOException, IOException {
		// case 1: test loadTasks() is able to load something
		storage.saveTasks(tempArrayList3);
		assertEquals(tempArrayList3.size(), tempArrayList3Size);

		// case 2: test cleanFile()
		storage.cleanTextFile();
		assertTrue(storage.loadTasks().isEmpty());

		// case 2: test if add empty ArrayList will return the same list
		ArrayList<TaskObject> emptyArrayList = new ArrayList<TaskObject>();
		storage.saveTasks(emptyArrayList);
		assertTrue(storage.loadTasks().equals(emptyArrayList));

		// case 3: test if add a random generated ArrayList<TaskObject> will
		// return the same arrayList
		storage.saveTasks(tempArrayList1);
		assertTrue(storage.loadTasks().equals(tempArrayList1));

		// case 4: test if add n items into storage and retrieval equals same
		// list
		storage.saveTasks(tempArrayList2);
		returnedTempArrayList = storage.loadTasks();
		assertTrue(returnedTempArrayList.equals(tempArrayList2));

		// case 5: test if StorageDeadlineUpdater successfully updated the task
		// if overdued

		// Firstly, check the previous taskObject is TASK_OUTSTANDING
		assertTrue(overdueTaskObject.getTaskStatus().equals(TaskObject.TaskStatus.TASK_OUTSTANDING));
		storage.saveTasks(tempArrayList3);
		returnedTempArrayList = storage.loadTasks();
		// Next, check that the arrayList has changed
		assertFalse(returnedTempArrayList.equals(tempArrayList3));
		TaskObject overduedTask = returnedTempArrayList.get(tempArrayList3Size - OVERDUE_TASK_SIZE);
		// Finally check if the returned overdued task is really set to
		// TASK_OVERDUE
		assertTrue(overduedTask.getTaskStatus().equals(TaskObject.TaskStatus.TASK_OVERDUE));
	}

	private void testPathManipulation() throws IOException, TaskListIOException {
		// case 1: undo PATH where there is no history
		assertFalse(storage.undoPath());

		// case 2: change absolute PATH with a correct PATH but without slash
		assertTrue(storage.changePath(PATH_NAME_WITHOUT_SLASH));
		String fullPathNameWithoutSlash = fileManipulator.readFullPathFromPathFile();
		File firstFile = new File(fullPathNameWithoutSlash);
		assertTrue(firstFile.exists());

		// case 3: change absolute PATH with a different file
		// also test that the previous file is deleted
		// additional test that the items inside the storage is still there
		assertTrue(storage.changePath(PATH_NAME_WITH_TEXT_FILE));
		String fullPathNameWithTextFile = fileManipulator.readFullPathFromPathFile();
		File tempFile = new File(fullPathNameWithTextFile);
		assertTrue(tempFile.exists());
		ArrayList<TaskObject> tasks = storage.loadTasks();
		assertTrue(returnedTempArrayList.equals(tasks));

		// case 4: change PATH to an invalid PATH
		// also check that the current path is still retained at the previous
		// path
		assertFalse(storage.changePath(PATH_NAME_INVALID));
		String path = fileManipulator.readFullPathFromPathFile();
		assertTrue(path.equals(fullPathNameWithTextFile));
		assertTrue(tempFile.exists());

		// case 5: undo PATH
		assertTrue(storage.undoPath());
		path = fileManipulator.readFullPathFromPathFile();
		assertTrue(path.equals(fullPathNameWithoutSlash));

		// case 6: redo PATH
		assertTrue(storage.redoPath());
		path = fileManipulator.readFullPathFromPathFile();
		assertTrue(path.equals(fullPathNameWithTextFile));

		// case 7: redo PATH when there is no future history
		assertFalse(storage.redoPath());
		path = fileManipulator.readFullPathFromPathFile();
		assertTrue(path.equals(fullPathNameWithTextFile));

		// case 8: test if storage undo and does a valid change PATH does the
		// redo PATH remains
		// test with previous passed tests
		storage.undoPath(); // expect to the path without slash
		storage.changePath(PATH_NAME_WITHOUT_SLASH);
		assertFalse(storage.redoPath()); // if it exist would be the path with
											// text file
		path = fileManipulator.readFullPathFromPathFile();
		assertTrue(path.equals(fullPathNameWithoutSlash));

		// case 8: change PATH to original PATH
		assertTrue(storage.changePath(PATH_NAME_DEFAULT));
		String fullPathNameDefault = fileManipulator.readFullPathFromPathFile();
		tempFile = new File(fullPathNameDefault);
		assertTrue(tempFile.exists());

		// case 9: change PATH with relative PATH
		assertTrue(storage.changePath(PATH_NAME_RELATIVE));
		String absolutePath = fileManipulator.readFullPathFromPathFile();
		assertTrue(pathManipulator.isAbsolutePath(absolutePath));

		// case 10: change PATH with ONLY fileName
		assertTrue(storage.changePath(PATH_NAME_TEXT_FILE_ONLY));
		String newTextFilePath = fileManipulator.readFullPathFromPathFile();
		fileManipulator.moveFile(newTextFilePath); //ensure fileManipulator is updated (different set of instance)
		assertTrue(fileManipulator.getTextFileName().equals(PATH_NAME_TEXT_FILE_ONLY));
		assertFalse(absolutePath.equals(newTextFilePath));

		// case 11: change PATH with multiple local PATHS
		assertTrue(storage.changePath(PATH_NAME_RELATIVE_ONLY));
		String relativePath = fileManipulator.readFullPathFromPathFile();
		tempFile = new File(relativePath);
		assertTrue(tempFile.exists());
	}

	private void testAliasManipulation() throws IOException {
		boolean isAddExceptionThrown = false;
		try {
			// case 1: test undo command when there isn't any
			storage.undoAlias();
			storage.undoAlias();
			assertFalse(storage.undoAlias());

			// case 2: clean the alias file and check that it gets a valid empty
			// HasMap
			storage.cleanAliasFile();
			HashMap<String, String> emptyAlias = storage.getAlias();
			assertTrue(emptyAlias.isEmpty());

			// case 3: test addAlias
			storage.addAlias(COMMAND_ADD, ALIAS_ADD_INCLUDE);
			assertTrue(storage.getAlias(ALIAS_ADD_INCLUDE).equals(COMMAND_ADD));

			// case 4: test duplicate alias added (Only tested outside try-catch
			// block)
			storage.addAlias(COMMAND_CHANGE_PATH, ALIAS_ADD_INCLUDE);
		} catch (AddDuplicateAliasException e) {
			isAddExceptionThrown = true;
		}
		assertTrue(isAddExceptionThrown);

		// case 5: fillup fullAlias and test saveAlias
		fullAlias.put(ALIAS_ADD_INCLUDE, COMMAND_ADD);
		fullAlias.put(ALIAS_CHANGE_PATH_CD, COMMAND_CHANGE_PATH);
		fullAlias.put(ALIAS_ADD_PUSH, COMMAND_ADD);
		fullAlias.put(ALIAS_EDIT_MODIFY, COMMAND_EDIT);
		fullAlias.put(ALIAS_DELETE_REMOVE, COMMAND_DELETE);

		storage.saveAlias(fullAlias);
		assertTrue(storage.getAlias().equals(fullAlias));

		// case 6: test remove an alias
		storage.removeAlias(ALIAS_EDIT_MODIFY);
		HashMap<String, String> aliasRemovedContent = storage.getAlias();
		assertFalse(aliasRemovedContent.containsKey(ALIAS_EDIT_MODIFY));

		// case 7: test undo command for alias
		assertTrue(storage.undoAlias());
		HashMap<String, String> undoedAlias = storage.getAlias();
		assertTrue(undoedAlias.equals(fullAlias));

		// case 8: test redo command for alias
		assertTrue(storage.redoAlias());
		HashMap<String, String> redoedAlias = storage.getAlias();
		assertTrue(redoedAlias.equals(aliasRemovedContent));

		// case 9: test redo command when there isn't any
		assertFalse(storage.redoAlias());
		redoedAlias = storage.getAlias();
		assertTrue(redoedAlias.equals(aliasRemovedContent));

	}
}
```
